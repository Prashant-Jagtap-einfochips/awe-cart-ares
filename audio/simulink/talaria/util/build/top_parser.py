#!/usr/bin/env python
###############################################################################
#
# BOSE CORPORATION
# COPYRIGHT (c) BOSE CORPORATION ALL RIGHTS RESERVED
# This program may not be reproduced, in whole or in part in any
# form or any means whatsoever without the written permission of:
# BOSE CORPORATION
# The Mountain
# Framingham, MA 01701-9168
#
# translation_engine Loads a translation engine into python.
#   Given the full path of the dll corresponding to the translation engine
#   this routine loads the dll. If successful, 
#   the resulting object can be used to access the translation engine.
# Note: The translation engine must be built with the same
# machine architecture as the python (i.e. 64 vs. 32 bit)
################################################################################
import sys
import warnings
import os
import xml.etree.ElementTree as ET
from collections import namedtuple
from payload_parser import payload_parser

class top_parser:
    '''
    top_parser Loads the generated TOP_Tokens.xml file and enables
    conversion between binary-packed payloads and string representations of
    TOP payloads
    '''
    def __init__(self, TopTokensXmlFilePath, isLittleEndian=True):
        '''
        top_parser Constructs a TOP parser object.
        Given a TOP_Tokens.XML file to describe the tokens. Payload definitions are
        manually known and described within this class
        '''
        if (False == os.path.isfile(TopTokensXmlFilePath)):
            raise Exception('Could not find TOP XML file %s' % TopTokensXmlFilePath)
        else:
            self.XmlFilePath = TopTokensXmlFilePath

        self.isLittleEndian = isLittleEndian
        payload_parser.isLittleEndian = isLittleEndian
        tree = ET.parse(self.XmlFilePath)

        self.MapFPathToTopInfoStruct = dict()
        self.MapTokenToFPath = dict()
        for elem in tree.iter():
            if elem.tag == 'TOP':
                attribute = elem.attrib
                id = attribute.get('id')
                writeToken = attribute.get('writeToken')
                readToken = attribute.get('readToken')
                self.MapFPathToTopInfoStruct[id] = attribute
                self.MapTokenToFPath[writeToken] = id
                self.MapTokenToFPath[readToken] = id
    
    def GetReadToken(self, featurePath):
        '''
        GetReadToken returns string hex readToken for the specified
        TOP featurePath string.
        Usage:
            readToken = obj.GetReadToken(featurePath);
        '''
        top = self.MapFPathToTopInfoStruct[featurePath]
        return top.get('readToken')

    def GetWriteToken(self, featurePath):
        '''
        GetWriteToken returns string hex writeToken for the specified
        TOP featurePath string.
        Usage:
            writeToken = obj.GetWriteToken(featurePath);
        '''
        top = self.MapFPathToTopInfoStruct[featurePath]
        return top.get('writeToken')
    
    def PackTopWriteFromEngineString(self, translationEngineString):
        '''
        PackTopWriteFromEngineString packs a binary TOP write
        request directly from a string generated by the translation
        engine. These strings contain featurepath name, datatatype,
        and a space-delimited list of values all in one string to set
        the entire TOP.
        Usage:
           binaryPayload = obj.PackTopWriteFromEngineString(this, translationEngineString);
        
        See also: ext_port_model.HandleAsdIdRequest, PackTopWriteFromString, ext_port_model.SetTOP
        '''
        if isinstance(translationEngineString,list):
            if len(translationEngineString) > 1:
                raise Exception('Translation engine string appears to contain more than one translation. Send one at a time');
            translationEngineString = str(translationEngineString[0])
        else:
            translationEngineString = str(translationEngineString)
        strParts = translationEngineString.split()
        # Extra validation: Make sure the datatype matches
        featurePath = strParts[0]
        dataTypeStr = strParts[1]
        strValues = strParts[2:]
        topInfoStruct = self.MapFPathToTopInfoStruct[featurePath]
        if (topInfoStruct.get('dataType') != dataTypeStr):
            raise Exception('Engine string datatype [%s] does not match TOP datatype from XML definition [%s]' % (topInfoStruct.dataType,dataTypeStr));
        # Forward to the more flexible payload packing routine that
        # includes the ability to use offsets (although no need to use
        # one here)
        return self.PackTopWriteFromString(featurePath,strValues)
    
    def PackTopWriteFromString(self, featurePath, strValues, charOffset=0):
        '''
        PackTopWrite Packs a TOP write request payload given
        featurePath and string data (space-delimited or string array)
        separately specifying featurePath, values, and charOffset.
        Usage:
          binaryPayload = obj.PackTopWrite(featurePath, strValues, charOffset)
        
        strValues can be a single space-delimited or a string array.
        If not provided, charOffset is assumed to be 0.
        
        Example for a TOP of type single with write token 0x01000000:
           obj.PackTopWriteFromString('MyVector','1 2 3 4')
        
        See also: ext_port_model.HandleAsdIdRequest, PackTopWriteFromEngineString, ext_port_model.SetTOP
        '''
        # Retrieve specifications for this TOP.
        topInfoStruct = self.MapFPathToTopInfoStruct[featurePath];

        # Understand datatype's size in count of uint8s
        dtBytes, dataType = payload_parser.GetDataTypeBytes(topInfoStruct.get('dataType'));

        # Split the strValues if they are not already
        if isinstance(strValues, str):
            strValues = strValues.split()
            widthToSet = len(strValues)
        elif isinstance(strValues,list):
            widthToSet = len(strValues)
        else:
            raise Exception('strValues needs be a single space-delimited or a string array: %s' % strValues)

        # Calculate how much data is to be set in uint8s
        charsToSet = widthToSet * dtBytes

        # Arrange payload specs and content
        signalsList = "topId callerHandle offset byteCount data"
        signalValueList = [
            str(topInfoStruct.get('writeToken')),       # topId
            "0",                                        # callerHandle
            str(charOffset),                            # charOffset
            str(charsToSet),                            # byteCount
            ]
        signalValueList = signalValueList + strValues   # data
        signalNames = signalsList.split()
        srcStrArray = signalValueList

        # Use a payload_parser specStruct to help pack the request
        specStruct = payload_parser.InitSpecStruct()
        specStruct.featurePath = topInfoStruct.get('id')

        for i in range(len(signalNames)):
            specStruct.sigName = signalNames[i]
            if ("data" == signalNames[i]):
                # data has special handling
                specStruct.dataType = topInfoStruct.get('dataType')
                specStruct.width = widthToSet
            else:
                specStruct.dataType = GetSigDataType(specStruct.sigName)
                specStruct.width = 1
            [srcStrArray,specStruct] = payload_parser.PackPayloadElement(srcStrArray,specStruct)
        
        return specStruct.binaryPayload

    def PackTopRead(self, featurePath, charOffset=0, byteCount=''):
        '''
        PackTopRead Packs a TOP read request payload given
        featurePath, offset, and byteCount
        Usage:
          binaryPayload = obj.PackTopRead(this, featurePath, charOffset, byteCount)
        
        See also: ext_port_model.HandleAsdIdRequest, ext_port_model.GetTOP
        '''

        # Retrieve specifications for this TOP,
        # and understand datatype's size in count of uint8s
        topInfoStruct = self.MapFPathToTopInfoStruct[featurePath]
        dtBytes, dataType = payload_parser.GetDataTypeBytes(topInfoStruct.get('dataType'))

        # If no byteCount was given - read it all
        if (byteCount == ''):
            byteCount = dtBytes * int(topInfoStruct.get('width')) - charOffset
        
        # Arrange payload specs and content
        signalsList = "topId callerHandle offset byteCount"
        signalValueList = [
            str(topInfoStruct.get('readToken')),    # topId
            "0",                                    # callerHandle
            str(charOffset),                        # charOffset
            str(byteCount),                         # byteCount
            ]
        signalNames = signalsList.split()
        srcStrArray = signalValueList

        # Use a payload_parser specStruct to help pack the request
        specStruct = payload_parser.InitSpecStruct()
        specStruct.featurePath = topInfoStruct.get('id')

        for i in range(len(signalNames)):
            specStruct.sigName = signalNames[i]
            specStruct.dataType = GetSigDataType(specStruct.sigName)
            specStruct.width = 1
            [srcStrArray,specStruct] = payload_parser.PackPayloadElement(srcStrArray,specStruct)
        
        return specStruct.binaryPayload

    def UnpackRequest(self, binaryPayload):
        return self.UnpackPayload(binaryPayload, True);

    def UnpackResponse(self, binaryPayload):
        return self.UnpackPayload(binaryPayload, False);

    def UnpackPayload(self, binaryPayload, isRequest=False):
        '''
        UnpackPayload Returns a MATLAB struct given a binary payload
        and the knowledge of whether to unpack a request or response.
        If not provided, isRequest is assumed false;
        Usage:
          theStruct = obj.UnpackPayload(binaryPayload, isRequest)
        '''
        
        # Retrieve the token from the payload and lookup feature path
        byteArr = bytearray(binaryPayload[0:4])
        if self.isLittleEndian:
            token = int.from_bytes(byteArr, byteorder='little', signed=False)
        else:
            token = int.from_bytes(byteArr, byteorder='big', signed=False)
        tokenStr = "0x{:08x}".format(token)
        featurePath = self.MapTokenToFPath[tokenStr]

        class Struct():
            pass
        theStruct = Struct()
        theStruct.CalcFeaturePath = featurePath
        theStruct.CalcToken = tokenStr

        # Understand TOP's datatype and size in count of uint8s
        topInfoStruct = self.MapFPathToTopInfoStruct[featurePath]
        dtBytes, dataType = payload_parser.GetDataTypeBytes(topInfoStruct.get('dataType'))

        # Determine which of the 4 types of payloads to unpack
        if ((token & 0x80000000) > 0):
            # This is a READ
            if (isRequest):
                # Read Request
                theStruct.CalcPayloadType = 'TOP Read Request'
                signalsList = "topId callerHandle offset byteCount"
            else:
                # Read Response
                theStruct.CalcPayloadType = 'TOP Read Response'
                signalsList = "topId callerHandle statusCode byteCount data"
        else:
            # This is a WRITE
            if (isRequest):
                # Write request
                theStruct.CalcPayloadType = 'TOP Write Request'
                signalsList = "topId callerHandle offset byteCount data"
            else:
                # Write response
                theStruct.CalcPayloadType = 'TOP Write Response'
                signalsList = "topId callerHandle statusCode"

        # Use a payload_parser specStruct to help unpack the request
        specStruct = payload_parser.InitSpecStruct()
        specStruct.featurePath = featurePath
        specStruct.binaryPayload = binaryPayload
        
        # Pull out all signals using XML doc as payload specification
        signalNames = signalsList.split()
        for i in range(len(signalNames)):
            specStruct.sigName = signalNames[i]
            if ("data" == signalNames[i]):
                # the data payload element is variable size and type
                specStruct.dataType = topInfoStruct.get('dataType')
                specStruct.width = int(theStruct.byteCount / dtBytes)
                # Include additional "calculated" information in result
                theStruct.CalcTopDatatype = topInfoStruct.get('dataType')
                theStruct.CalcWidth = int(specStruct.width)
            else:
                specStruct.width = 1
                specStruct.dataType = GetSigDataType(specStruct.sigName)
            theStruct, specStruct = payload_parser.UnpackPayloadElement(theStruct,specStruct)
            # If a status code has just been unpacked, also include
            # it's string translation:
            if ("statusCode" == signalNames[i]):
                theStruct.CalcStatusCodeStr = payload_parser.GetStatusCodeStr(theStruct.statusCode)

        # Diagnostic information
        unparsedCount = len(binaryPayload) - specStruct.charItr
        if (0 < unparsedCount):
            theStruct.CalcUnparsedBytes = unparsedCount
            warnings.warn('[%d] additional bytes in payload that were not parsed' % unparsedCount)

        return theStruct

# Local helper function (e.g. like private static, but without hassle)
def GetSigDataType(sigName):
    if(sigName == 'statusCode'):
        dataType = 'int32';
    else:
        dataType = 'uint32';
    return dataType
