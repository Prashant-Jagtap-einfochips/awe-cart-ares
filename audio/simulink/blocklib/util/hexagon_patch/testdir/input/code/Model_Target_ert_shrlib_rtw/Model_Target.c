/*
 * File: Model_Target.c
 *
 * Code generated for Simulink model 'Model_Target'.
 *
 * Model version                  : 1.12
 * Simulink Coder version         : 9.8 (R2022b) 13-May-2022
 * C/C++ source code generated on : Wed Dec 20 15:13:20 2023
 *
 * Target selection: ert_shrlib.tlc
 * Embedded hardware selection: Qualcomm->Hexagon
 * Emulation hardware selection:
 *    Differs from embedded hardware (MATLAB Host)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "Model_Target.h"
#include "rtwtypes.h"
#include "Model_Target_private.h"
#include "qhmath.h"
#include <math.h>
#include "Model_Target_types.h"
#include <string.h>
#include "PostProcess.h"
#include "circbuf.h"
#include "MedusaExpandTailComps.h"
#include "fir_hexagon.h"
#include "pooliir_hexagon.h"
#include "qhblas.h"
#include "qhcomplex.h"
#include "qhdsp.h"
#include "qhdsp_common.h"
#include "qhdsp_iir.h"
#include "fireven_hexagon.h"
#include "qhdsp_fft_internal.h"
#include "qhl_common.h"
#include "rt_sys_Model_Target_100.h"
#include "Ifir.h"
#include "blkutil.h"
#include "rfft_hexagon.h"
#include "MedusaPostHoligram.h"
#include "rt_sys_Model_Target_107.h"
#include "rt_sys_Model_Target_105.h"
#include "rt_sys_Model_Target_104.h"
#include "PreAmpPart2.h"
#include "VLS.h"
#include "Model_Target_MedusaDelays.h"
#include "Model_Target_FirGenericStorage.h"
#include "PoolDelayStorage.h"
#include "Model_Target_MedusaHoligramEq.h"
#include "FirStorage.h"
#include "tsp_capture_settings.h"
#include "FFTBuffers.h"

/* Named constants for MATLAB Function: '<S197>/InnerLink' */
#define Model_Target_SuperFastDecayMultiplier (30.0F)

/* Named constants for MATLAB Function: '<S1079>/InnerLink' */
#define Model_Target_SuperFastDecayMultiplier_k (3.0F)

/* Named constants for MATLAB Function: '<S1704>/Delay Line Update' */
#define Model_Target_fixedDelayLength  (660)

/* Named constants for MATLAB Function: '<S1706>/Delay Line Update' */
#define Model_Target_fixedDelayLength_l (540)

/* Named constants for MATLAB Function: '<S1273>/Detect Impulse' */
#define Model_Target_MaxValueOfCounterForDetectingImpulse (4.0)

/* Named constants for MATLAB Function: '<S1357>/Detect Impulse' */
#define Model_Target_MaxValueOfCounterForDetectingImpulse_n (16.0)

/* Named constants for MATLAB Function: '<S1392>/Mono Detector' */
#define Model_Target_maxZeroLevelCount (693.0)

/* Exported data definition */

/* Definition for custom storage class: ApiBuffer */
real32_T UnitTest_Target_AudioIn[160]; /* '<Root>/BoseAudioIn' */
real32_T UnitTest_Target_AudioOut[768];/* '<S630>/PoolIirProcess' */

/* Definition for custom storage class: ExportToFile */
real32_T DeciRateBassDelay[1482];      /* '<S1434>/Data Store Memory' */
real32_T DeciRateSpeakerDelay[10170];  /* '<S1782>/Data Store Memory' */
real32_T FullRateBassDelay[70];        /* '<S1435>/Data Store Memory' */
real32_T FullRateSpeakerDelay[30822];  /* '<S1783>/Data Store Memory' */
real32_T MidrangeDelay[1392];          /* '<S1433>/Data Store Memory' */
real32_T PeripheralDelayBuffer[11880]; /* '<S1704>/Data Store Memory' */
real32_T TrebleDelay[8552];            /* '<S1209>/Data Store Memory' */

/* Block signals (default storage) */
B_Model_Target_T Model_Target_B;

/* Block states (default storage) */
DW_Model_Target_T Model_Target_DW;

/* Real-time model */
static RT_MODEL_Model_Target_T Model_Target_M_;
RT_MODEL_Model_Target_T *const Model_Target_M = &Model_Target_M_;

/* Forward declaration for local functions */
static void Model_Target_sum(const real32_T x_data[], const int32_T x_size[2],
    real32_T y[8]);

/* Forward declaration for local functions */
static void Model_Target_Mixer(const real32_T audioIn[8], const real32_T loc[2],
    const real32_T gainMatrix[25], real_T interp, real32_T mixOut[8]);
static void Model_Target_Mixer_l(const real32_T audioIn[32], const real32_T loc
    [2], const real32_T gainMatrix[25], real_T interp, real32_T mixOut[32]);
static real32_T Model_Target_interp1(const real32_T varargin_1[2], const
    real32_T varargin_2[2], real32_T varargin_3);
static void Model_Target_eml_find_a(const boolean_T x[2], int32_T i_data[],
    int32_T i_size[2]);
static real32_T Model_Target_mod(real32_T x, real32_T y);
static real32_T Model_Target_interp1_m(const real32_T varargin_1[128], const
    real32_T varargin_2[128], real32_T varargin_3);
static void rate_monotonic_scheduler(void);

/* Declare variables for internal data of system '<S1165>/Alignment Delay' */
B_AlignmentDelay_Model_Target_T Model_Target_AlignmentDelay_B;
DW_AlignmentDelay_Model_Target_T Model_Target_AlignmentDelay_DW;

/* Declare variables for internal data of system '<S1137>/Medusa5H1 Part 3' */
B_Medusa5H1Part3_Model_Target_T Model_Target_Medusa5H1Part3_B;
DW_Medusa5H1Part3_Model_Target_T Model_Target_Medusa5H1Part3_DW;

/* Declare variables for internal data of system '<S1137>/Medusa5H1 Part 4' */
B_Medusa5H1Part4_Model_Target_T Model_Target_Medusa5H1Part4_B;
DW_Medusa5H1Part4_Model_Target_T Model_Target_Medusa5H1Part4_DW;

/* Declare variables for internal data of system '<S1137>/Medusa5H1 Part 5' */
B_Medusa5H1Part5_Model_Target_T Model_Target_Medusa5H1Part5_B;
DW_Medusa5H1Part5_Model_Target_T Model_Target_Medusa5H1Part5_DW;

/* Declare variables for internal data of system '<S1137>/Medusa5H1 Part 6' */
B_Medusa5H1Part6_Model_Target_T Model_Target_Medusa5H1Part6_B;
DW_Medusa5H1Part6_Model_Target_T Model_Target_Medusa5H1Part6_DW;

/* Declare variables for internal data of system '<S7>/PreAmpPart1' */
B_PreAmpPart1_Model_Target_T Model_Target_PreAmpPart1_B;
DW_PreAmpPart1_Model_Target_T Model_Target_PreAmpPart1_DW;

// PostProcessMuteCfgSet RTC Request-Response Handler (RTC ID 0x10000018) '<S604>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessMuteCfgSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S604>/Request' */

    /* S-Function (RTC_BytePack): '<S612>/UnpackREQ' */
    PostProcessMuteCfgSet_REQ_T* payloadREQ = (PostProcessMuteCfgSet_REQ_T*)
        pREQBuf;
    Model_TargetPostProcessMuteCfgSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPostProcessMuteCfgSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetPostProcessMuteCfgSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPostProcessMuteCfgSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPostProcessMuteCfgSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPostProcessMuteCfgSet();

    /* Output and update for function-call system: '<S604>/Response' */

    /* S-Function (RTC_BytePack): '<S613>/PackRSP' */
    PostProcessMuteCfgSet_RSP_T* payloadRSP = (PostProcessMuteCfgSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessMuteCfgSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetPostProcessMuteCfgSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PostProcessMuteCfgSet RTC NTF check complete '<S604>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PostProcessMuteCfgSet( void )
{
    /* Output and update for function-call system: '<S604>/NtfCheck' */

    /* MATLAB Function: '<S603>/TriggeredFunction' */
    /* MATLAB Function: '<S603>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S609>:1' */
    /* '<S609>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S615>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S615>:1:9' done = true; */
    Model_Target_PostProcess_B.done = true;

    /* '<S615>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.PostProcessMuteTargetLinearGain !=
            Model_TargetControlDsms.PostProcessMuteCurrentGain)
    {
        /* '<S615>:1:11' done = false; */
        Model_Target_PostProcess_B.done = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S603>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S602>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S605>/In1' */
    Model_Target_PostProcess_B.In1 =
        Model_TargetPostProcessMuteCfgSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S602>/Triggered Subsystem' */
}

// PostProcessMuteCfgSet RTC NTF message preparation and packing '<S604>/NTF Trigger' ---------------------------------
void RtcNtfPack_PostProcessMuteCfgSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S604>/Notification' */

    /* S-Function (RTC_BytePack): '<S608>/PackNTF' */
    PostProcessMuteCfgSet_NTF_T* payloadNTF = (PostProcessMuteCfgSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPostProcessMuteCfgSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_PostProcess_B.In1;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PostProcessLimiterSoftclipParamSet RTC Request-Response Handler (RTC ID 0x10010017) '<S568>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessLimiterSoftclipParamSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S568>/Request' */

    /* S-Function (RTC_BytePack): '<S645>/UnpackREQ' */
    PostProcessLimiterSoftclipParamSet_REQ_T* payloadREQ =
        (PostProcessLimiterSoftclipParamSet_REQ_T*)pREQBuf;
    Model_TargetPostProcessLimiterSoftclipParamSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPostProcessLimiterSoftclipParamSetRtcOut.REQ_paramSet =
        payloadREQ->paramSet;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S568>/Response' */

    /* S-Function (RTC_BytePack): '<S646>/PackRSP' */
    PostProcessLimiterSoftclipParamSet_RSP_T* payloadRSP =
        (PostProcessLimiterSoftclipParamSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessLimiterSoftclipParamSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->paramSet =
        Model_TargetPostProcessLimiterSoftclipParamSetRtcOut.REQ_paramSet;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PostProcessLimiterSoftclipDisable RTC Request-Response Handler (RTC ID 0x10010016) '<S569>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessLimiterSoftclipDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S569>/Request' */

    /* S-Function (RTC_BytePack): '<S651>/UnpackREQ' */
    PostProcessLimiterSoftclipDisable_REQ_T* payloadREQ =
        (PostProcessLimiterSoftclipDisable_REQ_T*)pREQBuf;
    Model_TargetPostProcessLimiterSoftclipDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPostProcessLimiterSoftclipDisableRtcOut.REQ_disableMsg =
        payloadREQ->disableMsg;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S569>/Response' */

    /* S-Function (RTC_BytePack): '<S652>/PackRSP' */
    PostProcessLimiterSoftclipDisable_RSP_T* payloadRSP =
        (PostProcessLimiterSoftclipDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessLimiterSoftclipDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->disableMsg =
        Model_TargetPostProcessLimiterSoftclipDisableRtcOut.REQ_disableMsg;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PostProcessEnergyLimiterConfigEnableLimiter RTC Request-Response Handler (RTC ID 0x10000015) '<S574>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessEnergyLimiterConfigEnableLimiter(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S574>/Request' */

    /* S-Function (RTC_BytePack): '<S597>/UnpackREQ' */
    PostProcessEnergyLimiterConfigEnableLimiter_REQ_T* payloadREQ =
        (PostProcessEnergyLimiterConfigEnableLimiter_REQ_T*)pREQBuf;
    Model_TargetPostProcessEnergyLimiterConfigEnableLimiterRtcOut.REQ_caller_handle
        = payloadREQ->caller_handle;
    Model_TargetPostProcessEnergyLimiterConfigEnableLimiterRtcOut.REQ_EnableGainLimiter
        = payloadREQ->EnableGainLimiter;
    (Model_TargetPostProcessEnergyLimiterConfigEnableLimiterRtcOut.REQ_sequence)
        ++;                            // Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S574>/Response' */

    /* S-Function (RTC_BytePack): '<S598>/PackRSP' */
    PostProcessEnergyLimiterConfigEnableLimiter_RSP_T* payloadRSP =
        (PostProcessEnergyLimiterConfigEnableLimiter_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessEnergyLimiterConfigEnableLimiterRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PostProcessEnergyLimiterConfigEnableLimiter RTC NTF check complete '<S574>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PostProcessEnergyLimiterConfigEnableLimiter( void )
{
    /* Output and update for function-call system: '<S574>/NtfCheck' */

    /* Outputs for Function Call SubSystem: '<S571>/Triggered Subsystem1' */
    /* Outputs for Function Call SubSystem: '<S571>/Triggered Subsystem' */
    /* Switch: '<S576>/Switch1' incorporates:
     *  Switch: '<S577>/Switch1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S594>:1' */
    /* '<S594>:1:3' go(); */
    if (Model_TargetPostProcessEnergyLimiterConfigEnableLimiterRtcOut.REQ_EnableGainLimiter
        > 0U)
    {
        real32_T tmp;

        /* DataTypeConversion: '<S576>/Data Type Conversion' */
        Model_Target_PostProcess_B.DataTypeConversion_m =
            (Model_Target_PostProcess_B.transition != 0.0F);

        /* DataTypeConversion: '<S577>/Data Type Conversion' */
        tmp = fmodf(qhmath_floor_f(Model_Target_PostProcess_B.transition),
                    4.2949673E+9F);

        /* DataTypeConversion: '<S577>/Data Type Conversion' */
        Model_Target_PostProcess_B.DataTypeConversion = tmp < 0.0F ? (uint32_T)
            -(int32_T)(uint32_T)-tmp : (uint32_T)tmp;
    }
    else
    {
        /* DataTypeConversion: '<S576>/Data Type Conversion' incorporates:
         *  Constant: '<S576>/Constant1'
         */
        Model_Target_PostProcess_B.DataTypeConversion_m = true;

        /* DataTypeConversion: '<S577>/Data Type Conversion' incorporates:
         *  Constant: '<S577>/Constant1'
         */
        Model_Target_PostProcess_B.DataTypeConversion = 5U;
    }

    /* End of Switch: '<S576>/Switch1' */
    /* End of Outputs for SubSystem: '<S571>/Triggered Subsystem' */
    /* End of Outputs for SubSystem: '<S571>/Triggered Subsystem1' */
}

// PostProcessEnergyLimiterConfigEnableLimiter RTC NTF message preparation and packing '<S574>/NTF Trigger' ---------------------------------
void RtcNtfPack_PostProcessEnergyLimiterConfigEnableLimiter(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S574>/Notification' */

    /* S-Function (RTC_BytePack): '<S593>/PackNTF' */
    PostProcessEnergyLimiterConfigEnableLimiter_NTF_T* payloadNTF =
        (PostProcessEnergyLimiterConfigEnableLimiter_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPostProcessEnergyLimiterConfigEnableLimiterRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->ELNotification = Model_Target_PostProcess_B.DataTypeConversion;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PostProcessPostLimiterEqShutdown RTC Request-Response Handler (RTC ID 0x10010019) '<S627>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessPostLimiterEqShutdown(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S627>/Request' */

    /* S-Function (RTC_BytePack): '<S639>/UnpackREQ' */
    PostProcessPostLimiterEqShutdown_REQ_T* payloadREQ =
        (PostProcessPostLimiterEqShutdown_REQ_T*)pREQBuf;
    Model_TargetPostProcessPostLimiterEqShutdownRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S627>/Response' */

    /* S-Function (RTC_BytePack): '<S640>/PackRSP' */
    PostProcessPostLimiterEqShutdown_RSP_T* payloadRSP =
        (PostProcessPostLimiterEqShutdown_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessPostLimiterEqShutdownRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaSurroundLevelControlIndex RTC Request-Response Handler (RTC ID 0x10000034) '<S1626>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaSurroundLevelControlIndex(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S1626>/Request' */

    /* S-Function (RTC_BytePack): '<S1634>/UnpackREQ' */
    PreAmpMedusaSurroundLevelControlIndex_REQ_T* payloadREQ =
        (PreAmpMedusaSurroundLevelControlIndex_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index =
        payloadREQ->surround_index;
    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second
        = payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds
        = payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaSurroundLevelControlIndex();

    /* Output and update for function-call system: '<S1626>/Response' */

    /* S-Function (RTC_BytePack): '<S1635>/PackRSP' */
    PreAmpMedusaSurroundLevelControlIndex_RSP_T* payloadRSP =
        (PreAmpMedusaSurroundLevelControlIndex_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->surround_index =
        Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaSurroundLevelControlIndex RTC NTF check complete '<S1626>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpMedusaSurroundLevelControlIndex( void )
{
    /* Output and update for function-call system: '<S1626>/NtfCheck' */
    {
        int32_T i;
        boolean_T done;
        boolean_T done_c;
        boolean_T done_f;
        boolean_T done_h;
        boolean_T done_i;
        boolean_T done_k;
        boolean_T done_kk;
        boolean_T done_n;
        boolean_T exitg1;

        /* MATLAB Function: '<S1529>/Split NTF_check_done' */
        /* MATLAB Function: '<S1529>/Split NTF_check_done' incorporates:
         *  MATLAB Function: '<S1586>/check sequence'
         */
        /* MATLAB Function: '<S1586>/check sequence' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1631>:1' */
        /* '<S1631>:1:3' go(); */
        /*  #codegen */
        /*  Splits the incoming function call */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Split NTF_check_done': '<S1540>:1' */
        /* '<S1540>:1:4' fcncall_Left(); */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Ramper/check sequence': '<S1591>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1591>:1:8' done = true; */
        done_i = true;

        /* '<S1591>:1:10' for i=1:numel(Premix_targetGain_Left) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 77))
        {
            /* '<S1591>:1:11' if (Premix_targetGain_Left(i) ~= Premix_currentGain_Left(i)) */
            if (Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left[i] !=
                    Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left[i])
            {
                /* '<S1591>:1:12' done = false; */
                done_i = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1529>/Split NTF_check_done' incorporates:
         *  MATLAB Function: '<S1574>/check sequence'
         */
        /* MATLAB Function: '<S1574>/check sequence' */
        /* '<S1540>:1:5' fcncall_CS(); */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/check sequence': '<S1579>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1579>:1:8' done = true; */
        done_n = true;

        /* '<S1579>:1:10' for i=1:numel(Premix_targetGain_CS) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 20))
        {
            /* '<S1579>:1:11' if (Premix_targetGain_CS(i) ~= Premix_currentGain_CS(i)) */
            if (Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS[i] !=
                    Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[i])
            {
                /* '<S1579>:1:12' done = false; */
                done_n = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1529>/Split NTF_check_done' incorporates:
         *  MATLAB Function: '<S1598>/check sequence'
         */
        /* MATLAB Function: '<S1598>/check sequence' */
        /* '<S1540>:1:6' fcncall_Right(); */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Ramper/check sequence': '<S1603>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1603>:1:8' done = true; */
        done_h = true;

        /* '<S1603>:1:10' for i=1:numel(Premix_targetGain_Right) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 77))
        {
            /* '<S1603>:1:11' if (Premix_targetGain_Right(i) ~= Premix_currentGain_Right(i)) */
            if (Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right[i] !=
                    Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right[i])
            {
                /* '<S1603>:1:12' done = false; */
                done_h = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1462>/MATLAB Function' */
        /* MATLAB Function: '<S1462>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S1495>/check sequence'
         */
        /* MATLAB Function: '<S1495>/check sequence' */
        /* '<S1540>:1:7' fcncall_AND(); */
        /*  #codegen */
        /*  Splits the incoming function call */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/MATLAB Function': '<S1470>:1' */
        /* '<S1470>:1:4' fcncall_Left(); */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Ramper/check sequence': '<S1500>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1500>:1:7' done = true; */
        done_kk = true;

        /* '<S1500>:1:9' for i=1:numel(FRM_targetGain_Left) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 30))
        {
            /* '<S1500>:1:10' if (FRM_targetGain_Left(i) ~= FRM_currentGain_Left(i)) */
            if (Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left[i] !=
                    Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i])
            {
                /* '<S1500>:1:11' done = false; */
                done_kk = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1462>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S1483>/check sequence'
         */
        /* MATLAB Function: '<S1483>/check sequence' */
        /* '<S1470>:1:5' fcncall_CS(); */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/check sequence': '<S1488>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1488>:1:7' done = true; */
        done_k = true;

        /* '<S1488>:1:9' for i=1:numel(FRM_targetGain_CS) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 12))
        {
            /* '<S1488>:1:10' if (FRM_targetGain_CS(i) ~= FRM_currentGain_CS(i)) */
            if (Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS[i] !=
                    Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS[i])
            {
                /* '<S1488>:1:11' done = false; */
                done_k = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1462>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S1507>/check sequence'
         */
        /* MATLAB Function: '<S1507>/check sequence' */
        /* '<S1470>:1:6' fcncall_Right(); */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Ramper/check sequence': '<S1512>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1512>:1:7' done = true; */
        done_f = true;

        /* '<S1512>:1:9' for i=1:numel(FRM_targetGain_Right) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 30))
        {
            /* '<S1512>:1:10' if (FRM_targetGain_Right(i) ~= FRM_currentGain_Right(i)) */
            if (Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right[i] !=
                    Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i])
            {
                /* '<S1512>:1:11' done = false; */
                done_f = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1656>/check sequence' */
        /* MATLAB Function: '<S1656>/check sequence' */
        /* '<S1470>:1:7' fcncall_AND(); */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Ramper/check sequence': '<S1659>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1659>:1:8' done = true; */
        done_c = true;

        /* '<S1659>:1:10' for i=1:numel(VLSDrv_targetGain) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 12))
        {
            /* '<S1659>:1:11' if (VLSDrv_targetGain(i) ~= VLSDrv_currentGain(i)) */
            if (Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain[i] !=
                    Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain[i])
            {
                /* '<S1659>:1:12' done = false; */
                done_c = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1681>/check sequence' */
        /* MATLAB Function: '<S1681>/check sequence' */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Ramper/check sequence': '<S1684>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1684>:1:8' done = true; */
        done = true;

        /* '<S1684>:1:10' for i=1:numel(VLSPax_targetGain) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 12))
        {
            /* '<S1684>:1:11' if (VLSPax_targetGain(i) ~= VLSPax_currentGain(i)) */
            if (Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain[i] !=
                    Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain[i])
            {
                /* '<S1684>:1:12' done = false; */
                done = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* Outputs for Function Call SubSystem: '<S1440>/Merge NTF_done' */
        /* MATLAB Function: '<S1529>/Split NTF_check_done' */
        /* MATLAB Function: '<S1529>/Split NTF_check_done' incorporates:
         *  SubSystem: '<S1529>/Merge NTF_done'
         */
        /* MATLAB Function: '<S1462>/MATLAB Function' */
        /* MATLAB Function: '<S1462>/MATLAB Function' incorporates:
         *  SubSystem: '<S1462>/Merge NTF_done'
         */
        /* Logic: '<S1622>/AND' incorporates:
         *  Logic: '<S1471>/AND'
         *  Logic: '<S1538>/AND'
         */
        Model_Target_Medusa5H1Part3_B.AND = (done_h && done_n && done_i &&
            (done_f && done_k && done_kk) && done_c && done);

        /* End of Outputs for SubSystem: '<S1440>/Merge NTF_done' */

        /* Outputs for Function Call SubSystem: '<S1623>/NTF_SLC' */
        /* SignalConversion generated from: '<S1625>/In1' */
        Model_Target_Medusa5H1Part3_B.In1 =
            Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index;

        /* End of Outputs for SubSystem: '<S1623>/NTF_SLC' */
    }
}

// PreAmpMedusaSurroundLevelControlIndex RTC NTF message preparation and packing '<S1626>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpMedusaSurroundLevelControlIndex(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1626>/Notification' */

    /* S-Function (RTC_BytePack): '<S1630>/PackNTF' */
    PreAmpMedusaSurroundLevelControlIndex_NTF_T* payloadNTF =
        (PreAmpMedusaSurroundLevelControlIndex_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->surround_index = Model_Target_Medusa5H1Part3_B.In1;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpMedusaSurroundLevelControlReset RTC Request-Response Handler (RTC ID 0x10010035) '<S1627>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaSurroundLevelControlReset(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S1627>/Request' */

    /* S-Function (RTC_BytePack): '<S1640>/UnpackREQ' */
    PreAmpMedusaSurroundLevelControlReset_REQ_T* payloadREQ =
        (PreAmpMedusaSurroundLevelControlReset_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaSurroundLevelControlResetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaSurroundLevelControlReset();

    /* Output and update for function-call system: '<S1627>/Response' */

    /* S-Function (RTC_BytePack): '<S1641>/PackRSP' */
    PreAmpMedusaSurroundLevelControlReset_RSP_T* payloadRSP =
        (PreAmpMedusaSurroundLevelControlReset_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaSurroundLevelControlResetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaPostUpmixDisable RTC Request-Response Handler (RTC ID 0x10010033) '<S1432>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaPostUpmixDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1432>/Request' */

    /* S-Function (RTC_BytePack): '<S1698>/UnpackREQ' */
    PreAmpMedusaPostUpmixDisable_REQ_T* payloadREQ =
        (PreAmpMedusaPostUpmixDisable_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaPostUpmixDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaPostUpmixDisable();

    /* Output and update for function-call system: '<S1432>/Response' */

    /* S-Function (RTC_BytePack): '<S1699>/PackRSP' */
    PreAmpMedusaPostUpmixDisable_RSP_T* payloadRSP =
        (PreAmpMedusaPostUpmixDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaPostUpmixDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaHoligramDisable RTC Request-Response Handler (RTC ID 0x10010030) '<S1703>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaHoligramDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1703>/Request' */

    /* S-Function (RTC_BytePack): '<S1768>/UnpackREQ' */
    PreAmpMedusaHoligramDisable_REQ_T* payloadREQ =
        (PreAmpMedusaHoligramDisable_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaHoligramDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaHoligramDisable();

    /* Output and update for function-call system: '<S1703>/Response' */

    /* S-Function (RTC_BytePack): '<S1769>/PackRSP' */
    PreAmpMedusaHoligramDisable_RSP_T* payloadRSP =
        (PreAmpMedusaHoligramDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaHoligramDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaOverheadHoligramDisable RTC Request-Response Handler (RTC ID 0x10010031) '<S1772>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaOverheadHoligramDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1772>/Request' */

    /* S-Function (RTC_BytePack): '<S1780>/UnpackREQ' */
    PreAmpMedusaOverheadHoligramDisable_REQ_T* payloadREQ =
        (PreAmpMedusaOverheadHoligramDisable_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaOverheadHoligramDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaOverheadHoligramDisable();

    /* Output and update for function-call system: '<S1772>/Response' */

    /* S-Function (RTC_BytePack): '<S1781>/PackRSP' */
    PreAmpMedusaOverheadHoligramDisable_RSP_T* payloadRSP =
        (PreAmpMedusaOverheadHoligramDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaOverheadHoligramDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaPostHoligramDisable RTC Request-Response Handler (RTC ID 0x10010032) '<S1792>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaPostHoligramDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1792>/Request' */

    /* S-Function (RTC_BytePack): '<S1799>/UnpackREQ' */
    PreAmpMedusaPostHoligramDisable_REQ_T* payloadREQ =
        (PreAmpMedusaPostHoligramDisable_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaPostHoligramDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaPostHoligramDisable();

    /* Output and update for function-call system: '<S1792>/Response' */

    /* S-Function (RTC_BytePack): '<S1800>/PackRSP' */
    PreAmpMedusaPostHoligramDisable_RSP_T* payloadRSP =
        (PreAmpMedusaPostHoligramDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaPostHoligramDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpBassSet RTC Request-Response Handler (RTC ID 0x1000002e) '<S1978>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpBassSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1978>/Request' */

    /* S-Function (RTC_BytePack): '<S1994>/UnpackREQ' */
    PreAmpBassSet_REQ_T* payloadREQ = (PreAmpBassSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpBassSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpBassSetRtcOut.REQ_gain_index = payloadREQ->gain_index;
    Model_TargetPreAmpBassSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpBassSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpBassSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpBassSet();

    /* Output and update for function-call system: '<S1978>/Response' */

    /* S-Function (RTC_BytePack): '<S1995>/PackRSP' */
    PreAmpBassSet_RSP_T* payloadRSP = (PreAmpBassSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpBassSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index = Model_TargetPreAmpBassSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpBassSet RTC NTF check complete '<S1978>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpBassSet( void )
{
    /* Output and update for function-call system: '<S1978>/NtfCheck' */

    /* MATLAB Function: '<S1974>/check done' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1991>:1' */
    /* '<S1991>:1:3' go(); */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Bass/check done': '<S1985>:1' */
    /*  Checking whether the frameCounts are exactly equal to 0 was leading to */
    /*  unpredictable behavior. Therefore, we now check whether or not the  */
    /*  frameCounts are less-than/equal-to 0. */
    /*  See SAMPLERATE-1196 & SAMPLERATE-1205 for more details.  */
    /* '<S1985>:1:10' done = (Rampers(1).frameCount <= 0) && (Rampers(2).frameCount <= 0); */
    Model_Target_PreAmpPart1_B.done_b =
        ((Model_TargetControlDsms.PreAmpBassRampers[0].frameCount <= 0) &&
         (Model_TargetControlDsms.PreAmpBassRampers[1].frameCount <= 0));

    /* Outputs for Function Call SubSystem: '<S1974>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1981>/In1' */
    Model_Target_PreAmpPart1_B.In1_h =
        Model_TargetPreAmpBassSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S1974>/Triggered Subsystem' */
}

// PreAmpBassSet RTC NTF message preparation and packing '<S1978>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpBassSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1978>/Notification' */

    /* S-Function (RTC_BytePack): '<S1990>/PackNTF' */
    PreAmpBassSet_NTF_T* payloadNTF = (PreAmpBassSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpBassSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_PreAmpPart1_B.In1_h;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpMidrangeCfgSet RTC Request-Response Handler (RTC ID 0x10000036) '<S1996>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMidrangeCfgSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1996>/Request' */

    /* S-Function (RTC_BytePack): '<S2012>/UnpackREQ' */
    PreAmpMidrangeCfgSet_REQ_T* payloadREQ = (PreAmpMidrangeCfgSet_REQ_T*)
        pREQBuf;
    Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMidrangeCfgSet();

    /* Output and update for function-call system: '<S1996>/Response' */

    /* S-Function (RTC_BytePack): '<S2013>/PackRSP' */
    PreAmpMidrangeCfgSet_RSP_T* payloadRSP = (PreAmpMidrangeCfgSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMidrangeCfgSet RTC NTF check complete '<S1996>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpMidrangeCfgSet( void )
{
    /* Output and update for function-call system: '<S1996>/NtfCheck' */

    /* MATLAB Function: '<S1975>/check done' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S2009>:1' */
    /* '<S2009>:1:3' go(); */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Midrange/check done': '<S2004>:1' */
    /*  Checking whether the frameCounts are exactly equal to 0 was leading to */
    /*  unpredictable behavior. Therefore, we now check whether or not the  */
    /*  frameCounts are less-than/equal-to 0. */
    /*  See SAMPLERATE-1196 & SAMPLERATE-1205 for more details.  */
    /* '<S2004>:1:10' done = (Rampers(1).frameCount <= 0) && (Rampers(2).frameCount <= 0); */
    Model_Target_PreAmpPart1_B.done_k =
        ((Model_TargetControlDsms.PreAmpMidrangeCfgRampers[0].frameCount <= 0) &&
         (Model_TargetControlDsms.PreAmpMidrangeCfgRampers[1].frameCount <= 0));

    /* Outputs for Function Call SubSystem: '<S1975>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1999>/In1' */
    Model_Target_PreAmpPart1_B.In1_i =
        Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S1975>/Triggered Subsystem' */
}

// PreAmpMidrangeCfgSet RTC NTF message preparation and packing '<S1996>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpMidrangeCfgSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1996>/Notification' */

    /* S-Function (RTC_BytePack): '<S2008>/PackNTF' */
    PreAmpMidrangeCfgSet_NTF_T* payloadNTF = (PreAmpMidrangeCfgSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_PreAmpPart1_B.In1_i;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpTrebleSet RTC Request-Response Handler (RTC ID 0x1000003b) '<S2032>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpTrebleSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2032>/Request' */

    /* S-Function (RTC_BytePack): '<S2048>/UnpackREQ' */
    PreAmpTrebleSet_REQ_T* payloadREQ = (PreAmpTrebleSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpTrebleSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpTrebleSetRtcOut.REQ_gain_index = payloadREQ->gain_index;
    Model_TargetPreAmpTrebleSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpTrebleSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpTrebleSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpTrebleSet();

    /* Output and update for function-call system: '<S2032>/Response' */

    /* S-Function (RTC_BytePack): '<S2049>/PackRSP' */
    PreAmpTrebleSet_RSP_T* payloadRSP = (PreAmpTrebleSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpTrebleSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index = Model_TargetPreAmpTrebleSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpTrebleSet RTC NTF check complete '<S2032>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpTrebleSet( void )
{
    /* Output and update for function-call system: '<S2032>/NtfCheck' */

    /* MATLAB Function: '<S1977>/check done' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S2045>:1' */
    /* '<S2045>:1:3' go(); */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Treble/check done': '<S2039>:1' */
    /*  Checking whether the frameCounts are exactly equal to 0 was leading to */
    /*  unpredictable behavior. Therefore, we now check whether or not the  */
    /*  frameCounts are less-than/equal-to 0. */
    /*  See SAMPLERATE-1196 & SAMPLERATE-1205 for more details.  */
    /* '<S2039>:1:10' done = (Rampers(1).frameCount <= 0) && (Rampers(2).frameCount <= 0); */
    Model_Target_PreAmpPart1_B.done =
        ((Model_TargetControlDsms.PreAmpTrebleRampers[0].frameCount <= 0) &&
         (Model_TargetControlDsms.PreAmpTrebleRampers[1].frameCount <= 0));

    /* Outputs for Function Call SubSystem: '<S1977>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S2035>/In1' */
    Model_Target_PreAmpPart1_B.In1 =
        Model_TargetPreAmpTrebleSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S1977>/Triggered Subsystem' */
}

// PreAmpTrebleSet RTC NTF message preparation and packing '<S2032>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpTrebleSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S2032>/Notification' */

    /* S-Function (RTC_BytePack): '<S2044>/PackNTF' */
    PreAmpTrebleSet_NTF_T* payloadNTF = (PreAmpTrebleSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpTrebleSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_PreAmpPart1_B.In1;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// InputSelectRouterCfgSet RTC Request-Response Handler (RTC ID 0x10010000) '<S15>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_InputSelectRouterCfgSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S15>/Request' */

    /* S-Function (RTC_BytePack): '<S21>/UnpackREQ' */
    InputSelectRouterCfgSet_REQ_T* payloadREQ = (InputSelectRouterCfgSet_REQ_T*)
        pREQBuf;
    Model_TargetInputSelectRouterCfgSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetInputSelectRouterCfgSetRtcOut.REQ_routerMap[0]),
                 (uint8_t*)payloadREQ->routerMap, sizeof(int32_T)*12 );// copy 48 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S15>/Response' */

    /* S-Function (RTC_BytePack): '<S22>/PackRSP' */
    InputSelectRouterCfgSet_RSP_T* payloadRSP = (InputSelectRouterCfgSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetInputSelectRouterCfgSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    (void)memcpy((uint8_t*)payloadRSP->routerMap, (uint8_t*)
                 &(Model_TargetInputSelectRouterCfgSetRtcOut.REQ_routerMap[0]),
                 sizeof(int32_T)*12 ); // copy 48 chars

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMuteControlSet RTC Request-Response Handler (RTC ID 0x10000037) '<S1858>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMuteControlSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1858>/Request' */

    /* S-Function (RTC_BytePack): '<S1866>/UnpackREQ' */
    PreAmpMuteControlSet_REQ_T* payloadREQ = (PreAmpMuteControlSet_REQ_T*)
        pREQBuf;
    Model_TargetPreAmpMuteControlSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpMuteControlSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetPreAmpMuteControlSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpMuteControlSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpMuteControlSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMuteControlSet();

    /* Output and update for function-call system: '<S1858>/Response' */

    /* S-Function (RTC_BytePack): '<S1867>/PackRSP' */
    PreAmpMuteControlSet_RSP_T* payloadRSP = (PreAmpMuteControlSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMuteControlSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetPreAmpMuteControlSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMuteControlSet RTC NTF check complete '<S1858>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpMuteControlSet( void )
{
    /* Output and update for function-call system: '<S1858>/NtfCheck' */
    {
        boolean_T done_f;
        boolean_T done_i;

        /* MATLAB Function: '<S1868>/TriggeredFunction' */
        /* MATLAB Function: '<S1868>/TriggeredFunction' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1863>:1' */
        /* '<S1863>:1:3' go(); */
        /*  Function to check whether the ramp has completed.  */
        /*  If so, send out TRUE */
        /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S1870>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1870>:1:9' done = true; */
        done_f = true;

        /* '<S1870>:1:10' if (targetLinearGain ~= currentGain) */
        if (Model_TargetControlDsms.PreAmpMuteDRTargetLinearGain !=
                Model_TargetControlDsms.PreAmpMuteDRCurrentGain)
        {
            /* '<S1870>:1:11' done = false; */
            done_f = false;

            /*  just proved otherwise */
        }

        /* End of MATLAB Function: '<S1868>/TriggeredFunction' */

        /* MATLAB Function: '<S1881>/TriggeredFunction' */
        /* MATLAB Function: '<S1881>/TriggeredFunction' */
        /*  Function to check whether the ramp has completed.  */
        /*  If so, send out TRUE */
        /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S1883>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1883>:1:9' done = true; */
        done_i = true;

        /* '<S1883>:1:10' if (targetLinearGain ~= currentGain) */
        if (Model_TargetControlDsms.PreAmpMuteFRTargetLinearGain !=
                Model_TargetControlDsms.PreAmpMuteFRCurrentGain)
        {
            /* '<S1883>:1:11' done = false; */
            done_i = false;

            /*  just proved otherwise */
        }

        /* End of MATLAB Function: '<S1881>/TriggeredFunction' */

        /* Outputs for Function Call SubSystem: '<S1140>/Subsystem' */
        /* Logic: '<S1825>/AND' */
        Model_Target_B.AND = (done_f && done_i);

        /* End of Outputs for SubSystem: '<S1140>/Subsystem' */

        /* Outputs for Function Call SubSystem: '<S1857>/Triggered Subsystem' */
        /* SignalConversion generated from: '<S1859>/In1' */
        Model_Target_B.In1_g2 =
            Model_TargetPreAmpMuteControlSetRtcOut.REQ_mute_switch;

        /* End of Outputs for SubSystem: '<S1857>/Triggered Subsystem' */
    }
}

// PreAmpMuteControlSet RTC NTF message preparation and packing '<S1858>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpMuteControlSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1858>/Notification' */

    /* S-Function (RTC_BytePack): '<S1862>/PackNTF' */
    PreAmpMuteControlSet_NTF_T* payloadNTF = (PreAmpMuteControlSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpMuteControlSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_g2;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpFadeControlSet RTC Request-Response Handler (RTC ID 0x1000002f) '<S1828>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpFadeControlSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1828>/Request' */

    /* S-Function (RTC_BytePack): '<S1841>/UnpackREQ' */
    PreAmpFadeControlSet_REQ_T* payloadREQ = (PreAmpFadeControlSet_REQ_T*)
        pREQBuf;
    Model_TargetPreAmpFadeControlSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpFadeControlSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpFadeControlSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpFadeControlSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpFadeControlSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpFadeControlSet();

    /* Output and update for function-call system: '<S1828>/Response' */

    /* S-Function (RTC_BytePack): '<S1842>/PackRSP' */
    PreAmpFadeControlSet_RSP_T* payloadRSP = (PreAmpFadeControlSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpFadeControlSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpFadeControlSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpFadeControlSet RTC NTF check complete '<S1828>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpFadeControlSet( void )
{
    /* Output and update for function-call system: '<S1828>/NtfCheck' */

    /* Outputs for Function Call SubSystem: '<S1140>/Subsystem1' */
    /* MATLAB Function: '<S1843>/check done' */
    /* MATLAB Function: '<S1850>/check done' */
    /* Logic: '<S1826>/AND' incorporates:
     *  MATLAB Function: '<S1843>/check done'
     *  MATLAB Function: '<S1850>/check done'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1838>:1' */
    /* '<S1838>:1:3' go(); */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/PreAmpPart2/FadeRamperDR/InnerLink/check done': '<S1846>:1' */
    /*  Fading is done if both the 'Front' and the 'Rear' groups of channels  */
    /*  have ramped. */
    /* '<S1846>:1:8' done = Rampers(1).frameCount == 0 && Rampers(2).frameCount == 0; */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/PreAmpPart2/FadeRamperFR/InnerLink/check done': '<S1853>:1' */
    /*  Fading is done if both the 'Front' and the 'Rear' groups of channels  */
    /*  have ramped. */
    /* '<S1853>:1:8' done = Rampers(1).frameCount == 0 && Rampers(2).frameCount == 0; */
    Model_Target_B.AND_h = ((Model_TargetControlDsms.PreAmpFadeRamperDRRampers[0]
        .frameCount == 0) && (Model_TargetControlDsms.PreAmpFadeRamperDRRampers
        [1].frameCount == 0) &&
                            ((Model_TargetControlDsms.PreAmpFadeRamperFRRampers
        [0].frameCount == 0) &&
        (Model_TargetControlDsms.PreAmpFadeRamperFRRampers[1].frameCount == 0)));

    /* End of Outputs for SubSystem: '<S1140>/Subsystem1' */

    /* Outputs for Function Call SubSystem: '<S1827>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1829>/In1' */
    Model_Target_B.In1_g20 =
        Model_TargetPreAmpFadeControlSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S1827>/Triggered Subsystem' */
}

// PreAmpFadeControlSet RTC NTF message preparation and packing '<S1828>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpFadeControlSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1828>/Notification' */

    /* S-Function (RTC_BytePack): '<S1837>/PackNTF' */
    PreAmpFadeControlSet_NTF_T* payloadNTF = (PreAmpFadeControlSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpFadeControlSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_g20;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpSleepingBeautyDRSet RTC Request-Response Handler (RTC ID 0x10000039) '<S1901>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpSleepingBeautyDRSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1901>/Request' */

    /* S-Function (RTC_BytePack): '<S1918>/UnpackREQ' */
    PreAmpSleepingBeautyDRSet_REQ_T* payloadREQ =
        (PreAmpSleepingBeautyDRSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpSleepingBeautyDRSet();

    /* Output and update for function-call system: '<S1901>/Response' */

    /* S-Function (RTC_BytePack): '<S1919>/PackRSP' */
    PreAmpSleepingBeautyDRSet_RSP_T* payloadRSP =
        (PreAmpSleepingBeautyDRSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpSleepingBeautyDRSet RTC NTF check complete '<S1901>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpSleepingBeautyDRSet( void )
{
    /* Output and update for function-call system: '<S1901>/NtfCheck' */
    {
        int32_T i;
        boolean_T exitg1;

        /* MATLAB Function: '<S1900>/check sequence' */
        /* MATLAB Function: '<S1900>/check sequence' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1915>:1' */
        /* '<S1915>:1:3' go(); */
        /*   Function that checks whether all channels have completed their ramp to  */
        /*  target gain. */
        /*  If so, send out TRUE to RTC */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/PreAmpPart2/SleepingBeautyDR/InnerLink/check sequence': '<S1911>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1911>:1:9' done = true; */
        Model_Target_B.done_m = true;

        /* '<S1911>:1:11' for i=1:MaskNumRampers */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 4))
        {
            /* '<S1911>:1:12' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
            if (Model_TargetControlDsms.PreAmpSleepingBeautyDRRampers[i].
                    targetGain !=
                    Model_TargetControlDsms.PreAmpSleepingBeautyDRRampers[i].
                    currentGain)
            {
                /* '<S1911>:1:13' done = false; */
                Model_Target_B.done_m = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* Outputs for Function Call SubSystem: '<S1900>/Triggered Subsystem' */
        /* SignalConversion generated from: '<S1904>/In1' */
        Model_Target_B.In1_g =
            Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_gain_index;

        /* End of Outputs for SubSystem: '<S1900>/Triggered Subsystem' */
    }
}

// PreAmpSleepingBeautyDRSet RTC NTF message preparation and packing '<S1901>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpSleepingBeautyDRSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1901>/Notification' */

    /* S-Function (RTC_BytePack): '<S1914>/PackNTF' */
    PreAmpSleepingBeautyDRSet_NTF_T* payloadNTF =
        (PreAmpSleepingBeautyDRSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_g;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpSleepingBeautyFRSet RTC Request-Response Handler (RTC ID 0x1000003a) '<S1921>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpSleepingBeautyFRSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1921>/Request' */

    /* S-Function (RTC_BytePack): '<S1938>/UnpackREQ' */
    PreAmpSleepingBeautyFRSet_REQ_T* payloadREQ =
        (PreAmpSleepingBeautyFRSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpSleepingBeautyFRSet();

    /* Output and update for function-call system: '<S1921>/Response' */

    /* S-Function (RTC_BytePack): '<S1939>/PackRSP' */
    PreAmpSleepingBeautyFRSet_RSP_T* payloadRSP =
        (PreAmpSleepingBeautyFRSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpSleepingBeautyFRSet RTC NTF check complete '<S1921>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpSleepingBeautyFRSet( void )
{
    /* Output and update for function-call system: '<S1921>/NtfCheck' */
    {
        int32_T i;
        boolean_T exitg1;

        /* MATLAB Function: '<S1920>/check sequence' */
        /* MATLAB Function: '<S1920>/check sequence' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1935>:1' */
        /* '<S1935>:1:3' go(); */
        /*   Function that checks whether all channels have completed their ramp to  */
        /*  target gain. */
        /*  If so, send out TRUE to RTC */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/PreAmpPart2/SleepingBeautyFR/InnerLink/check sequence': '<S1931>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1931>:1:9' done = true; */
        Model_Target_B.done = true;

        /* '<S1931>:1:11' for i=1:MaskNumRampers */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 4))
        {
            /* '<S1931>:1:12' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
            if (Model_TargetControlDsms.PreAmpSleepingBeautyFRRampers[i].
                    targetGain !=
                    Model_TargetControlDsms.PreAmpSleepingBeautyFRRampers[i].
                    currentGain)
            {
                /* '<S1931>:1:13' done = false; */
                Model_Target_B.done = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* Outputs for Function Call SubSystem: '<S1920>/Triggered Subsystem' */
        /* SignalConversion generated from: '<S1924>/In1' */
        Model_Target_B.In1 =
            Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_gain_index;

        /* End of Outputs for SubSystem: '<S1920>/Triggered Subsystem' */
    }
}

// PreAmpSleepingBeautyFRSet RTC NTF message preparation and packing '<S1921>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpSleepingBeautyFRSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1921>/Notification' */

    /* S-Function (RTC_BytePack): '<S1934>/PackNTF' */
    PreAmpSleepingBeautyFRSet_NTF_T* payloadNTF =
        (PreAmpSleepingBeautyFRSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpResetSleepingBeauty RTC Request-Response Handler (RTC ID 0x10010038) '<S1822>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpResetSleepingBeauty(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1822>/Request' */

    /* S-Function (RTC_BytePack): '<S1898>/UnpackREQ' */
    PreAmpResetSleepingBeauty_REQ_T* payloadREQ =
        (PreAmpResetSleepingBeauty_REQ_T*)pREQBuf;
    Model_TargetPreAmpResetSleepingBeautyRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1822>/Response' */

    /* S-Function (RTC_BytePack): '<S1899>/PackRSP' */
    PreAmpResetSleepingBeauty_RSP_T* payloadRSP =
        (PreAmpResetSleepingBeauty_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpResetSleepingBeautyRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterMainSelect RTC Request-Response Handler (RTC ID 0x10010041) '<S2062>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterMainSelect(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2062>/Request' */

    /* S-Function (RTC_BytePack): '<S2100>/UnpackREQ' */
    TestRouterASDRouterMainSelect_REQ_T* payloadREQ =
        (TestRouterASDRouterMainSelect_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_mainSelect
                   [0]), (uint8_t*)payloadREQ->mainSelect, sizeof(int32_T)*24 );// copy 96 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2062>/Response' */

    /* S-Function (RTC_BytePack): '<S2101>/PackRSP' */
    TestRouterASDRouterMainSelect_RSP_T* payloadRSP =
        (TestRouterASDRouterMainSelect_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterMainGain RTC Request-Response Handler (RTC ID 0x10010040) '<S2061>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterMainGain(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2061>/Request' */

    /* S-Function (RTC_BytePack): '<S2094>/UnpackREQ' */
    TestRouterASDRouterMainGain_REQ_T* payloadREQ =
        (TestRouterASDRouterMainGain_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterMainGainRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetTestRouterASDRouterMainGainRtcOut.REQ_mainGain[0]),
                 (uint8_t*)payloadREQ->mainGain, sizeof(real32_T)*24 );// copy 96 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2061>/Response' */

    /* S-Function (RTC_BytePack): '<S2095>/PackRSP' */
    TestRouterASDRouterMainGain_RSP_T* payloadRSP =
        (TestRouterASDRouterMainGain_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterMainGainRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterAuxEnable RTC Request-Response Handler (RTC ID 0x1001003d) '<S2057>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterAuxEnable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2057>/Request' */

    /* S-Function (RTC_BytePack): '<S2070>/UnpackREQ' */
    TestRouterASDRouterAuxEnable_REQ_T* payloadREQ =
        (TestRouterASDRouterAuxEnable_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_EnableAuxFlag =
        payloadREQ->EnableAuxFlag;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2057>/Response' */

    /* S-Function (RTC_BytePack): '<S2071>/PackRSP' */
    TestRouterASDRouterAuxEnable_RSP_T* payloadRSP =
        (TestRouterASDRouterAuxEnable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterAuxSelect RTC Request-Response Handler (RTC ID 0x1001003f) '<S2059>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterAuxSelect(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2059>/Request' */

    /* S-Function (RTC_BytePack): '<S2082>/UnpackREQ' */
    TestRouterASDRouterAuxSelect_REQ_T* payloadREQ =
        (TestRouterASDRouterAuxSelect_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_AuxSelect
                   [0]), (uint8_t*)payloadREQ->AuxSelect, sizeof(int32_T)*24 );// copy 96 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2059>/Response' */

    /* S-Function (RTC_BytePack): '<S2083>/PackRSP' */
    TestRouterASDRouterAuxSelect_RSP_T* payloadRSP =
        (TestRouterASDRouterAuxSelect_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterAuxGain RTC Request-Response Handler (RTC ID 0x1001003e) '<S2058>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterAuxGain(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2058>/Request' */

    /* S-Function (RTC_BytePack): '<S2076>/UnpackREQ' */
    TestRouterASDRouterAuxGain_REQ_T* payloadREQ =
        (TestRouterASDRouterAuxGain_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterAuxGainRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetTestRouterASDRouterAuxGainRtcOut.REQ_AuxGain[0]),
                 (uint8_t*)payloadREQ->AuxGain, sizeof(real32_T)*24 );// copy 96 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2058>/Response' */

    /* S-Function (RTC_BytePack): '<S2077>/PackRSP' */
    TestRouterASDRouterAuxGain_RSP_T* payloadRSP =
        (TestRouterASDRouterAuxGain_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterAuxGainRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn1Ann1VolumeSet RTC Request-Response Handler (RTC ID 0x10000003) '<S291>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn1Ann1VolumeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S291>/Request' */

    /* S-Function (RTC_BytePack): '<S305>/UnpackREQ' */
    NearAnn1Ann1VolumeSet_REQ_T* payloadREQ = (NearAnn1Ann1VolumeSet_REQ_T*)
        pREQBuf;
    Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_volume_index =
        payloadREQ->volume_index;
    Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_db_per_second =
        payloadREQ->db_per_second;
    Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn1Ann1VolumeSet();

    /* Output and update for function-call system: '<S291>/Response' */

    /* S-Function (RTC_BytePack): '<S306>/PackRSP' */
    NearAnn1Ann1VolumeSet_RSP_T* payloadRSP = (NearAnn1Ann1VolumeSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_volume_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn1Ann1VolumeSet RTC NTF check complete '<S291>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn1Ann1VolumeSet( void )
{
    /* Output and update for function-call system: '<S291>/NtfCheck' */

    /* MATLAB Function: '<S309>/rgainx check sequence' */
    /* MATLAB Function: '<S309>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S302>:1' */
    /* '<S302>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S314>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S314>:1:7' done = true; */
    Model_Target_B.done_ey = true;

    /* '<S314>:1:8' for i=1:MaskNumRampers */
    /* '<S314>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.targetGain !=
            Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain)
    {
        /* '<S314>:1:10' done = false; */
        Model_Target_B.done_ey = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S309>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S238>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S293>/In1' */
    Model_Target_B.In1_oa =
        Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_volume_index;

    /* End of Outputs for SubSystem: '<S238>/Triggered Subsystem' */
}

// NearAnn1Ann1VolumeSet RTC NTF message preparation and packing '<S291>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn1Ann1VolumeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S291>/Notification' */

    /* S-Function (RTC_BytePack): '<S301>/PackNTF' */
    NearAnn1Ann1VolumeSet_NTF_T* payloadNTF = (NearAnn1Ann1VolumeSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_oa;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn2Ann2VolumeSet RTC Request-Response Handler (RTC ID 0x10000006) '<S371>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn2Ann2VolumeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S371>/Request' */

    /* S-Function (RTC_BytePack): '<S385>/UnpackREQ' */
    NearAnn2Ann2VolumeSet_REQ_T* payloadREQ = (NearAnn2Ann2VolumeSet_REQ_T*)
        pREQBuf;
    Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_volume_index =
        payloadREQ->volume_index;
    Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_db_per_second =
        payloadREQ->db_per_second;
    Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn2Ann2VolumeSet();

    /* Output and update for function-call system: '<S371>/Response' */

    /* S-Function (RTC_BytePack): '<S386>/PackRSP' */
    NearAnn2Ann2VolumeSet_RSP_T* payloadRSP = (NearAnn2Ann2VolumeSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_volume_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn2Ann2VolumeSet RTC NTF check complete '<S371>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn2Ann2VolumeSet( void )
{
    /* Output and update for function-call system: '<S371>/NtfCheck' */

    /* MATLAB Function: '<S389>/rgainx check sequence' */
    /* MATLAB Function: '<S389>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S382>:1' */
    /* '<S382>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S394>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S394>:1:7' done = true; */
    Model_Target_B.done_n = true;

    /* '<S394>:1:8' for i=1:MaskNumRampers */
    /* '<S394>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.targetGain !=
            Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain)
    {
        /* '<S394>:1:10' done = false; */
        Model_Target_B.done_n = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S389>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S318>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S373>/In1' */
    Model_Target_B.In1_d2 =
        Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_volume_index;

    /* End of Outputs for SubSystem: '<S318>/Triggered Subsystem' */
}

// NearAnn2Ann2VolumeSet RTC NTF message preparation and packing '<S371>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn2Ann2VolumeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S371>/Notification' */

    /* S-Function (RTC_BytePack): '<S381>/PackNTF' */
    NearAnn2Ann2VolumeSet_NTF_T* payloadNTF = (NearAnn2Ann2VolumeSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_d2;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn3Ann3VolumeSet RTC Request-Response Handler (RTC ID 0x10000009) '<S451>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn3Ann3VolumeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S451>/Request' */

    /* S-Function (RTC_BytePack): '<S465>/UnpackREQ' */
    NearAnn3Ann3VolumeSet_REQ_T* payloadREQ = (NearAnn3Ann3VolumeSet_REQ_T*)
        pREQBuf;
    Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_volume_index =
        payloadREQ->volume_index;
    Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_db_per_second =
        payloadREQ->db_per_second;
    Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn3Ann3VolumeSet();

    /* Output and update for function-call system: '<S451>/Response' */

    /* S-Function (RTC_BytePack): '<S466>/PackRSP' */
    NearAnn3Ann3VolumeSet_RSP_T* payloadRSP = (NearAnn3Ann3VolumeSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_volume_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn3Ann3VolumeSet RTC NTF check complete '<S451>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn3Ann3VolumeSet( void )
{
    /* Output and update for function-call system: '<S451>/NtfCheck' */

    /* MATLAB Function: '<S469>/rgainx check sequence' */
    /* MATLAB Function: '<S469>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S462>:1' */
    /* '<S462>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S474>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S474>:1:7' done = true; */
    Model_Target_B.done_l = true;

    /* '<S474>:1:8' for i=1:MaskNumRampers */
    /* '<S474>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.targetGain !=
            Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain)
    {
        /* '<S474>:1:10' done = false; */
        Model_Target_B.done_l = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S469>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S398>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S453>/In1' */
    Model_Target_B.In1_jw =
        Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_volume_index;

    /* End of Outputs for SubSystem: '<S398>/Triggered Subsystem' */
}

// NearAnn3Ann3VolumeSet RTC NTF message preparation and packing '<S451>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn3Ann3VolumeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S451>/Notification' */

    /* S-Function (RTC_BytePack): '<S461>/PackNTF' */
    NearAnn3Ann3VolumeSet_NTF_T* payloadNTF = (NearAnn3Ann3VolumeSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_jw;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn4Ann4VolumeSet RTC Request-Response Handler (RTC ID 0x1000000c) '<S531>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn4Ann4VolumeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S531>/Request' */

    /* S-Function (RTC_BytePack): '<S545>/UnpackREQ' */
    NearAnn4Ann4VolumeSet_REQ_T* payloadREQ = (NearAnn4Ann4VolumeSet_REQ_T*)
        pREQBuf;
    Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_volume_index =
        payloadREQ->volume_index;
    Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_db_per_second =
        payloadREQ->db_per_second;
    Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn4Ann4VolumeSet();

    /* Output and update for function-call system: '<S531>/Response' */

    /* S-Function (RTC_BytePack): '<S546>/PackRSP' */
    NearAnn4Ann4VolumeSet_RSP_T* payloadRSP = (NearAnn4Ann4VolumeSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_volume_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn4Ann4VolumeSet RTC NTF check complete '<S531>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn4Ann4VolumeSet( void )
{
    /* Output and update for function-call system: '<S531>/NtfCheck' */

    /* MATLAB Function: '<S549>/rgainx check sequence' */
    /* MATLAB Function: '<S549>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S542>:1' */
    /* '<S542>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S554>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S554>:1:7' done = true; */
    Model_Target_B.done_h = true;

    /* '<S554>:1:8' for i=1:MaskNumRampers */
    /* '<S554>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.targetGain !=
            Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain)
    {
        /* '<S554>:1:10' done = false; */
        Model_Target_B.done_h = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S549>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S478>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S533>/In1' */
    Model_Target_B.In1_d =
        Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_volume_index;

    /* End of Outputs for SubSystem: '<S478>/Triggered Subsystem' */
}

// NearAnn4Ann4VolumeSet RTC NTF message preparation and packing '<S531>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn4Ann4VolumeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S531>/Notification' */

    /* S-Function (RTC_BytePack): '<S541>/PackNTF' */
    NearAnn4Ann4VolumeSet_NTF_T* payloadNTF = (NearAnn4Ann4VolumeSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_d;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn1Ann1NonEntGainCalcvncEnableRTC RTC Request-Response Handler (RTC ID 0x10010002) '<S240>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn1Ann1NonEntGainCalcvncEnableRTC(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S240>/Request' */

    /* S-Function (RTC_BytePack): '<S257>/UnpackREQ' */
    NearAnn1Ann1NonEntGainCalcvncEnableRTC_REQ_T* payloadREQ =
        (NearAnn1Ann1NonEntGainCalcvncEnableRTC_REQ_T*)pREQBuf;
    Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable =
        payloadREQ->vncEnable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn1Ann1NonEntGainCalcvncEnableRTC();

    /* Output and update for function-call system: '<S240>/Response' */

    /* S-Function (RTC_BytePack): '<S258>/PackRSP' */
    NearAnn1Ann1NonEntGainCalcvncEnableRTC_RSP_T* payloadRSP =
        (NearAnn1Ann1NonEntGainCalcvncEnableRTC_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->enable =
        Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn1Ann1MuteSet RTC Request-Response Handler (RTC ID 0x10000001) '<S269>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn1Ann1MuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S269>/Request' */

    /* S-Function (RTC_BytePack): '<S277>/UnpackREQ' */
    NearAnn1Ann1MuteSet_REQ_T* payloadREQ = (NearAnn1Ann1MuteSet_REQ_T*)pREQBuf;
    Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn1Ann1MuteSet();

    /* Output and update for function-call system: '<S269>/Response' */

    /* S-Function (RTC_BytePack): '<S278>/PackRSP' */
    NearAnn1Ann1MuteSet_RSP_T* payloadRSP = (NearAnn1Ann1MuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn1Ann1MuteSet RTC NTF check complete '<S269>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn1Ann1MuteSet( void )
{
    /* Output and update for function-call system: '<S269>/NtfCheck' */

    /* MATLAB Function: '<S268>/TriggeredFunction' */
    /* MATLAB Function: '<S268>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S274>:1' */
    /* '<S274>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S280>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S280>:1:9' done = true; */
    Model_Target_B.done_o = true;

    /* '<S280>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.NearAnn1MuteTargetLinearGain !=
            Model_TargetControlDsms.NearAnn1MuteCurrentGain)
    {
        /* '<S280>:1:11' done = false; */
        Model_Target_B.done_o = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S268>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S267>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S270>/In1' */
    Model_Target_B.In1_c = Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S267>/Triggered Subsystem' */
}

// NearAnn1Ann1MuteSet RTC NTF message preparation and packing '<S269>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn1Ann1MuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S269>/Notification' */

    /* S-Function (RTC_BytePack): '<S273>/PackNTF' */
    NearAnn1Ann1MuteSet_NTF_T* payloadNTF = (NearAnn1Ann1MuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_c;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn2Ann2NonEntGainCalcvncEnableRTC RTC Request-Response Handler (RTC ID 0x10010005) '<S320>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn2Ann2NonEntGainCalcvncEnableRTC(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S320>/Request' */

    /* S-Function (RTC_BytePack): '<S337>/UnpackREQ' */
    NearAnn2Ann2NonEntGainCalcvncEnableRTC_REQ_T* payloadREQ =
        (NearAnn2Ann2NonEntGainCalcvncEnableRTC_REQ_T*)pREQBuf;
    Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable =
        payloadREQ->vncEnable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn2Ann2NonEntGainCalcvncEnableRTC();

    /* Output and update for function-call system: '<S320>/Response' */

    /* S-Function (RTC_BytePack): '<S338>/PackRSP' */
    NearAnn2Ann2NonEntGainCalcvncEnableRTC_RSP_T* payloadRSP =
        (NearAnn2Ann2NonEntGainCalcvncEnableRTC_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->enable =
        Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn2Ann2MuteSet RTC Request-Response Handler (RTC ID 0x10000004) '<S349>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn2Ann2MuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S349>/Request' */

    /* S-Function (RTC_BytePack): '<S357>/UnpackREQ' */
    NearAnn2Ann2MuteSet_REQ_T* payloadREQ = (NearAnn2Ann2MuteSet_REQ_T*)pREQBuf;
    Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn2Ann2MuteSet();

    /* Output and update for function-call system: '<S349>/Response' */

    /* S-Function (RTC_BytePack): '<S358>/PackRSP' */
    NearAnn2Ann2MuteSet_RSP_T* payloadRSP = (NearAnn2Ann2MuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn2Ann2MuteSet RTC NTF check complete '<S349>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn2Ann2MuteSet( void )
{
    /* Output and update for function-call system: '<S349>/NtfCheck' */

    /* MATLAB Function: '<S348>/TriggeredFunction' */
    /* MATLAB Function: '<S348>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S354>:1' */
    /* '<S354>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S360>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S360>:1:9' done = true; */
    Model_Target_B.done_nh = true;

    /* '<S360>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.NearAnn2MuteTargetLinearGain !=
            Model_TargetControlDsms.NearAnn2MuteCurrentGain)
    {
        /* '<S360>:1:11' done = false; */
        Model_Target_B.done_nh = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S348>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S347>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S350>/In1' */
    Model_Target_B.In1_d2u =
        Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S347>/Triggered Subsystem' */
}

// NearAnn2Ann2MuteSet RTC NTF message preparation and packing '<S349>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn2Ann2MuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S349>/Notification' */

    /* S-Function (RTC_BytePack): '<S353>/PackNTF' */
    NearAnn2Ann2MuteSet_NTF_T* payloadNTF = (NearAnn2Ann2MuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_d2u;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn3Ann3NonEntGainCalcvncEnableRTC RTC Request-Response Handler (RTC ID 0x10010008) '<S400>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn3Ann3NonEntGainCalcvncEnableRTC(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S400>/Request' */

    /* S-Function (RTC_BytePack): '<S417>/UnpackREQ' */
    NearAnn3Ann3NonEntGainCalcvncEnableRTC_REQ_T* payloadREQ =
        (NearAnn3Ann3NonEntGainCalcvncEnableRTC_REQ_T*)pREQBuf;
    Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable =
        payloadREQ->vncEnable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn3Ann3NonEntGainCalcvncEnableRTC();

    /* Output and update for function-call system: '<S400>/Response' */

    /* S-Function (RTC_BytePack): '<S418>/PackRSP' */
    NearAnn3Ann3NonEntGainCalcvncEnableRTC_RSP_T* payloadRSP =
        (NearAnn3Ann3NonEntGainCalcvncEnableRTC_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->enable =
        Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn3Ann3MuteSet RTC Request-Response Handler (RTC ID 0x10000007) '<S429>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn3Ann3MuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S429>/Request' */

    /* S-Function (RTC_BytePack): '<S437>/UnpackREQ' */
    NearAnn3Ann3MuteSet_REQ_T* payloadREQ = (NearAnn3Ann3MuteSet_REQ_T*)pREQBuf;
    Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn3Ann3MuteSet();

    /* Output and update for function-call system: '<S429>/Response' */

    /* S-Function (RTC_BytePack): '<S438>/PackRSP' */
    NearAnn3Ann3MuteSet_RSP_T* payloadRSP = (NearAnn3Ann3MuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn3Ann3MuteSet RTC NTF check complete '<S429>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn3Ann3MuteSet( void )
{
    /* Output and update for function-call system: '<S429>/NtfCheck' */

    /* MATLAB Function: '<S428>/TriggeredFunction' */
    /* MATLAB Function: '<S428>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S434>:1' */
    /* '<S434>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S440>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S440>:1:9' done = true; */
    Model_Target_B.done_b3 = true;

    /* '<S440>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.NearAnn3MuteTargetLinearGain !=
            Model_TargetControlDsms.NearAnn3MuteCurrentGain)
    {
        /* '<S440>:1:11' done = false; */
        Model_Target_B.done_b3 = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S428>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S427>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S430>/In1' */
    Model_Target_B.In1_ip =
        Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S427>/Triggered Subsystem' */
}

// NearAnn3Ann3MuteSet RTC NTF message preparation and packing '<S429>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn3Ann3MuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S429>/Notification' */

    /* S-Function (RTC_BytePack): '<S433>/PackNTF' */
    NearAnn3Ann3MuteSet_NTF_T* payloadNTF = (NearAnn3Ann3MuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_ip;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn4Ann4NonEntGainCalcvncEnableRTC RTC Request-Response Handler (RTC ID 0x1001000b) '<S480>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn4Ann4NonEntGainCalcvncEnableRTC(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S480>/Request' */

    /* S-Function (RTC_BytePack): '<S497>/UnpackREQ' */
    NearAnn4Ann4NonEntGainCalcvncEnableRTC_REQ_T* payloadREQ =
        (NearAnn4Ann4NonEntGainCalcvncEnableRTC_REQ_T*)pREQBuf;
    Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable =
        payloadREQ->vncEnable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn4Ann4NonEntGainCalcvncEnableRTC();

    /* Output and update for function-call system: '<S480>/Response' */

    /* S-Function (RTC_BytePack): '<S498>/PackRSP' */
    NearAnn4Ann4NonEntGainCalcvncEnableRTC_RSP_T* payloadRSP =
        (NearAnn4Ann4NonEntGainCalcvncEnableRTC_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->enable =
        Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn4Ann4MuteSet RTC Request-Response Handler (RTC ID 0x1000000a) '<S509>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn4Ann4MuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S509>/Request' */

    /* S-Function (RTC_BytePack): '<S517>/UnpackREQ' */
    NearAnn4Ann4MuteSet_REQ_T* payloadREQ = (NearAnn4Ann4MuteSet_REQ_T*)pREQBuf;
    Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn4Ann4MuteSet();

    /* Output and update for function-call system: '<S509>/Response' */

    /* S-Function (RTC_BytePack): '<S518>/PackRSP' */
    NearAnn4Ann4MuteSet_RSP_T* payloadRSP = (NearAnn4Ann4MuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn4Ann4MuteSet RTC NTF check complete '<S509>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn4Ann4MuteSet( void )
{
    /* Output and update for function-call system: '<S509>/NtfCheck' */

    /* MATLAB Function: '<S508>/TriggeredFunction' */
    /* MATLAB Function: '<S508>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S514>:1' */
    /* '<S514>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S520>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S520>:1:9' done = true; */
    Model_Target_B.done_jh = true;

    /* '<S520>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.NearAnn4MuteTargetLinearGain !=
            Model_TargetControlDsms.NearAnn4MuteCurrentGain)
    {
        /* '<S520>:1:11' done = false; */
        Model_Target_B.done_jh = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S508>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S507>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S510>/In1' */
    Model_Target_B.In1_i = Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S507>/Triggered Subsystem' */
}

// NearAnn4Ann4MuteSet RTC NTF message preparation and packing '<S509>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn4Ann4MuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S509>/Notification' */

    /* S-Function (RTC_BytePack): '<S513>/PackNTF' */
    NearAnn4Ann4MuteSet_NTF_T* payloadNTF = (NearAnn4Ann4MuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_i;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnnNoiseLevel RTC Request-Response Handler (RTC ID 0x1002000d) '<S176>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnnNoiseLevel(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S176>/Request' */

    /* S-Function (RTC_BytePack): '<S233>/UnpackREQ' */
    NearAnnNoiseLevel_REQ_T* payloadREQ = (NearAnnNoiseLevel_REQ_T*)pREQBuf;
    Model_TargetNearAnnNoiseLevelRtcOut.REQ_NoiseSig = payloadREQ->NoiseSig;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S176>/Response' */

    /* S-Function (RTC_BytePack): '<S234>/PackRSP' */
    /* Byte Packing: <S234>/PackRSP : nothing to do */
}

// NearChannel1_Location RTC Request-Response Handler (RTC ID 0x1001000e) '<S131>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearChannel1_Location(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S131>/Request' */

    /* S-Function (RTC_BytePack): '<S144>/UnpackREQ' */
    NearChannel1_Location_REQ_T* payloadREQ = (NearChannel1_Location_REQ_T*)
        pREQBuf;
    Model_TargetNearChannel1_LocationRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearChannel1_LocationRtcOut.REQ_loc[0]),
                 (uint8_t*)payloadREQ->loc, sizeof(real32_T)*2 );// copy 8 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S131>/Response' */

    /* S-Function (RTC_BytePack): '<S145>/PackRSP' */
    NearChannel1_Location_RSP_T* payloadRSP = (NearChannel1_Location_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearChannel1_LocationRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearChannel2_Location RTC Request-Response Handler (RTC ID 0x1001000f) '<S130>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearChannel2_Location(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S130>/Request' */

    /* S-Function (RTC_BytePack): '<S138>/UnpackREQ' */
    NearChannel2_Location_REQ_T* payloadREQ = (NearChannel2_Location_REQ_T*)
        pREQBuf;
    Model_TargetNearChannel2_LocationRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearChannel2_LocationRtcOut.REQ_loc[0]),
                 (uint8_t*)payloadREQ->loc, sizeof(real32_T)*2 );// copy 8 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S130>/Response' */

    /* S-Function (RTC_BytePack): '<S139>/PackRSP' */
    NearChannel2_Location_RSP_T* payloadRSP = (NearChannel2_Location_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearChannel2_LocationRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearChannel3_Location RTC Request-Response Handler (RTC ID 0x10010010) '<S133>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearChannel3_Location(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S133>/Request' */

    /* S-Function (RTC_BytePack): '<S156>/UnpackREQ' */
    NearChannel3_Location_REQ_T* payloadREQ = (NearChannel3_Location_REQ_T*)
        pREQBuf;
    Model_TargetNearChannel3_LocationRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearChannel3_LocationRtcOut.REQ_loc[0]),
                 (uint8_t*)payloadREQ->loc, sizeof(real32_T)*2 );// copy 8 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S133>/Response' */

    /* S-Function (RTC_BytePack): '<S157>/PackRSP' */
    NearChannel3_Location_RSP_T* payloadRSP = (NearChannel3_Location_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearChannel3_LocationRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearChannel4_Location RTC Request-Response Handler (RTC ID 0x10010011) '<S132>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearChannel4_Location(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S132>/Request' */

    /* S-Function (RTC_BytePack): '<S150>/UnpackREQ' */
    NearChannel4_Location_REQ_T* payloadREQ = (NearChannel4_Location_REQ_T*)
        pREQBuf;
    Model_TargetNearChannel4_LocationRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearChannel4_LocationRtcOut.REQ_loc[0]),
                 (uint8_t*)payloadREQ->loc, sizeof(real32_T)*2 );// copy 8 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S132>/Response' */

    /* S-Function (RTC_BytePack): '<S151>/PackRSP' */
    NearChannel4_Location_RSP_T* payloadRSP = (NearChannel4_Location_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearChannel4_LocationRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearDr_RouterSet RTC Request-Response Handler (RTC ID 0x10010012) '<S65>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearDr_RouterSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S65>/Request' */

    /* S-Function (RTC_BytePack): '<S71>/UnpackREQ' */
    NearDr_RouterSet_REQ_T* payloadREQ = (NearDr_RouterSet_REQ_T*)pREQBuf;
    Model_TargetNearDr_RouterSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearDr_RouterSetRtcOut.REQ_routerMap[0]),
                 (uint8_t*)payloadREQ->routerMap, sizeof(int32_T)*18 );// copy 72 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S65>/Response' */

    /* S-Function (RTC_BytePack): '<S72>/PackRSP' */
    NearDr_RouterSet_RSP_T* payloadRSP = (NearDr_RouterSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearDr_RouterSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    (void)memcpy((uint8_t*)payloadRSP->routerMap, (uint8_t*)
                 &(Model_TargetNearDr_RouterSetRtcOut.REQ_routerMap[0]), sizeof
                 (int32_T)*18 );       // copy 72 chars

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearEnable RTC Request-Response Handler (RTC ID 0x10010013) '<S27>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearEnable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S27>/Request' */

    /* S-Function (RTC_BytePack): '<S559>/UnpackREQ' */
    NearEnable_REQ_T* payloadREQ = (NearEnable_REQ_T*)pREQBuf;
    Model_TargetNearEnableRtcOut.REQ_caller_handle = payloadREQ->caller_handle;
    Model_TargetNearEnableRtcOut.REQ_Enable = payloadREQ->Enable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S27>/Response' */

    /* S-Function (RTC_BytePack): '<S560>/PackRSP' */
    NearEnable_RSP_T* payloadRSP = (NearEnable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle = Model_TargetNearEnableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearFr_RouterSet RTC Request-Response Handler (RTC ID 0x10010014) '<S109>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearFr_RouterSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S109>/Request' */

    /* S-Function (RTC_BytePack): '<S115>/UnpackREQ' */
    NearFr_RouterSet_REQ_T* payloadREQ = (NearFr_RouterSet_REQ_T*)pREQBuf;
    Model_TargetNearFr_RouterSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearFr_RouterSetRtcOut.REQ_routerMap[0]),
                 (uint8_t*)payloadREQ->routerMap, sizeof(int32_T)*18 );// copy 72 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S109>/Response' */

    /* S-Function (RTC_BytePack): '<S116>/PackRSP' */
    NearFr_RouterSet_RSP_T* payloadRSP = (NearFr_RouterSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearFr_RouterSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    (void)memcpy((uint8_t*)payloadRSP->routerMap, (uint8_t*)
                 &(Model_TargetNearFr_RouterSetRtcOut.REQ_routerMap[0]), sizeof
                 (int32_T)*18 );       // copy 72 chars

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotmuteReference RTC Request-Response Handler (RTC ID 0x1001001e) '<S674>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotmuteReference(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S674>/Request' */

    /* S-Function (RTC_BytePack): '<S690>/UnpackREQ' */
    PreAmpAudiopilotmuteReference_REQ_T* payloadREQ =
        (PreAmpAudiopilotmuteReference_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_muteReference =
        payloadREQ->muteReference;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S674>/Response' */

    /* S-Function (RTC_BytePack): '<S691>/PackRSP' */
    PreAmpAudiopilotmuteReference_RSP_T* payloadRSP =
        (PreAmpAudiopilotmuteReference_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->muteReference =
        Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_muteReference;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotsetSpeedIn RTC Request-Response Handler (RTC ID 0x10020027) '<S675>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetSpeedIn(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S675>/Request' */

    /* S-Function (RTC_BytePack): '<S696>/UnpackREQ' */
    PreAmpAudiopilotsetSpeedIn_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetSpeedIn_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetSpeedInRtcOut.REQ_speedIn =
        payloadREQ->speedIn;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S675>/Response' */

    /* S-Function (RTC_BytePack): '<S697>/PackRSP' */
    /* Byte Packing: <S697>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetHVACSetting RTC Request-Response Handler (RTC ID 0x10020023) '<S678>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetHVACSetting(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S678>/Request' */

    /* S-Function (RTC_BytePack): '<S684>/UnpackREQ' */
    PreAmpAudiopilotsetHVACSetting_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetHVACSetting_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetHVACSettingRtcOut.REQ_HVACSetting =
        payloadREQ->HVACSetting;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpAudiopilotsetHVACSetting();

    /* Output and update for function-call system: '<S678>/Response' */

    /* S-Function (RTC_BytePack): '<S685>/PackRSP' */
    /* Byte Packing: <S685>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetDynEQBoostOverRide RTC Request-Response Handler (RTC ID 0x10020020) '<S772>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetDynEQBoostOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S772>/Request' */

    /* S-Function (RTC_BytePack): '<S780>/UnpackREQ' */
    PreAmpAudiopilotsetDynEQBoostOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetDynEQBoostOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetDynEQBoostOverRideRtcOut.REQ_DynEQBoostOverRideFlag
        = payloadREQ->DynEQBoostOverRideFlag;
    Model_TargetPreAmpAudiopilotsetDynEQBoostOverRideRtcOut.REQ_DynEQBoostOverRide
        = payloadREQ->DynEQBoostOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S772>/Response' */

    /* S-Function (RTC_BytePack): '<S781>/PackRSP' */
    /* Byte Packing: <S781>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetVNCTrebleBoostOverRide RTC Request-Response Handler (RTC ID 0x1002002b) '<S775>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetVNCTrebleBoostOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S775>/Request' */

    /* S-Function (RTC_BytePack): '<S798>/UnpackREQ' */
    PreAmpAudiopilotsetVNCTrebleBoostOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetVNCTrebleBoostOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetVNCTrebleBoostOverRideRtcOut.REQ_VNCTrebleBoostOverRideFlag
        = payloadREQ->VNCTrebleBoostOverRideFlag;
    Model_TargetPreAmpAudiopilotsetVNCTrebleBoostOverRideRtcOut.REQ_VNCTrebleBoostOverRide
        = payloadREQ->VNCTrebleBoostOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S775>/Response' */

    /* S-Function (RTC_BytePack): '<S799>/PackRSP' */
    /* Byte Packing: <S799>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetLoudSignalOverRide RTC Request-Response Handler (RTC ID 0x10020025) '<S801>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetLoudSignalOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S801>/Request' */

    /* S-Function (RTC_BytePack): '<S808>/UnpackREQ' */
    PreAmpAudiopilotsetLoudSignalOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetLoudSignalOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetLoudSignalOverRideRtcOut.REQ_LoudSignalOverRideFlag
        = payloadREQ->LoudSignalOverRideFlag;
    Model_TargetPreAmpAudiopilotsetLoudSignalOverRideRtcOut.REQ_LoudSignalOverRide
        = payloadREQ->LoudSignalOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S801>/Response' */

    /* S-Function (RTC_BytePack): '<S809>/PackRSP' */
    /* Byte Packing: <S809>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetVNCSignalOverRide RTC Request-Response Handler (RTC ID 0x1002002a) '<S803>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetVNCSignalOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S803>/Request' */

    /* S-Function (RTC_BytePack): '<S814>/UnpackREQ' */
    PreAmpAudiopilotsetVNCSignalOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetVNCSignalOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetVNCSignalOverRideRtcOut.REQ_VNCSignalOverRideFlag
        = payloadREQ->VNCSignalOverRideFlag;
    Model_TargetPreAmpAudiopilotsetVNCSignalOverRideRtcOut.REQ_VNCSignalOverRide
        = payloadREQ->VNCSignalOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S803>/Response' */

    /* S-Function (RTC_BytePack): '<S815>/PackRSP' */
    /* Byte Packing: <S815>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetLFNoiseOverRide RTC Request-Response Handler (RTC ID 0x10020024) '<S823>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetLFNoiseOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S823>/Request' */

    /* S-Function (RTC_BytePack): '<S837>/UnpackREQ' */
    PreAmpAudiopilotsetLFNoiseOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetLFNoiseOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetLFNoiseOverRideRtcOut.REQ_LFNoiseOverRideFlag
        = payloadREQ->LFNoiseOverRideFlag;
    Model_TargetPreAmpAudiopilotsetLFNoiseOverRideRtcOut.REQ_LFNoiseOverRide =
        payloadREQ->LFNoiseOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S823>/Response' */

    /* S-Function (RTC_BytePack): '<S838>/PackRSP' */
    /* Byte Packing: <S838>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetWBNoiseOverRide RTC Request-Response Handler (RTC ID 0x1002002c) '<S826>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetWBNoiseOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S826>/Request' */

    /* S-Function (RTC_BytePack): '<S849>/UnpackREQ' */
    PreAmpAudiopilotsetWBNoiseOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetWBNoiseOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetWBNoiseOverRideRtcOut.REQ_WBNoiseOverRideFlag
        = payloadREQ->WBNoiseOverRideFlag;
    Model_TargetPreAmpAudiopilotsetWBNoiseOverRideRtcOut.REQ_WBNoiseOverRide =
        payloadREQ->WBNoiseOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S826>/Response' */

    /* S-Function (RTC_BytePack): '<S850>/PackRSP' */
    /* Byte Packing: <S850>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetHFNoiseOverRide RTC Request-Response Handler (RTC ID 0x10020022) '<S822>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetHFNoiseOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S822>/Request' */

    /* S-Function (RTC_BytePack): '<S831>/UnpackREQ' */
    PreAmpAudiopilotsetHFNoiseOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetHFNoiseOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetHFNoiseOverRideRtcOut.REQ_HFNoiseOverRideFlag
        = payloadREQ->HFNoiseOverRideFlag;
    Model_TargetPreAmpAudiopilotsetHFNoiseOverRideRtcOut.REQ_HFNoiseOverRide =
        payloadREQ->HFNoiseOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S822>/Response' */

    /* S-Function (RTC_BytePack): '<S832>/PackRSP' */
    /* Byte Packing: <S832>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetRatioOverRide RTC Request-Response Handler (RTC ID 0x10020026) '<S825>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetRatioOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S825>/Request' */

    /* S-Function (RTC_BytePack): '<S843>/UnpackREQ' */
    PreAmpAudiopilotsetRatioOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetRatioOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetRatioOverRideRtcOut.REQ_RatioOverRideFlag =
        payloadREQ->RatioOverRideFlag;
    Model_TargetPreAmpAudiopilotsetRatioOverRideRtcOut.REQ_RatioOverRide =
        payloadREQ->RatioOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S825>/Response' */

    /* S-Function (RTC_BytePack): '<S844>/PackRSP' */
    /* Byte Packing: <S844>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetDyneqOn RTC Request-Response Handler (RTC ID 0x10010021) '<S862>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetDyneqOn(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S862>/Request' */

    /* S-Function (RTC_BytePack): '<S871>/UnpackREQ' */
    PreAmpAudiopilotsetDyneqOn_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetDyneqOn_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_dyneq_on =
        payloadREQ->dyneq_on;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S862>/Response' */

    /* S-Function (RTC_BytePack): '<S872>/PackRSP' */
    PreAmpAudiopilotsetDyneqOn_RSP_T* payloadRSP =
        (PreAmpAudiopilotsetDyneqOn_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->dyneq_on =
        Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_dyneq_on;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotsetAudioPilotOn RTC Request-Response Handler (RTC ID 0x1001001f) '<S863>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetAudioPilotOn(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S863>/Request' */

    /* S-Function (RTC_BytePack): '<S877>/UnpackREQ' */
    PreAmpAudiopilotsetAudioPilotOn_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetAudioPilotOn_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_audiopilot_on =
        payloadREQ->audiopilot_on;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S863>/Response' */

    /* S-Function (RTC_BytePack): '<S878>/PackRSP' */
    PreAmpAudiopilotsetAudioPilotOn_RSP_T* payloadRSP =
        (PreAmpAudiopilotsetAudioPilotOn_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->audiopilot_on =
        Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_audiopilot_on;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotsetVNCBassBoostOverRide RTC Request-Response Handler (RTC ID 0x10020028) '<S773>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetVNCBassBoostOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S773>/Request' */

    /* S-Function (RTC_BytePack): '<S786>/UnpackREQ' */
    PreAmpAudiopilotsetVNCBassBoostOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetVNCBassBoostOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetVNCBassBoostOverRideRtcOut.REQ_VNCBassBoostOverRideFlag
        = payloadREQ->VNCBassBoostOverRideFlag;
    Model_TargetPreAmpAudiopilotsetVNCBassBoostOverRideRtcOut.REQ_VNCBassBoostOverRide
        = payloadREQ->VNCBassBoostOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S773>/Response' */

    /* S-Function (RTC_BytePack): '<S787>/PackRSP' */
    /* Byte Packing: <S787>/PackRSP : nothing to do */
}

// PreAmpAudiopilotgetBassBoost RTC Request-Response Handler (RTC ID 0x1001001b) '<S699>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotgetBassBoost(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S699>/Request' */

    /* S-Function (RTC_BytePack): '<S720>/UnpackREQ' */
    PreAmpAudiopilotgetBassBoost_REQ_T* payloadREQ =
        (PreAmpAudiopilotgetBassBoost_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotgetBassBoostRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S699>/Response' */

    /* S-Function (RTC_BytePack): '<S721>/PackRSP' */
    PreAmpAudiopilotgetBassBoost_RSP_T* payloadRSP =
        (PreAmpAudiopilotgetBassBoost_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotgetBassBoostRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->bassBoost = Model_Target_B.Min;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotsetVNCMidBoostOverRide RTC Request-Response Handler (RTC ID 0x10020029) '<S774>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetVNCMidBoostOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S774>/Request' */

    /* S-Function (RTC_BytePack): '<S792>/UnpackREQ' */
    PreAmpAudiopilotsetVNCMidBoostOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetVNCMidBoostOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetVNCMidBoostOverRideRtcOut.REQ_VNCMidBoostOverRideFlag
        = payloadREQ->VNCMidBoostOverRideFlag;
    Model_TargetPreAmpAudiopilotsetVNCMidBoostOverRideRtcOut.REQ_VNCMidBoostOverRide
        = payloadREQ->VNCMidBoostOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S774>/Response' */

    /* S-Function (RTC_BytePack): '<S793>/PackRSP' */
    /* Byte Packing: <S793>/PackRSP : nothing to do */
}

// PreAmpAudiopilotgetMidBoost RTC Request-Response Handler (RTC ID 0x1001001c) '<S700>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotgetMidBoost(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S700>/Request' */

    /* S-Function (RTC_BytePack): '<S726>/UnpackREQ' */
    PreAmpAudiopilotgetMidBoost_REQ_T* payloadREQ =
        (PreAmpAudiopilotgetMidBoost_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotgetMidBoostRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S700>/Response' */

    /* S-Function (RTC_BytePack): '<S727>/PackRSP' */
    PreAmpAudiopilotgetMidBoost_RSP_T* payloadRSP =
        (PreAmpAudiopilotgetMidBoost_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotgetMidBoostRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->midBoost = Model_Target_B.Product1_o;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotgetTrebleBoost RTC Request-Response Handler (RTC ID 0x1001001d) '<S701>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotgetTrebleBoost(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S701>/Request' */

    /* S-Function (RTC_BytePack): '<S732>/UnpackREQ' */
    PreAmpAudiopilotgetTrebleBoost_REQ_T* payloadREQ =
        (PreAmpAudiopilotgetTrebleBoost_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotgetTrebleBoostRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S701>/Response' */

    /* S-Function (RTC_BytePack): '<S733>/PackRSP' */
    PreAmpAudiopilotgetTrebleBoost_RSP_T* payloadRSP =
        (PreAmpAudiopilotgetTrebleBoost_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotgetTrebleBoostRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->trebleBoost = Model_Target_B.Product;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotgetAverageAudioPilotBoostLevel RTC Request-Response Handler (RTC ID 0x1001001a) '<S737>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotgetAverageAudioPilotBoostLevel(void* pREQBuf,
    void* pRSPBuf)
{
    /* Output and update for function-call system: '<S737>/Request' */

    /* S-Function (RTC_BytePack): '<S820>/UnpackREQ' */
    PreAmpAudiopilotgetAverageAudioPilotBoostLevel_REQ_T* payloadREQ =
        (PreAmpAudiopilotgetAverageAudioPilotBoostLevel_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotgetAverageAudioPilotBoostLevelRtcOut.REQ_caller_handle
        = payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpAudiopilotgetAverageAudioPilotBoostLevel();

    /* Output and update for function-call system: '<S737>/Response' */

    /* S-Function (RTC_BytePack): '<S821>/PackRSP' */
    PreAmpAudiopilotgetAverageAudioPilotBoostLevel_RSP_T* payloadRSP =
        (PreAmpAudiopilotgetAverageAudioPilotBoostLevel_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotgetAverageAudioPilotBoostLevelRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->level = Model_Target_B.boostAverage;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpVolumeCfgSet RTC Request-Response Handler (RTC ID 0x1000003c) '<S1114>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpVolumeCfgSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1114>/Request' */

    /* S-Function (RTC_BytePack): '<S1126>/UnpackREQ' */
    PreAmpVolumeCfgSet_REQ_T* payloadREQ = (PreAmpVolumeCfgSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_index = payloadREQ->gain_index;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_offset =
        payloadREQ->gain_offset;
    (Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpVolumeCfgSet();

    /* Output and update for function-call system: '<S1114>/Response' */

    /* S-Function (RTC_BytePack): '<S1127>/PackRSP' */
    PreAmpVolumeCfgSet_RSP_T* payloadRSP = (PreAmpVolumeCfgSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index = Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpVolumeCfgSet RTC NTF check complete '<S1114>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpVolumeCfgSet( void )
{
    /* Output and update for function-call system: '<S1114>/NtfCheck' */

    /* MATLAB Function: '<S1130>/rgainx check sequence' */
    /* MATLAB Function: '<S1130>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1123>:1' */
    /* '<S1123>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S1135>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S1135>:1:7' done = true; */
    Model_Target_B.done_e = true;

    /* '<S1135>:1:8' for i=1:MaskNumRampers */
    /* '<S1135>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.PreAmpVolumeCfgRampers.targetGain !=
            Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain)
    {
        /* '<S1135>:1:10' done = false; */
        Model_Target_B.done_e = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S1130>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S666>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1116>/In1' */
    Model_Target_B.In1_o = Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S666>/Triggered Subsystem' */
}

// PreAmpVolumeCfgSet RTC NTF message preparation and packing '<S1114>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpVolumeCfgSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1114>/Notification' */

    /* S-Function (RTC_BytePack): '<S1122>/PackNTF' */
    PreAmpVolumeCfgSet_NTF_T* payloadNTF = (PreAmpVolumeCfgSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_o;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpBalance_CfgSet RTC Request-Response Handler (RTC ID 0x1000002d) '<S1143>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpBalance_CfgSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1143>/Request' */

    /* S-Function (RTC_BytePack): '<S1162>/UnpackREQ' */
    PreAmpBalance_CfgSet_REQ_T* payloadREQ = (PreAmpBalance_CfgSet_REQ_T*)
        pREQBuf;
    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpBalance_CfgSet();

    /* Output and update for function-call system: '<S1143>/Response' */

    /* S-Function (RTC_BytePack): '<S1163>/PackRSP' */
    PreAmpBalance_CfgSet_RSP_T* payloadRSP = (PreAmpBalance_CfgSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpBalance_CfgSet RTC NTF check complete '<S1143>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpBalance_CfgSet( void )
{
    /* Output and update for function-call system: '<S1143>/NtfCheck' */
    {
        int32_T i;
        boolean_T exitg1;

        /* MATLAB Function: '<S1142>/check sequence' */
        /* MATLAB Function: '<S1142>/check sequence' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1159>:1' */
        /* '<S1159>:1:3' go(); */
        /*  Function which checks if the notification sequence */
        /*  has completed successfully  */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/Balance/Balance/check sequence': '<S1156>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1156>:1:8' done = true; */
        Model_Target_B.done_p = true;

        /* '<S1156>:1:10' for i=1:MaskNumRampers */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i <= 3))
        {
            /* '<S1156>:1:11' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
            if (Model_TargetControlDsms.PreAmpBalance_CfgRampers[i].targetGain
                    != Model_TargetControlDsms.PreAmpBalance_CfgRampers[i].
                    currentGain)
            {
                /* '<S1156>:1:12' done = false; */
                Model_Target_B.done_p = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* Outputs for Function Call SubSystem: '<S1142>/Triggered Subsystem' */
        /* SignalConversion generated from: '<S1146>/In1' */
        Model_Target_B.In1_j =
            Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index;

        /* End of Outputs for SubSystem: '<S1142>/Triggered Subsystem' */
    }
}

// PreAmpBalance_CfgSet RTC NTF message preparation and packing '<S1143>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpBalance_CfgSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1143>/Notification' */

    /* S-Function (RTC_BytePack): '<S1158>/PackNTF' */
    PreAmpBalance_CfgSet_NTF_T* payloadNTF = (PreAmpBalance_CfgSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_j;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

int32_T div_nde_s32_floor(int32_T numerator, int32_T denominator)
{
    return (((numerator < 0) != (denominator < 0)) && (numerator % denominator
             != 0) ? -1 : 0) + numerator / denominator;
}

int32_T div_nzp_s32_floor(int32_T numerator, int32_T denominator)
{
    uint32_T absDenominator;
    uint32_T absNumerator;
    uint32_T tempAbsQuotient;
    boolean_T quotientNeedsNegation;
    absNumerator = numerator < 0 ? ~(uint32_T)numerator + 1U : (uint32_T)
        numerator;
    absDenominator = denominator < 0 ? ~(uint32_T)denominator + 1U : (uint32_T)
        denominator;
    quotientNeedsNegation = ((numerator < 0) != (denominator < 0));
    tempAbsQuotient = absNumerator / absDenominator;
    if (quotientNeedsNegation)
    {
        absNumerator %= absDenominator;
        if (absNumerator > 0U)
        {
            tempAbsQuotient++;
        }
    }

    return quotientNeedsNegation ? -(int32_T)tempAbsQuotient : (int32_T)
        tempAbsQuotient;
}

/*
 * Set which subrates need to run this base step (base rate always runs).
 * This function must be called prior to calling the model step function
 * in order to remember which rates need to run this base step.  The
 * buffering of events allows for overlapping preemption.
 */
void Model_Target_SetEventsForThisBaseStep(boolean_T *eventFlags)
{
    /* Task runs when its counter is zero, computed via rtmStepTask macro */
    eventFlags[1] = ((boolean_T)rtmStepTask(Model_Target_M, 1));
    eventFlags[2] = ((boolean_T)rtmStepTask(Model_Target_M, 2));
    eventFlags[3] = ((boolean_T)rtmStepTask(Model_Target_M, 3));
    eventFlags[4] = ((boolean_T)rtmStepTask(Model_Target_M, 4));
    eventFlags[5] = ((boolean_T)rtmStepTask(Model_Target_M, 5));
    eventFlags[6] = ((boolean_T)rtmStepTask(Model_Target_M, 6));
    eventFlags[7] = ((boolean_T)rtmStepTask(Model_Target_M, 7));
    eventFlags[8] = ((boolean_T)rtmStepTask(Model_Target_M, 8));
}

/*
 *         This function updates active task flag for each subrate
 *         and rate transition flags for tasks that exchange data.
 *         The function assumes rate-monotonic multitasking scheduler.
 *         The function must be called at model base rate so that
 *         the generated code self-manages all its subrates and rate
 *         transition flags.
 */
static void rate_monotonic_scheduler(void)
{
    /* To ensure a deterministic data transfer between two rates,
     * data is transferred at the priority of a fast task and the frequency
     * of the slow task.  The following flags indicate when the data transfer
     * happens.  That is, a rate interaction flag is set true when both rates
     * will run, and false otherwise.
     */

    /* tid 2 shares data with slower tid rate: 6 */
    if (Model_Target_M->Timing.TaskCounters.TID[2] == 0)
    {
        Model_Target_M->Timing.RateInteraction.TID2_6 =
            (Model_Target_M->Timing.TaskCounters.TID[6] == 0);
    }

    /* tid 7 shares data with slower tid rate: 8 */
    if (Model_Target_M->Timing.TaskCounters.TID[7] == 0)
    {
        Model_Target_M->Timing.RateInteraction.TID7_8 =
            (Model_Target_M->Timing.TaskCounters.TID[8] == 0);
    }

    /* Compute which subrates run during the next base time step.  Subrates
     * are an integer multiple of the base rate counter.  Therefore, the subtask
     * counter is reset when it reaches its limit (zero means run).
     */
    (Model_Target_M->Timing.TaskCounters.TID[1])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[1]) > 11)
    {                         /* Sample time: [0.00066666666666666664s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[1] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[2])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[2]) > 12)
    {                         /* Sample time: [0.00072222222222222219s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[2] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[3])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[3]) > 25)
    {                          /* Sample time: [0.0014444444444444444s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[3] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[4])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[4]) > 51)
    {                          /* Sample time: [0.0028888888888888888s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[4] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[5])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[5]) > 207)
    {                           /* Sample time: [0.011555555555555555s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[5] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[6])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[6]) > 831)
    {                            /* Sample time: [0.04622222222222222s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[6] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[7])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[7]) > 3327)
    {                            /* Sample time: [0.18488888888888888s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[7] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[8])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[8]) > 9983)
    {                            /* Sample time: [0.55466666666666664s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[8] = 0;
    }
}

/* Output and update for atomic system: '<Root>/InputSelect' */
void Model_Target_InputSelect(void)
{
    int32_T rtb_routerMapOut[12];
    int32_T ind;
    int32_T rtb_routerMapOut_e;
    int_T linIx;
    real32_T rtb_Assignment[384];
    int8_T rtb_FindNonzeroElements[12];
    boolean_T rtb_OR[12];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S15>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S12>/MATLAB Function' incorporates:
     *  S-Function (TOP_MEX): '<S12>/TOP'
     */
    /*  tuneTopMap is provided via a tune variable. However  */
    /*  if parameters are provided through RTC, the block will use the values  */
    /*  given in the RTC messages. */
    /* MATLAB Function 'InputSelect/Router/MATLAB Function': '<S14>:1' */
    /* '<S14>:1:7' Numiters=size(rtcMap,1); */
    /* '<S14>:1:8' routerMapOut = int32(tuneTopMap); */
    /* '<S14>:1:9' for ind=1:Numiters */
    for (ind = 0; ind < 12; ind++)
    {
        rtb_routerMapOut[ind] = Model_Target_InputSelect0.RouterCfgOutMap[ind];

        /* '<S14>:1:10' if (rtcMap(ind)) */
        if (Model_TargetInputSelectRouterCfgSetRtcOut.REQ_routerMap[ind] != 0)
        {
            /* '<S14>:1:11' routerMapOut(ind) = rtcMap(ind); */
            rtb_routerMapOut[ind] =
                Model_TargetInputSelectRouterCfgSetRtcOut.REQ_routerMap[ind];
        }
    }

    /* End of MATLAB Function: '<S12>/MATLAB Function' */
    /* End of Outputs for S-Function (RTC_NTF): '<S15>/NTF Trigger' */
    for (ind = 0; ind < 12; ind++)
    {
        /* S-Function (sdspperm2): '<S16>/Variable Selector' incorporates:
         *  Assignment: '<S16>/Assignment'
         *  SignalConversion generated from: '<S8>/In'
         */
        rtb_routerMapOut_e = rtb_routerMapOut[ind];
        linIx = rtb_routerMapOut_e;
        if (rtb_routerMapOut_e - 1 < 0)
        {
            linIx = 1;
        }
        else if (rtb_routerMapOut_e - 1 >= 5)
        {
            linIx = 5;
        }

        memcpy(&rtb_Assignment[ind << 5], &Model_Target_B.In[(linIx << 5) + -32],
               sizeof(real32_T) << 5U);

        /* End of S-Function (sdspperm2): '<S16>/Variable Selector' */

        /* Logic: '<S16>/OR' incorporates:
         *  Constant: '<S23>/Constant'
         *  Constant: '<S24>/Constant'
         *  RelationalOperator: '<S23>/Compare'
         *  RelationalOperator: '<S24>/Compare'
         */
        rtb_OR[ind] = ((rtb_routerMapOut_e <= 0) || (rtb_routerMapOut_e > 2));
    }

    /* Find: '<S16>/Find Nonzero Elements' incorporates:
     *  Logic: '<S16>/OR'
     */
    ind = 0;
    linIx = 0;
    for (rtb_routerMapOut_e = 0; rtb_routerMapOut_e < 12; rtb_routerMapOut_e++)
    {
        if (rtb_OR[linIx])
        {
            rtb_FindNonzeroElements[ind] = (int8_T)(rtb_routerMapOut_e + 1);
            ind++;
        }

        linIx++;
    }

    Model_Target_DW.FindNonzeroElements_DIMS1_f = ind;

    /* End of Find: '<S16>/Find Nonzero Elements' */

    /* Assignment: '<S16>/Assignment' incorporates:
     *  Constant: '<S16>/Constant3'
     *  Find: '<S16>/Find Nonzero Elements'
     */
    for (ind = 0; ind < Model_Target_DW.FindNonzeroElements_DIMS1_f; ind++)
    {
        for (rtb_routerMapOut_e = 0; rtb_routerMapOut_e < 32; rtb_routerMapOut_e
                ++)
        {
            rtb_Assignment[rtb_routerMapOut_e + ((rtb_FindNonzeroElements[ind] -
                1) << 5)] = 0.0F;
        }
    }

    /* End of Assignment: '<S16>/Assignment' */
    /* S-Function (sdspperm2): '<S3>/Variable Selector1' incorporates:
     *  Assignment: '<S16>/Assignment'
     */
    memcpy(&Model_Target_B.VariableSelector1[0], &rtb_Assignment[0], sizeof
           (real32_T) << 6U);

    /* S-Function (sdspperm2): '<S3>/Variable Selector2' incorporates:
     *  Assignment: '<S16>/Assignment'
     */
    for (ind = 0; ind < 2; ind++)
    {
        linIx = Model_Target_ConstP.VariableSelector2_Elements[ind];
        if (Model_Target_ConstP.VariableSelector2_Elements[ind] < 0)
        {
            linIx = 0;
        }
        else if (Model_Target_ConstP.VariableSelector2_Elements[ind] >= 12)
        {
            linIx = 11;
        }

        memcpy(&Model_Target_B.VariableSelector2[ind << 5],
               &rtb_Assignment[linIx << 5], sizeof(real32_T) << 5U);
    }

    /* End of S-Function (sdspperm2): '<S3>/Variable Selector2' */

    /* S-Function (sdspperm2): '<S3>/Variable Selector3' incorporates:
     *  Assignment: '<S16>/Assignment'
     */
    memcpy(&Model_Target_B.VariableSelector3[0], &rtb_Assignment[128], sizeof
           (real32_T) << 5U);

    /* M-S-Function: '<S3>/FeaturePath' */
    /* MATLAB Function 'InputSelect/cross-partition buffer': '<S13>:1' */
    /* '<S13>:1:3' y = u; */
}

/* Output and update for function-call system: '<S47>/init' */
void InitTrigger_Model_340_172_156(void)
{
    /* MATLAB Function: '<S46>/PoolIirInit' */
    /* MATLAB Function: '<S46>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S43>/TOP'
     *  S-Function (TOP_MEX): '<S43>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S50>:1' */
    /* '<S50>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S48>:1' */
    /*  Extract configuration information from inputs */
    /* '<S48>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S48>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S48>:1:24' VariantStr = char(VariantUint8); */
    /* '<S48>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S48>:1:28' else */
    /* '<S48>:1:29' switch(VariantStr) */
    /* '<S48>:1:30' case{"Hexagon"} */
    /* '<S48>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S48>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S48>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearFsDrEq47493states[0], &Model_Target_B.audioOut_o2[0], 8U,
                 7U, &(Model_Target_Near0.Dr_PooliirPooliirNumStages[0]),
                 &(Model_Target_Near0Dr_PooliirpooliirCoeffs[0]),
                 &NearFsDrEq47493states[0], 1417U, 0U, 400U);

    /* '<S48>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S59>/init' */
void InitTrigger_Model_457_172_156(void)
{
    /* MATLAB Function: '<S58>/PoolIirInit' */
    /* MATLAB Function: '<S58>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S55>/TOP'
     *  S-Function (TOP_MEX): '<S55>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S62>:1' */
    /* '<S62>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S60>:1' */
    /*  Extract configuration information from inputs */
    /* '<S60>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S60>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S60>:1:24' VariantStr = char(VariantUint8); */
    /* '<S60>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S60>:1:28' else */
    /* '<S60>:1:29' switch(VariantStr) */
    /* '<S60>:1:30' case{"Hexagon"} */
    /* '<S60>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S60>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S60>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearHrEqDr25031states[0], &Model_Target_B.audioOut_o[0], 8U,
                 4U, &(Model_Target_Near0.Dr_PoolIirTunablePooliirNumStages[0]),
                 &(Model_Target_Near0Dr_PoolIirTunablepooliirCoeffs[0]),
                 &NearHrEqDr25031states[0], 817U, 0U, 400U);

    /* '<S60>:1:34' states(1) = y; */
}

/*
 * Output and update for atomic system:
 *    '<S63>/MATLAB Function'
 *    '<S107>/MATLAB Function'
 */
void Model_Target_MATLABFunction(const int32_T rtu_tuneTopMap[18], const int32_T
    rtu_rtcMap[18], B_MATLABFunction_Model_Target_T *localB)
{
    int32_T ind;

    /*  tuneTopMap is provided via a tune variable. However  */
    /*  if parameters are provided through RTC, the block will use the values  */
    /*  given in the RTC messages. */
    /* MATLAB Function 'NEAR/Near1p1/DrProc/RouterDr/InnerLink/MATLAB Function': '<S64>:1' */
    /* '<S64>:1:7' Numiters=size(rtcMap,1); */
    /* '<S64>:1:8' routerMapOut = int32(tuneTopMap); */
    /* '<S64>:1:9' for ind=1:Numiters */
    for (ind = 0; ind < 18; ind++)
    {
        localB->routerMapOut[ind] = rtu_tuneTopMap[ind];

        /* '<S64>:1:10' if (rtcMap(ind)) */
        if (rtu_rtcMap[ind] != 0)
        {
            /* '<S64>:1:11' routerMapOut(ind) = rtcMap(ind); */
            localB->routerMapOut[ind] = rtu_rtcMap[ind];
        }
    }
}

/* Output and update for function-call system: '<S91>/init' */
void InitTrigger_Model_607_172_156(void)
{
    /* MATLAB Function: '<S90>/PoolIirInit' */
    /* MATLAB Function: '<S90>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S87>/TOP'
     *  S-Function (TOP_MEX): '<S87>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S94>:1' */
    /* '<S94>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S92>:1' */
    /*  Extract configuration information from inputs */
    /* '<S92>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S92>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S92>:1:24' VariantStr = char(VariantUint8); */
    /* '<S92>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S92>:1:28' else */
    /* '<S92>:1:29' switch(VariantStr) */
    /* '<S92>:1:30' case{"Hexagon"} */
    /* '<S92>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S92>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S92>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearFsFrEq10008states[0], &Model_Target_B.audioOut_dj[0], 32U,
                 5U, &(Model_Target_Near0.Fr_PooliirPooliirNumStages[0]),
                 &(Model_Target_Near0.Fr_PooliirpooliirCoeffs[0]),
                 &NearFsFrEq10008states[0], 1017U, 0U, 400U);

    /* '<S92>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S103>/init' */
void InitTrigger_Model_644_172_156(void)
{
    /* MATLAB Function: '<S102>/PoolIirInit' */
    /* MATLAB Function: '<S102>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S99>/TOP'
     *  S-Function (TOP_MEX): '<S99>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S106>:1' */
    /* '<S106>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S104>:1' */
    /*  Extract configuration information from inputs */
    /* '<S104>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S104>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S104>:1:24' VariantStr = char(VariantUint8); */
    /* '<S104>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S104>:1:28' else */
    /* '<S104>:1:29' switch(VariantStr) */
    /* '<S104>:1:30' case{"Hexagon"} */
    /* '<S104>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S104>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S104>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearHrEqFr28288states[0], &Model_Target_B.audioOut_m[0], 32U,
                 4U, &(Model_Target_Near0.Fr_PoolIirTunablePooliirNumStages[0]),
                 &(Model_Target_Near0.Fr_PoolIirTunablepooliirCoeffs[0]),
                 &NearHrEqFr28288states[0], 817U, 0U, 400U);

    /* '<S104>:1:34' states(1) = y; */
}

/*
 * System initialize for atomic system:
 *    '<S31>/MATLAB Function'
 *    '<S31>/MATLAB Function1'
 *    '<S31>/MATLAB Function2'
 *    '<S31>/MATLAB Function3'
 *    '<S31>/MATLAB Function4'
 *    '<S31>/MATLAB Function5'
 *    '<S31>/MATLAB Function6'
 *    '<S31>/MATLAB Function7'
 */
void Model_Target_MATLABFunction_e_Init(DW_MATLABFunction_Model_Target_n_T
    *localDW)
{
    /* '<S121>:1:7' , */
    /* '<S121>:1:7' lastG = cast(0, class(tgain)); */
    /* '<S121>:1:10' , */
    /* '<S121>:1:10' upCoeff = cast(0, class(tgain)); */
    /* '<S121>:1:12' , */
    /* '<S121>:1:12' upCoeffN = cast(0, class(tgain)); */
    /* '<S121>:1:14' , */
    /* '<S121>:1:14' downCoeff = cast(0, class(tgain)); */
    /* '<S121>:1:16' , */
    /* '<S121>:1:16' downCoeffN = cast(0, class(tgain)); */
    /* '<S121>:1:22' , */
    /* '<S121>:1:22' lpfCoeff = cast(exp(-1 / FRAME_SIZE), class(tgain)); */
    localDW->lpfCoeff = 0.969233215F;
}

/*
 * Output and update for atomic system:
 *    '<S31>/MATLAB Function'
 *    '<S31>/MATLAB Function1'
 *    '<S31>/MATLAB Function2'
 *    '<S31>/MATLAB Function3'
 *    '<S31>/MATLAB Function4'
 *    '<S31>/MATLAB Function5'
 *    '<S31>/MATLAB Function6'
 *    '<S31>/MATLAB Function7'
 */
void Model_Target_MATLABFunction_n(real32_T rtu_tgain, real32_T
    rtu_ramp_db_per_samp, real_T rtu_minGain, real32_T *rty_gval,
    DW_MATLABFunction_Model_Target_n_T *localDW)
{
    int32_T i;
    real32_T gVec[32];
    real32_T gdiff;
    real32_T gp;
    real32_T nextDownCoeff;
    real32_T nextUpCoeff;
    boolean_T chtgain;

    /*  FRAME_SIZE = 32; */
    /*  Ramp coefficients */
    /* MATLAB Function 'NEAR/Near1p1/LocRamper/MATLAB Function': '<S121>:1' */
    /* '<S121>:1:5' if (isempty(lastTGain)) */
    if (!localDW->lastTGain_not_empty)
    {
        /* '<S121>:1:5' , */
        /* '<S121>:1:5' lastTGain = cast(tgain + 1, class(tgain)); */
        localDW->lastTGain = rtu_tgain + 1.0F;
        localDW->lastTGain_not_empty = true;
    }

    /* '<S121>:1:7' if (isempty(lastG)) */
    /*  Ramp coefficients */
    /* '<S121>:1:10' if (isempty(upCoeff)) */
    /* '<S121>:1:12' if (isempty(upCoeffN)) */
    /* '<S121>:1:14' if (isempty(downCoeff)) */
    /* '<S121>:1:16' if (isempty(downCoeffN)) */
    /* '<S121>:1:22' if (isempty(lpfCoeff)) */
    /*  Update the next set of ramp coefficients to use */
    /* '<S121>:1:24' nextUpCoeff = cast(10 ^ abs(ramp_db_per_samp / 20), class(tgain)); */
    nextUpCoeff = qhmath_pow_f(10.0F, qhmath_abs_f(qhmath_div_f
        (rtu_ramp_db_per_samp, 20.0F)));

    /* '<S121>:1:25' nextUpCoeffN = cast(nextUpCoeff ^ FRAME_SIZE, class(tgain)); */
    /* '<S121>:1:26' nextDownCoeff = cast(10 ^ (-abs(ramp_db_per_samp) / 20), class(tgain)); */
    nextDownCoeff = qhmath_pow_f(10.0F, qhmath_div_f(-qhmath_abs_f
        (rtu_ramp_db_per_samp), 20.0F));

    /* '<S121>:1:27' nextDownCoeffN = cast(nextDownCoeff ^ FRAME_SIZE, class(tgain)); */
    /*  Switch to the next set of ramp coefficients if the target gain changed */
    /* '<S121>:1:29' chtgain = (tgain ~= lastTGain); */
    chtgain = (rtu_tgain != localDW->lastTGain);

    /* '<S121>:1:30' lastTGain = tgain; */
    localDW->lastTGain = rtu_tgain;

    /* '<S121>:1:31' if (chtgain) */
    if (chtgain)
    {
        /* '<S121>:1:32' upCoeff = nextUpCoeff; */
        localDW->upCoeff = nextUpCoeff;

        /* '<S121>:1:33' upCoeffN = nextUpCoeffN; */
        localDW->upCoeffN = qhmath_pow_f(nextUpCoeff, 32.0F);

        /* '<S121>:1:34' downCoeff = nextDownCoeff; */
        localDW->downCoeff = nextDownCoeff;

        /* '<S121>:1:35' downCoeffN = nextDownCoeffN; */
        localDW->downCoeffN = qhmath_pow_f(nextDownCoeff, 32.0F);
    }

    /*  Initialize output */
    /* '<S121>:1:38' gp = lastG; */
    gp = localDW->lastG;

    /* '<S121>:1:39' gdiff = tgain - gp; */
    gdiff = rtu_tgain - localDW->lastG;

    /*  By default, use the lpf filter */
    /* '<S121>:1:41' a = lpfCoeff; */
    nextUpCoeff = localDW->lpfCoeff;

    /* '<S121>:1:42' b0 = 1-a; */
    nextDownCoeff = 1.0F - localDW->lpfCoeff;

    /* '<S121>:1:44' if (abs(gdiff) < minGain) */
    if (qhmath_abs_f(gdiff) < rtu_minGain)
    {
        /*  Snap to target gain if it's close enough */
        /* '<S121>:1:46' gVec = tgain * ones(FRAME_SIZE, 1, class(tgain)); */
        for (i = 0; i < 32; i++)
        {
            gVec[i] = rtu_tgain;
        }
    }
    else
    {
        /* '<S121>:1:47' else */
        /* '<S121>:1:48' if (gdiff > 0) */
        if (gdiff > 0.0F)
        {
            /*  previous gain cannot be zero for exponential ramp */
            /* '<S121>:1:50' temp = max(gp, minGain); */
            gdiff = fmaxf(localDW->lastG, (real32_T)rtu_minGain);

            /* '<S121>:1:51' if (temp * upCoeffN < tgain) */
            if (gdiff * localDW->upCoeffN < rtu_tgain)
            {
                /*  Ramp not done, so do zero-input exponential ramp */
                /* '<S121>:1:53' a = upCoeff; */
                nextUpCoeff = localDW->upCoeff;

                /* '<S121>:1:54' b0 = cast(0, class(tgain)); */
                nextDownCoeff = 0.0F;

                /* '<S121>:1:55' gp = temp; */
                gp = gdiff;
            }

            /* '<S121>:1:57' else */
            /* '<S121>:1:58' if (gp * downCoeffN > tgain) */
        }
        else if (localDW->lastG * localDW->downCoeffN > rtu_tgain)
        {
            /*  Ramp not done, so do zero-input exponential ramp */
            /* '<S121>:1:60' a = downCoeff; */
            nextUpCoeff = localDW->downCoeff;

            /* '<S121>:1:61' b0 = cast(0, class(tgain)); */
            nextDownCoeff = 0.0F;
        }

        /*  Calculate gain */
        /* '<S121>:1:65' zi = a * gp; */
        gp *= nextUpCoeff;

        /* '<S121>:1:66' gVec = zeros(FRAME_SIZE, 1, class(tgain)); */
        /* '<S121>:1:67' for samp = 1:FRAME_SIZE */
        for (i = 0; i < 32; i++)
        {
            /* '<S121>:1:68' g = b0 * tgain + zi; */
            gdiff = nextDownCoeff * rtu_tgain + gp;

            /* '<S121>:1:69' zi = a * g; */
            gp = nextUpCoeff * gdiff;

            /* '<S121>:1:70' gVec(samp) = g; */
            gVec[i] = gdiff;
        }
    }

    /* '<S121>:1:73' lastG = gVec(end); */
    localDW->lastG = gVec[31];

    /* '<S121>:1:74' gval = lastG; */
    *rty_gval = localDW->lastG;
}

/* Output and update for function-call system: '<S166>/init' */
void InitTrigger_Model_787_143_65(void)
{
    /* MATLAB Function: '<S163>/FirEvenInit' */
    /* MATLAB Function: '<S163>/FirEvenInit' incorporates:
     *  Constant: '<S158>/Image Rejection Filter Coeffs'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S167>:1' */
    /* '<S167>:1:3' init(); */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenInit': '<S164>:1' */
    /* '<S164>:1:4' [FilterLength, NumFilters] = size(FlippedCoefficients); */
    /* '<S164>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Simulation */
    /* '<S164>:1:10' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S164>:1:12' else */
    /* '<S164>:1:13' y = fireven_hexagon_init(uint32(FrameSize), uint32(NumChannels), uint32(NumFilters), uint32(FilterLength), single(FlippedCoefficients), uint32(CodeWorkMemory), uint32(MaxNumOfThreds)); */
    fireven_init(&NearBandSplitCodeWorkMemory[0], 32U, 2U, 1U, 22U,
                 &Model_Target_ConstP.ImageRejectionFilterCoeffs_Value[0],
                 &NearBandSplitCodeWorkMemory[0], 4U);

    /*  NOTE: The CRL mechanism requires an output for the function call, */
    /*  and appears to be optimized out if that return value isn't used.  */
    /*  This is a dummy operation to make sure CRL ends up in generated code */
    /* '<S164>:1:17' CodeWorkMemory(1) = y; */
}

/*
 * Output and update for function-call system:
 *    '<S194>/Reset'
 *    '<S1110>/Reset'
 */
void Model_Target_Reset(real32_T rtd_states_on[4])
{
    /*  Reset the states DSM to zeros */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/Reset': '<S196>:1' */
    /* '<S196>:1:6' states(:) = 0; */
    rtd_states_on[0] = 0.0F;
    rtd_states_on[1] = 0.0F;
    rtd_states_on[2] = 0.0F;
    rtd_states_on[3] = 0.0F;
}

/*
 * Output and update for atomic system:
 *    '<S194>/PoolIirProcess'
 *    '<S1110>/PoolIirProcess'
 */
void Model_Target_PoolIirProcess(const real32_T rtu_x[64], const uint32_T
    rtu_numStages[2], const real32_T rtu_coeffs[10], real32_T rtd_states_on[4],
    B_PoolIirProcess_Model_Target_T *localB)
{
    real_T coeffIdx;
    real_T stateIdx;
    int32_T cha;
    int32_T i;
    uint32_T st;

    /*  Extract configuration information from inputs */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/PoolIirProcess': '<S195>:1' */
    /* '<S195>:1:5' [frame_size, num_channels] = size(x); */
    /*  Initialize variables */
    /*  Typecast the variables */
    /* '<S195>:1:11' frame_size = uint32(frame_size); */
    /* '<S195>:1:12' num_channels = uint32(num_channels); */
    /* Compute the filter coefficients */
    /* '<S195>:1:15' y = pooliir(x, frame_size, num_channels, numStages, coeffs, states); */
    /*  We have to use a different state buffer than the one passed in.  Matlab */
    /*  value objects are passed by value, not by reference, so the saving of */
    /*  states here does not work.  The state buffer is still necessary to pass */
    /*  allocate in the calling function and pass here in order to trigger CRL. */
    /*  This double buffering is annoying, however only happens during */
    /*  simulation, not code generation. */
    /*  num_states = (length(coeffs) - numChannels) / 2; */
    /*  persistent states; */
    /*  if isempty(states) */
    /*      states = single(zeros(1, num_states)); */
    /*  end */
    /* 'pooliir:15' stateIdx = 1; */
    stateIdx = 1.0;

    /* 'pooliir:16' coeffIdx = 1; */
    coeffIdx = 1.0;

    /* 'pooliir:18' frameMinus1  = frameSize-1; */
    /*  number of samples minus one */
    /* 'pooliir:19' y     = coder.nullcopy(x); */
    /*  output matrix */
    /*  OUTER LOOP over all channels                  */
    /* 'pooliir:22' for cha = 1:numChannels */
    for (cha = 0; cha < 2; cha++)
    {
        real_T stateIdx_0;
        int32_T xx_tmp;
        real32_T a2;
        real32_T gain_tmp;
        real32_T q;
        real32_T w1;
        real32_T w1_tmp;
        real32_T w2;
        real32_T xx;
        real32_T yy;
        uint32_T b;

        /*  FIRST STAGE */
        /*  prologue: get coefficients, states and input vector  */
        /*  and perform some computations */
        /* 'pooliir:28' w1 = states(stateIdx); */
        w1 = rtd_states_on[(int32_T)stateIdx - 1];

        /* 'pooliir:28' stateIdx = stateIdx+1; */
        stateIdx_0 = stateIdx + 1.0;

        /* 'pooliir:29' gain = coeffs(coeffIdx); */
        gain_tmp = rtu_coeffs[(int32_T)coeffIdx - 1];

        /* 'pooliir:29' coeffIdx = coeffIdx+1; */
        /* 'pooliir:30' w2 = states(stateIdx); */
        w2 = rtd_states_on[(int32_T)(stateIdx + 1.0) - 1];

        /* 'pooliir:30' stateIdx = stateIdx-1; */
        stateIdx = (stateIdx + 1.0) - 1.0;

        /* 'pooliir:31' a2   = coeffs(coeffIdx); */
        a2 = rtu_coeffs[(int32_T)(coeffIdx + 1.0) - 1];

        /* 'pooliir:31' coeffIdx = coeffIdx+1; */
        /* 'pooliir:32' xx  = x(1,cha); */
        /* 'pooliir:32' a1   = coeffs(coeffIdx); */
        /* 'pooliir:32' coeffIdx = coeffIdx+1; */
        /* 'pooliir:33' xx  = xx*gain; */
        xx_tmp = cha << 5;
        xx = rtu_x[xx_tmp] * gain_tmp;

        /* 'pooliir:33' b2   = coeffs(coeffIdx); */
        /* 'pooliir:33' coeffIdx = coeffIdx+1; */
        /* 'pooliir:34' yy  = w1+xx; */
        yy = w1 + xx;

        /* 'pooliir:34' b1   = coeffs(coeffIdx); */
        /* 'pooliir:34' coeffIdx = coeffIdx+1; */
        /* 'pooliir:35' w1  = b1*xx; */
        w1_tmp = rtu_coeffs[(int32_T)((((coeffIdx + 1.0) + 1.0) + 1.0) + 1.0) -
            1];
        w1 = w1_tmp * xx;

        /*  main loop: 5 ops/sample */
        /* 'pooliir:38' i = 1; */
        /* 'pooliir:39' while i <= frameMinus1 */
        for (i = 0; i < 31; i++)
        {
            int32_T y_tmp;

            /* 'pooliir:40' r  = a1*yy; */
            /* 'pooliir:40' w1 = w1+w2; */
            w1 += w2;

            /* 'pooliir:40' y(i,cha) = yy; */
            y_tmp = i + xx_tmp;
            localB->y[y_tmp] = yy;

            /* 'pooliir:41' q  = b2*xx; */
            q = rtu_coeffs[(int32_T)(((coeffIdx + 1.0) + 1.0) + 1.0) - 1] * xx;

            /* 'pooliir:41' w1 = w1-r; */
            /* 'pooliir:41' xx = x(i+1,cha); */
            /* 'pooliir:42' xx = xx*gain; */
            xx = rtu_x[y_tmp + 1] * gain_tmp;

            /* 'pooliir:43' w2 = a2*yy; */
            w2 = a2 * yy;

            /* 'pooliir:43' yy = w1+xx; */
            yy = (w1 - rtu_coeffs[(int32_T)((coeffIdx + 1.0) + 1.0) - 1] * yy) +
                xx;

            /* 'pooliir:44' w1 = b1*xx; */
            w1 = w1_tmp * xx;

            /* 'pooliir:44' w2 = q-w2; */
            w2 = q - w2;

            /* 'pooliir:44' i = i + 1; */
        }

        /*  epilogue: drain pipe and write states */
        /* 'pooliir:48' r  = a1*yy; */
        /* 'pooliir:48' w1 = w1+w2; */
        /* 'pooliir:48' y(frameMinus1+1,cha) = yy; */
        localB->y[xx_tmp + 31] = yy;

        /* 'pooliir:49' q  = b2*xx; */
        /* 'pooliir:49' w1 = w1-r; */
        rtd_states_on[(int32_T)(stateIdx_0 - 1.0) - 1] = (w1 + w2) - rtu_coeffs
            [(int32_T)((coeffIdx + 1.0) + 1.0) - 1] * yy;

        /* 'pooliir:50' w2 = a2*yy; */
        /* 'pooliir:50' states(stateIdx) = w1; */
        /* 'pooliir:50' stateIdx = stateIdx+1; */
        /* 'pooliir:51' w2 = q-w2; */
        rtd_states_on[(int32_T)(stateIdx + 1.0) - 1] = rtu_coeffs[(int32_T)
            (((coeffIdx + 1.0) + 1.0) + 1.0) - 1] * xx - a2 * yy;

        /* 'pooliir:51' states(stateIdx) = w2; */
        /* 'pooliir:51' stateIdx = stateIdx+1; */
        stateIdx = (stateIdx + 1.0) + 1.0;

        /*  NOTE: asm implementation needs to exit here if it's only */
        /*  one stage, NOTE: all subsequent stages work in-place */
        /* 'pooliir:55' for st = 2:numStages(cha) */
        b = rtu_numStages[cha];
        for (st = 2U; st <= b; st++)
        {
            real_T a2_tmp;

            /*  prologue: get coefficients, states and input vector,  */
            /*  and perform some computations */
            /* 'pooliir:58' w1 = states(stateIdx); */
            w1 = rtd_states_on[(int32_T)stateIdx - 1];

            /* 'pooliir:58' stateIdx = stateIdx+1; */
            stateIdx_0 = stateIdx + 1.0;

            /* 'pooliir:59' a2 = coeffs(coeffIdx); */
            a2_tmp = (((((coeffIdx + 1.0) + 1.0) + 1.0) + 1.0) + 1.0) + ((real_T)
                st - 2.0) * 4.0;
            a2 = rtu_coeffs[(int32_T)a2_tmp - 1];

            /* 'pooliir:59' coeffIdx = coeffIdx+1; */
            /* 'pooliir:60' w2 = states(stateIdx); */
            w2 = rtd_states_on[(int32_T)(stateIdx + 1.0) - 1];

            /* 'pooliir:60' stateIdx = stateIdx-1; */
            stateIdx = (stateIdx + 1.0) - 1.0;

            /* 'pooliir:61' a1 = coeffs(coeffIdx); */
            gain_tmp = rtu_coeffs[(int32_T)(a2_tmp + 1.0) - 1];

            /* 'pooliir:61' coeffIdx = coeffIdx+1; */
            /* 'pooliir:62' xx = y(1,cha); */
            xx = localB->y[xx_tmp];

            /* 'pooliir:62' b2 = coeffs(coeffIdx); */
            /* 'pooliir:62' coeffIdx = coeffIdx+1; */
            /* 'pooliir:63' yy = w1+xx; */
            yy = xx + w1;

            /* 'pooliir:63' b1 = coeffs(coeffIdx); */
            /* 'pooliir:63' coeffIdx = coeffIdx+1; */
            /* 'pooliir:64' w1 = b1*xx; */
            w1_tmp = rtu_coeffs[(int32_T)(((a2_tmp + 1.0) + 1.0) + 1.0) - 1];
            w1 = w1_tmp * xx;

            /*  main loop: 4 ops/sample */
            /* 'pooliir:67' i = 1; */
            /* 'pooliir:68' while i <= frameMinus1 */
            for (i = 0; i < 31; i++)
            {
                /* 'pooliir:69' r  = a1*yy; */
                /* 'pooliir:69' w1 = w1+w2; */
                w1 += w2;

                /* 'pooliir:69' y(i,cha) = yy; */
                localB->y[i + (cha << 5)] = yy;

                /* 'pooliir:70' q  = b2*xx; */
                q = rtu_coeffs[(int32_T)((a2_tmp + 1.0) + 1.0) - 1] * xx;

                /* 'pooliir:70' w1 = w1-r ; */
                /* 'pooliir:70' xx = y(i+1,cha); */
                xx = localB->y[((cha << 5) + i) + 1];

                /* 'pooliir:71' w2 = a2*yy; */
                w2 = a2 * yy;

                /* 'pooliir:71' yy = w1+xx; */
                yy = (w1 - gain_tmp * yy) + xx;

                /* 'pooliir:72' w1 = b1*xx; */
                w1 = xx * w1_tmp;

                /* 'pooliir:72' w2 = q-w2; */
                w2 = q - w2;

                /* 'pooliir:72' i = i + 1; */
            }

            /*  epilogue: drain pipe and write states */
            /* 'pooliir:76' r  = a1*yy; */
            /* 'pooliir:76' w1 = w1+w2; */
            /* 'pooliir:76' y(frameMinus1+1,cha) = yy; */
            localB->y[xx_tmp + 31] = yy;

            /* 'pooliir:77' q  = b2*xx; */
            /* 'pooliir:77' w1 = w1-r; */
            rtd_states_on[(int32_T)(stateIdx_0 - 1.0) - 1] = (w1 + w2) -
                gain_tmp * yy;

            /* 'pooliir:78' w2 = a2*yy; */
            /* 'pooliir:78' states(stateIdx) = w1; */
            /* 'pooliir:78' stateIdx = stateIdx+1; */
            /* 'pooliir:79' w2 = q-w2; */
            rtd_states_on[(int32_T)(stateIdx + 1.0) - 1] = rtu_coeffs[(int32_T)
                ((a2_tmp + 1.0) + 1.0) - 1] * xx - a2 * yy;

            /* 'pooliir:79' states(stateIdx) = w2; */
            /* 'pooliir:79' stateIdx = stateIdx+1; */
            stateIdx = (stateIdx + 1.0) + 1.0;
        }

        coeffIdx = (((((coeffIdx + 1.0) + 1.0) + 1.0) + 1.0) + 1.0) + (((real_T)
            b - 2.0) + 1.0) * 4.0;
    }
}

/*
 * System initialize for atomic system:
 *    '<S197>/InnerLink'
 *    '<S205>/InnerLink'
 *    '<S213>/InnerLink'
 *    '<S221>/InnerLink'
 */
void Model_Target_InnerLink_Init(DW_InnerLink_Model_Target_T *localDW)
{
    localDW->holdFlag = 1.0;
}

/*
 * Output and update for atomic system:
 *    '<S197>/InnerLink'
 *    '<S205>/InnerLink'
 *    '<S213>/InnerLink'
 *    '<S221>/InnerLink'
 */
void Model_Target_InnerLink(real32_T rtu_rmsInput, real32_T rtu_peakInput,
    real32_T rtu_slowDecayDbPerSample, real32_T rtu_holdMarginDb, real32_T
    rtu_holdTimeSamples, real32_T rtu_fastDecayDbPerSample, real32_T
    rtu_minVolumeDb, real32_T rtu_maxVolumeDb, real_T rtu_AnnTrigger, real32_T
    rtu_mode1, DW_InnerLink_Model_Target_T *localDW)
{
    real32_T input1;
    input1 = rtu_rmsInput;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'LevelDetector': '<S204>:1' */
    /*  States */
    /* '<S204>:1:11' if (isempty(holdFlag)) */
    if (!localDW->holdFlag_not_empty)
    {
        /* '<S204>:1:12' holdFlag = 1; */
        localDW->holdFlag_not_empty = true;

        /* '<S204>:1:13' holdState = 0; */
        /* '<S204>:1:14' envelope1 = -abs(minVolumeDb); */
        localDW->envelope1 = -qhmath_abs_f(rtu_minVolumeDb);
    }

    /*  By default we use the RMS input */
    /* '<S204>:1:18' input1 = rmsInput; */
    /* '<S204>:1:19' level = single(0.0); */
    /* '<S204>:1:21' if mode1 >= 0.0 */
    if (rtu_mode1 >= 0.0F)
    {
        real32_T delta;

        /*  Choose input1 based on mode1 */
        /* '<S204>:1:23' if (mode1 > 0.0) */
        if (rtu_mode1 > 0.0F)
        {
            /* '<S204>:1:24' input1 = peakInput; */
            input1 = rtu_peakInput;
        }

        /* '<S204>:1:26' delta = single( envelope1 - input1 ); */
        delta = localDW->envelope1 - input1;

        /* '<S204>:1:27' if ( delta <= single(0) ) */
        if (delta <= 0.0F)
        {
            /*  Attack phase */
            /* '<S204>:1:29' envelope1 = input1; */
            localDW->envelope1 = input1;

            /* '<S204>:1:30' holdState = 0; */
            localDW->holdState = 0.0;

            /* '<S204>:1:31' holdFlag = 1; */
            localDW->holdFlag = 1.0;
        }
        else
        {
            /* '<S204>:1:32' else */
            /*  Slow Decay phase */
            /* '<S204>:1:34' coef = slowDecayDbPerSample; */
            input1 = rtu_slowDecayDbPerSample;

            /*  Hold phase */
            /* '<S204>:1:37' if ( delta >= holdMarginDb ) */
            if (delta >= rtu_holdMarginDb)
            {
                /* '<S204>:1:38' holdState = holdState + 1; */
                localDW->holdState++;

                /* '<S204>:1:39' if ( holdState > holdTimeSamples ) */
                if (localDW->holdState > rtu_holdTimeSamples)
                {
                    /* '<S204>:1:40' holdFlag = 0; */
                    localDW->holdFlag = 0.0;
                }
            }
            else
            {
                /* '<S204>:1:42' else */
                /* '<S204>:1:43' holdState = 0; */
                localDW->holdState = 0.0;
            }

            /*  Fast decay phase */
            /* '<S204>:1:47' if holdFlag == 0 */
            if (localDW->holdFlag == 0.0)
            {
                /* '<S204>:1:48' coef = fastDecayDbPerSample; */
                input1 = rtu_fastDecayDbPerSample;
            }

            /*  Super fast decay phase */
            /* '<S204>:1:52' if ( AnnTrigger > AnnTriggerThreshold ) */
            if (rtu_AnnTrigger > 0.5)
            {
                /* '<S204>:1:53' coef = SuperFastDecayMultiplier * fastDecayDbPerSample; */
                input1 = Model_Target_SuperFastDecayMultiplier *
                    rtu_fastDecayDbPerSample;
            }

            /*  Update the envelope1 */
            /* '<S204>:1:57' envelope1 = envelope1 + coef; */
            localDW->envelope1 += input1;
        }

        /*  Boundary Check */
        /* '<S204>:1:60' envelope1 = max(minVolumeDb, envelope1); */
        localDW->envelope1 = fmaxf(rtu_minVolumeDb, localDW->envelope1);

        /* '<S204>:1:61' envelope1 = min(maxVolumeDb, envelope1); */
        localDW->envelope1 = fminf(rtu_maxVolumeDb, localDW->envelope1);

        /*  dBSPL Conversion */
        /* '<S204>:1:64' level = max(0, envelope1 + predictionDbspl + volumeDb); */
    }
}

/*
 * Output and update for function-call system:
 *    '<S235>/MATLAB Function'
 *    '<S315>/MATLAB Function'
 *    '<S395>/MATLAB Function'
 *    '<S475>/MATLAB Function'
 */
void Model_Target_MATLABFunction_i(uint32_T rtu_vncEnableIn,
    B_MATLABFunction_Model_Target_a_T *localB)
{
    localB->vncEnableOut = rtu_vncEnableIn;

    /*  */
    /* Trivial translation */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Ann1NonEntGainCalc/MATLAB Function': '<S239>:1' */
    /* '<S239>:1:5' vncEnableOut = vncEnableIn; */
}

/* Output and update for function-call system: '<S240>/REQ' */
void HandleReqNearAnn1Ann1NonEntGainCalcvncEnableRTC(void)
{
    /* MATLAB Function: '<S235>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S256>:1' */
    /* '<S256>:1:3' go(); */
    Model_Target_MATLABFunction_i
        (Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable,
         &Model_Target_B.sf_MATLABFunction_iu);
}

/* Output and update for function-call system: '<S269>/REQ' */
void HandleReqNearAnn1Ann1MuteSet(void)
{
    real32_T quantum_ms;
    real32_T x;

    /* MATLAB Function: '<S267>/calculate_ramp_rate' */
    /* MATLAB Function: '<S267>/calculate_ramp_rate' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S276>:1' */
    /* '<S276>:1:3' go(); */
    Model_Target_calculate_ramp_rate
        (Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_Near0.Ann1Ann1MuteRampTime,
         &Model_Target_B.sf_calculate_ramp_rate);

    /* MATLAB Function: '<S268>/get_ramp_coeffs' */
    /* MATLAB Function: '<S268>/get_ramp_coeffs' incorporates:
     *  DataStoreRead: '<S268>/Data Store Read'
     *  S-Function (AudioStats_MEX): '<S268>/Audio Stats'
     */
    x = Model_Target_B.sf_calculate_ramp_rate.ramptime;

    /* MATLAB Function 'MuteRamper/get_ramp_coeffs': '<S281>:1' */
    /* '<S281>:1:5' targetLinearGain = single(1.0); */
    Model_TargetControlDsms.NearAnn1MuteTargetLinearGain = 1.0F;

    /* '<S281>:1:7' if muteSwitch */
    if (Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_mute_switch != 0U)
    {
        /* '<S281>:1:8' targetLinearGain = single(max(0, silentGainLinear)); */
        Model_TargetControlDsms.NearAnn1MuteTargetLinearGain = 4.7315126E-7F;
    }

    /*  % Nudge the gain values a bit if they are sitting at zero. */
    /*  % If current gain is zero, replace with a value very close to zero. What we */
    /*  % really want is a value which is on the edge of perception - not too small */
    /*  % or large. If the value is too small, we'll waste some of our ramp time */
    /*  % in perceived silence. If the value is too large, the audio will lurch */
    /*  % into perceptability at the start of the ramp. */
    /*  % So, 'max(currentGainValue, silentGainLinear)' & 'max(TargetGain, silentGainLinear)' are */
    /*  % used in equations */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Equivalent ramp rate is therefore calculated as follows: */
    /* '<S281>:1:24' if (rampingRate_dBPerSec) */
    if (Model_Target_B.sf_calculate_ramp_rate.rampRate != 0.0F)
    {
        /* '<S281>:1:25' currentGain_db = 20*log10(max(currentGainValue, silentGainLinear)); */
        /* '<S281>:1:26' targetGain_db = 20*log10( targetLinearGain); */
        /* '<S281>:1:27' diff = abs(currentGain_db - targetGain_db); */
        /* '<S281>:1:28' rampingTime_ms = diff / single(rampingRate_dBPerSec) * 1000; */
        x = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f(fmaxf
                           (Model_TargetControlDsms.NearAnn1MuteCurrentGain,
                            4.7315126E-7F)) - 20.0F * qhmath_log10_f
                          (Model_TargetControlDsms.NearAnn1MuteTargetLinearGain)),
                         Model_Target_B.sf_calculate_ramp_rate.rampRate) *
            1000.0F;
    }

    /* '<S281>:1:31' quantum_ms = 1000 * frameSize / Fs_Hz; */
    quantum_ms = qhmath_div_f(32000.0F, 44307.692307692312);

    /* '<S281>:1:32' numFrames = rampingTime_ms / quantum_ms; */
    /*  Do a ceil rather than a round to insure that we create enough */
    /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
    /* '<S281>:1:35' nFrames = max (1, ceil(numFrames)); */
    Model_TargetControlDsms.NearAnn1MuteNframes = fmaxf(1.0F, qhmath_ceil_f
        (qhmath_div_f(x, quantum_ms)));

    /* '<S281>:1:36' quantized_rampTime_ms = nFrames * quantum_ms; */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S281>:1:50' ramping_coeff= exp(log( targetLinearGain /max(currentGainValue, silentGainLinear) ) / (Fs_Hz * quantized_rampTime_ms / 1000)); */
    Model_Target_B.ramping_coeff_h = qhmath_div_f(qhmath_log_f(qhmath_div_f
        (Model_TargetControlDsms.NearAnn1MuteTargetLinearGain, fmaxf
         (Model_TargetControlDsms.NearAnn1MuteCurrentGain, 4.7315126E-7F))),
        qhmath_div_f(Model_TargetControlDsms.NearAnn1MuteNframes * quantum_ms *
                     44307.692307692312, 1000.0F));
    Model_Target_B.ramping_coeff_h = qhmath_exp_f(Model_Target_B.ramping_coeff_h);

    /* End of MATLAB Function: '<S268>/get_ramp_coeffs' */
}

/*
 * Output and update for iterator system:
 *    '<S283>/For Each Subsystem'
 *    '<S363>/For Each Subsystem'
 *    '<S443>/For Each Subsystem'
 *    '<S523>/For Each Subsystem'
 */
void Model_Target_ForEachSubsystem(int32_T NumIters, const real32_T rtu_In1[32],
    const real32_T rtu_In2[32], real32_T rty_Out1[32])
{
    /* local scratch DWork variables */
    int32_T ForEach_itr;

    /* Outputs for Iterator SubSystem: '<S283>/For Each Subsystem' incorporates:
     *  ForEach: '<S290>/For Each'
     */
    for (ForEach_itr = 0; ForEach_itr < NumIters; ForEach_itr++)
    {
        /* ForEachSliceAssignment generated from: '<S290>/Out1' incorporates:
         *  ForEachSliceSelector generated from: '<S290>/In1'
         *  ForEachSliceSelector generated from: '<S290>/In2'
         *  Product: '<S290>/Multiply'
         */
        rty_Out1[ForEach_itr] = rtu_In1[ForEach_itr] * rtu_In2[ForEach_itr];
    }

    /* End of Outputs for SubSystem: '<S283>/For Each Subsystem' */
}

/*
 * Output and update for function-call system:
 *    '<S238>/rtcscalartovector'
 *    '<S318>/rtcscalartovector'
 *    '<S398>/rtcscalartovector'
 *    '<S478>/rtcscalartovector'
 */
void Model_Target_rtcscalartovector(uint32_T rtu_Inp,
    B_rtcscalartovector_Model_Target_T *localB)
{
    /*  */
    /*  Convert input vector into a matrix */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/rtcscalartovector': '<S298>:1' */
    /* '<S298>:1:6' Inpsize=size(Inp,1); */
    /* '<S298>:1:8' Outp=(Inp').*uint32(ones(1,Inpsize)); */
    localB->Outp = rtu_Inp;
}

/*
 * Output and update for function-call system:
 *    '<S238>/calculate_vol_gain'
 *    '<S318>/calculate_vol_gain'
 *    '<S398>/calculate_vol_gain'
 *    '<S478>/calculate_vol_gain'
 */
void Model_Target_calculate_vol_gain(uint32_T rtu_idx, const uint32_T
    rtu_volTableIdx[16], const real32_T rtu_volTabledB[16],
    B_calculate_vol_gain_Model_Target_T *localB)
{
    uint32_T idx;
    uint8_T j;
    boolean_T exitg1;
    idx = rtu_idx;

    /*  Calculate a gain_value from VolumeTable, table index, and index table */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/calculate_vol_gain': '<S296>:1' */
    /* '<S296>:1:5' iter=size(idx,2); */
    /* gain_value = single(0.0); */
    /* '<S296>:1:7' gain_value=single(zeros(1,iter)); */
    localB->gain_value = 0.0F;

    /* '<S296>:1:8' percent =zeros(1,iter); */
    /* '<S296>:1:9' lastIdx =zeros(1,iter); */
    /* '<S296>:1:11' for chind=1:iter */
    /* '<S296>:1:12' j = uint8(1); */
    j = 1U;

    /*  workaround to type problem */
    /* '<S296>:1:14' idx(chind) = cast(idx(chind), class(volTableIdx(end))); */
    /*   bounds checking for vol - clip to max idx */
    /* '<S296>:1:17' if (idx(chind) > volTableIdx(end)) */
    if (rtu_idx > rtu_volTableIdx[15])
    {
        /* '<S296>:1:18' idx(chind) = volTableIdx(end); */
        idx = rtu_volTableIdx[15];
    }

    /*  search through volume table to find index closest to vol */
    /* '<S296>:1:22' while (j <= numel(volTableIdx)) */
    exitg1 = false;
    while ((!exitg1) && (j <= 16))
    {
        uint32_T tmp_0;

        /* '<S296>:1:23' if (idx(chind) <= volTableIdx(j)) */
        tmp_0 = rtu_volTableIdx[j - 1];
        if (idx <= tmp_0)
        {
            /* '<S296>:1:24' if (j <= 1) */
            if (j <= 1)
            {
                real_T a;

                /*  first indexed value is linearly interpolated to zero */
                /* '<S296>:1:25' if (volTableIdx(j)) */
                if (rtu_volTableIdx[0] != 0U)
                {
                    /* '<S296>:1:26' percent(chind) = single(idx(chind)) / single(volTableIdx(j)); */
                    a = qhmath_div_f((real32_T)idx, (real32_T)rtu_volTableIdx[0]);
                }
                else
                {
                    /* '<S296>:1:27' else */
                    /* '<S296>:1:28' percent(chind) = single(1); */
                    a = 1.0;
                }

                /* '<S296>:1:30' gain_value(chind) = percent(chind) * 10 ^ (volTabledB(j) / 20); */
                localB->gain_value = (real32_T)a * qhmath_pow_f(10.0F,
                    qhmath_div_f(rtu_volTabledB[0], 20.0F));
            }
            else
            {
                real_T a;
                real_T tmp;
                real32_T gain_value_tmp;

                /* '<S296>:1:31' else */
                /*  other values are interpolated in db space */
                /* '<S296>:1:32' lastIdx(chind) = volTableIdx(j-1); */
                /* '<S296>:1:33' percent(chind) = single(idx(chind) - lastIdx(chind)) / single(volTableIdx(j) - lastIdx(chind)); */
                /* '<S296>:1:34' gain_value(chind) = 10 ^ (((percent(chind) * (volTabledB(j) - volTabledB(j-1))) + volTabledB(j-1)) / 20); */
                a = rtu_volTableIdx[j - 2];
                tmp = (real_T)idx - a;
                a = (real_T)tmp_0 - a;
                if (tmp >= 0.0)
                {
                    tmp_0 = (uint32_T)tmp;
                }
                else
                {
                    tmp_0 = 0U;
                }

                if (a >= 0.0)
                {
                    idx = (uint32_T)a;
                }
                else
                {
                    idx = 0U;
                }

                gain_value_tmp = rtu_volTabledB[j - 2];
                localB->gain_value = qhmath_pow_f(10.0F, qhmath_div_f
                    ((rtu_volTabledB[j - 1] - gain_value_tmp) * qhmath_div_f
                     ((real32_T)tmp_0, (real32_T)idx) + gain_value_tmp, 20.0F));
            }

            exitg1 = true;
        }
        else
        {
            /* '<S296>:1:37' else */
            /* '<S296>:1:38' j = j + 1; */
            j++;
        }
    }
}

/*
 * Output and update for function-call system:
 *    '<S238>/rtcscalartovector2'
 *    '<S318>/rtcscalartovector2'
 *    '<S398>/rtcscalartovector2'
 *    '<S478>/rtcscalartovector2'
 */
void Model_Target_rtcscalartovector2(uint32_T rtu_Inp,
    B_rtcscalartovector2_Model_Target_T *localB)
{
    /*  */
    /*  Convert input vector into a matrix */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/rtcscalartovector2': '<S299>:1' */
    /* '<S299>:1:5' Inpsize=size(Inp,1); */
    /* '<S299>:1:7' Outp=(Inp').*uint32(ones(1,Inpsize)); */
    localB->Outp = rtu_Inp;
}

/*
 * Output and update for function-call system:
 *    '<S238>/rtcscalartovector3'
 *    '<S318>/rtcscalartovector3'
 *    '<S398>/rtcscalartovector3'
 *    '<S478>/rtcscalartovector3'
 */
void Model_Target_rtcscalartovector3(uint32_T rtu_Inp,
    B_rtcscalartovector3_Model_Target_T *localB)
{
    /*  */
    /*  Convert input vector into a matrix */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/rtcscalartovector3': '<S300>:1' */
    /* '<S300>:1:5' Inpsize=size(Inp,1); */
    /* '<S300>:1:7' Outp=(Inp').*uint32(ones(1,Inpsize)); */
    localB->Outp = rtu_Inp;
}

/*
 * Output and update for function-call system:
 *    '<S238>/get_ramp_parameters'
 *    '<S318>/get_ramp_parameters'
 *    '<S398>/get_ramp_parameters'
 *    '<S478>/get_ramp_parameters'
 */
void Model_Target_get_ramp_parameters(uint32_T rtu_rampTimeRTC, uint32_T
    rtu_rampRateRTC, real32_T rtu_rampTimeTune,
    B_get_ramp_parameters_Model_Target_T *localB)
{
    /*  % RTC message parameters */
    /*  Tune parameters */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/get_ramp_parameters': '<S297>:1' */
    /*  Ramp time and rate are provided to the block through RTC messages. However  */
    /*  in case neither of them are provided, the block will use the default ramp  */
    /*  time given in the tune variables. */
    /*  NOTE: Tune variable for ramp rate is provided as an option, but not used */
    /*  in the current version. */
    /* '<S297>:1:10' Numiters=size(rampTimeRTC,2); */
    /* '<S297>:1:11' ramp_ms=zeros(1,Numiters); */
    /* '<S297>:1:12' ramp_rate=zeros(1,Numiters); */
    /* '<S297>:1:14' ramp_ms(1:Numiters) = single(rampTimeTune); */
    localB->ramp_ms = rtu_rampTimeTune;

    /* '<S297>:1:15' ramp_rate(1:Numiters) = single(0.0); */
    localB->ramp_rate = 0.0;

    /*  Set to rampRateTune if a default is to be set */
    /* '<S297>:1:16' for rampind=1:Numiters */
    /* '<S297>:1:17' if (rampTimeRTC(rampind)) */
    if (rtu_rampTimeRTC != 0U)
    {
        /* '<S297>:1:18' ramp_ms(rampind) = single(rampTimeRTC(rampind)); */
        /* '<S297>:1:19' ramp_ms(rampind) = min(100000, ramp_ms(rampind)); */
        /* '<S297>:1:20' ramp_ms(rampind) = max(1, ramp_ms(rampind)); */
        localB->ramp_ms = fmin(100000.0, (real32_T)rtu_rampTimeRTC);
    }

    /* '<S297>:1:22' if (rampRateRTC(rampind)) */
    if (rtu_rampRateRTC != 0U)
    {
        /* '<S297>:1:23' ramp_rate(rampind) = single(rampRateRTC(rampind)); */
        /* '<S297>:1:24' ramp_rate(rampind) = min(50000, ramp_rate(rampind)); */
        /* '<S297>:1:25' ramp_rate(rampind) = max(5, ramp_rate(rampind)); */
        localB->ramp_rate = fmax(5.0, fmin(50000.0, (real32_T)rtu_rampRateRTC));
    }
}

/*
 * Output and update for function-call system:
 *    '<S308>/SetDsm'
 *    '<S308>/SetDsm1'
 */
void Model_Target_SetDsm(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S311>/Data Store Write' incorporates:
     *  Constant: '<S311>/Constant'
     */
    Model_TargetControlDsms.NearAnn1Ann1VolumeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S308>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol(real32_T rtu_target_gains_linear, real_T
    rtu_db_per_sec, real_T rtu_ramp_times_ms, real32_T rtu_sample_rate_in_hertz,
    real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S313>:1' */
    /* '<S313>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S313>:1:23' numGains = numel(target_gains_linear); */
    /* '<S313>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S313>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S313>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S313>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S313>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = (real32_T)rtu_ramp_times_ms;

        /* '<S313>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S313>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain,
             5.0118723E-7F);

        /* '<S313>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S313>:1:49' if (ramp_dbPerSec) */
        if ((real32_T)rtu_db_per_sec != 0.0F)
        {
            /* '<S313>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S313>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S313>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S313>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)), (real32_T)
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S313>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S313>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S313>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S313>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S313>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S313>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain,
                            currentGain)), qhmath_div_f(numFrames * quantum_ms *
                           rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S313>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.frameCount = (int32_T)
            numFrames;

        /* '<S313>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S313>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S313>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain =
            currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S291>/REQ' */
void HandleReqNearAnn1Ann1VolumeSet(void)
{
    /* MATLAB Function: '<S238>/rtcscalartovector' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S304>:1' */
    /* '<S304>:1:3' go(); */
    Model_Target_rtcscalartovector
        (Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_volume_index,
         &Model_Target_B.sf_rtcscalartovector);

    /* MATLAB Function: '<S238>/calculate_vol_gain' */
    Model_Target_calculate_vol_gain(Model_Target_B.sf_rtcscalartovector.Outp,
        &(Model_Target_Near0.Ann1Ann1VolumeTable_Idx[0]),
        &(Model_Target_Near0.Ann1Ann1VolumeTable_dB[0]),
        &Model_Target_B.sf_calculate_vol_gain);

    /* MATLAB Function: '<S238>/rtcscalartovector2' */
    Model_Target_rtcscalartovector2
        (Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_db_per_second,
         &Model_Target_B.sf_rtcscalartovector2);

    /* MATLAB Function: '<S238>/rtcscalartovector3' */
    Model_Target_rtcscalartovector3
        (Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_ramp_milliseconds,
         &Model_Target_B.sf_rtcscalartovector3);

    /* MATLAB Function: '<S238>/get_ramp_parameters' */
    Model_Target_get_ramp_parameters(Model_Target_B.sf_rtcscalartovector3.Outp,
        Model_Target_B.sf_rtcscalartovector2.Outp,
        Model_Target_Near0.Ann1Ann1VolumeRampTime,
        &Model_Target_B.sf_get_ramp_parameters);

    /* Outputs for Function Call SubSystem: '<S308>/SetDsm' */
    Model_Target_SetDsm(1U);

    /* End of Outputs for SubSystem: '<S308>/SetDsm' */

    /* MATLAB Function: '<S308>/rgainy ramper control' */
    /* MATLAB Function: '<S308>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S308>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol
        (Model_Target_B.sf_calculate_vol_gain.gain_value,
         Model_Target_B.sf_get_ramp_parameters.ramp_rate,
         Model_Target_B.sf_get_ramp_parameters.ramp_ms, 44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S308>/SetDsm1' */
    Model_Target_SetDsm(0U);

    /* End of Outputs for SubSystem: '<S308>/SetDsm1' */
}

/* Output and update for atomic system: '<S307>/rgainy process' */
void Model_Target_rgainyprocess(const uint8_T rtu_rampToChanMap[2], const
    real32_T rtu_audioIn[32], B_rgainyprocess_Model_Target_T *localB)
{
    int32_T b_tmp;
    int32_T n;
    real32_T gain;
    real32_T k;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S310>:1' */
    /*  set the size of the output buffer */
    /* '<S310>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S310>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S310>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S310>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S310>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S310>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S310>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain;

    /* '<S310>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.NearAnn1Ann1VolumeFreeze == 0U)
    {
        /* '<S310>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S310>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.targetGain;
        }
        else
        {
            /* '<S310>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S310>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.rampCoeff;

            /* '<S310>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.frameCount =
                Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S310>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S310>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S310>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        if (b_tmp - 1 >= 0)
        {
            localB->audioOut[n] = rtu_audioIn[n] * gain;
        }
    }

    /* '<S310>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S310>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S310>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut = gain;
    }

    /* '<S310>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain = gain;

    /* '<S310>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S310>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    if ((uint8_T)(rtu_rampToChanMap[0] + 2U) <= 2)
    {
        /* '<S310>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[0], &rtu_audioIn[0], sizeof(real32_T) << 5U);
    }
}

/* Output and update for function-call system: '<S320>/REQ' */
void HandleReqNearAnn2Ann2NonEntGainCalcvncEnableRTC(void)
{
    /* MATLAB Function: '<S315>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S336>:1' */
    /* '<S336>:1:3' go(); */
    Model_Target_MATLABFunction_i
        (Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable,
         &Model_Target_B.sf_MATLABFunction_fm);
}

/* Output and update for function-call system: '<S349>/REQ' */
void HandleReqNearAnn2Ann2MuteSet(void)
{
    real32_T quantum_ms;
    real32_T x;

    /* MATLAB Function: '<S347>/calculate_ramp_rate' */
    /* MATLAB Function: '<S347>/calculate_ramp_rate' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S356>:1' */
    /* '<S356>:1:3' go(); */
    Model_Target_calculate_ramp_rate
        (Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_Near0.Ann2Ann2MuteRampTime,
         &Model_Target_B.sf_calculate_ramp_rate_av);

    /* MATLAB Function: '<S348>/get_ramp_coeffs' */
    /* MATLAB Function: '<S348>/get_ramp_coeffs' incorporates:
     *  DataStoreRead: '<S348>/Data Store Read'
     *  S-Function (AudioStats_MEX): '<S348>/Audio Stats'
     */
    x = Model_Target_B.sf_calculate_ramp_rate_av.ramptime;

    /* MATLAB Function 'MuteRamper/get_ramp_coeffs': '<S361>:1' */
    /* '<S361>:1:5' targetLinearGain = single(1.0); */
    Model_TargetControlDsms.NearAnn2MuteTargetLinearGain = 1.0F;

    /* '<S361>:1:7' if muteSwitch */
    if (Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_mute_switch != 0U)
    {
        /* '<S361>:1:8' targetLinearGain = single(max(0, silentGainLinear)); */
        Model_TargetControlDsms.NearAnn2MuteTargetLinearGain = 4.7315126E-7F;
    }

    /*  % Nudge the gain values a bit if they are sitting at zero. */
    /*  % If current gain is zero, replace with a value very close to zero. What we */
    /*  % really want is a value which is on the edge of perception - not too small */
    /*  % or large. If the value is too small, we'll waste some of our ramp time */
    /*  % in perceived silence. If the value is too large, the audio will lurch */
    /*  % into perceptability at the start of the ramp. */
    /*  % So, 'max(currentGainValue, silentGainLinear)' & 'max(TargetGain, silentGainLinear)' are */
    /*  % used in equations */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Equivalent ramp rate is therefore calculated as follows: */
    /* '<S361>:1:24' if (rampingRate_dBPerSec) */
    if (Model_Target_B.sf_calculate_ramp_rate_av.rampRate != 0.0F)
    {
        /* '<S361>:1:25' currentGain_db = 20*log10(max(currentGainValue, silentGainLinear)); */
        /* '<S361>:1:26' targetGain_db = 20*log10( targetLinearGain); */
        /* '<S361>:1:27' diff = abs(currentGain_db - targetGain_db); */
        /* '<S361>:1:28' rampingTime_ms = diff / single(rampingRate_dBPerSec) * 1000; */
        x = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f(fmaxf
                           (Model_TargetControlDsms.NearAnn2MuteCurrentGain,
                            4.7315126E-7F)) - 20.0F * qhmath_log10_f
                          (Model_TargetControlDsms.NearAnn2MuteTargetLinearGain)),
                         Model_Target_B.sf_calculate_ramp_rate_av.rampRate) *
            1000.0F;
    }

    /* '<S361>:1:31' quantum_ms = 1000 * frameSize / Fs_Hz; */
    quantum_ms = qhmath_div_f(32000.0F, 44307.692307692312);

    /* '<S361>:1:32' numFrames = rampingTime_ms / quantum_ms; */
    /*  Do a ceil rather than a round to insure that we create enough */
    /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
    /* '<S361>:1:35' nFrames = max (1, ceil(numFrames)); */
    Model_TargetControlDsms.NearAnn2MuteNframes = fmaxf(1.0F, qhmath_ceil_f
        (qhmath_div_f(x, quantum_ms)));

    /* '<S361>:1:36' quantized_rampTime_ms = nFrames * quantum_ms; */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S361>:1:50' ramping_coeff= exp(log( targetLinearGain /max(currentGainValue, silentGainLinear) ) / (Fs_Hz * quantized_rampTime_ms / 1000)); */
    Model_Target_B.ramping_coeff_a = qhmath_div_f(qhmath_log_f(qhmath_div_f
        (Model_TargetControlDsms.NearAnn2MuteTargetLinearGain, fmaxf
         (Model_TargetControlDsms.NearAnn2MuteCurrentGain, 4.7315126E-7F))),
        qhmath_div_f(Model_TargetControlDsms.NearAnn2MuteNframes * quantum_ms *
                     44307.692307692312, 1000.0F));
    Model_Target_B.ramping_coeff_a = qhmath_exp_f(Model_Target_B.ramping_coeff_a);

    /* End of MATLAB Function: '<S348>/get_ramp_coeffs' */
}

/*
 * Output and update for function-call system:
 *    '<S388>/SetDsm'
 *    '<S388>/SetDsm1'
 */
void Model_Target_SetDsm_g(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S391>/Data Store Write' incorporates:
     *  Constant: '<S391>/Constant'
     */
    Model_TargetControlDsms.NearAnn2Ann2VolumeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S388>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol_d(real32_T rtu_target_gains_linear, real_T
    rtu_db_per_sec, real_T rtu_ramp_times_ms, real32_T rtu_sample_rate_in_hertz,
    real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S393>:1' */
    /* '<S393>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S393>:1:23' numGains = numel(target_gains_linear); */
    /* '<S393>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S393>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S393>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S393>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S393>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = (real32_T)rtu_ramp_times_ms;

        /* '<S393>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S393>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain,
             5.0118723E-7F);

        /* '<S393>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S393>:1:49' if (ramp_dbPerSec) */
        if ((real32_T)rtu_db_per_sec != 0.0F)
        {
            /* '<S393>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S393>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S393>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S393>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)), (real32_T)
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S393>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S393>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S393>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S393>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S393>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S393>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain,
                            currentGain)), qhmath_div_f(numFrames * quantum_ms *
                           rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S393>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.frameCount = (int32_T)
            numFrames;

        /* '<S393>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S393>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S393>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain =
            currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S371>/REQ' */
void HandleReqNearAnn2Ann2VolumeSet(void)
{
    /* MATLAB Function: '<S318>/rtcscalartovector' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S384>:1' */
    /* '<S384>:1:3' go(); */
    Model_Target_rtcscalartovector
        (Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_volume_index,
         &Model_Target_B.sf_rtcscalartovector_ex);

    /* MATLAB Function: '<S318>/calculate_vol_gain' */
    Model_Target_calculate_vol_gain(Model_Target_B.sf_rtcscalartovector_ex.Outp,
        &(Model_Target_Near0.Ann2Ann2VolumeTable_Idx[0]),
        &(Model_Target_Near0.Ann2Ann2VolumeTable_dB[0]),
        &Model_Target_B.sf_calculate_vol_gain_bl);

    /* MATLAB Function: '<S318>/rtcscalartovector2' */
    Model_Target_rtcscalartovector2
        (Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_db_per_second,
         &Model_Target_B.sf_rtcscalartovector2_gp);

    /* MATLAB Function: '<S318>/rtcscalartovector3' */
    Model_Target_rtcscalartovector3
        (Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_ramp_milliseconds,
         &Model_Target_B.sf_rtcscalartovector3_ee);

    /* MATLAB Function: '<S318>/get_ramp_parameters' */
    Model_Target_get_ramp_parameters
        (Model_Target_B.sf_rtcscalartovector3_ee.Outp,
         Model_Target_B.sf_rtcscalartovector2_gp.Outp,
         Model_Target_Near0.Ann2Ann2VolumeRampTime,
         &Model_Target_B.sf_get_ramp_parameters_b2);

    /* Outputs for Function Call SubSystem: '<S388>/SetDsm' */
    Model_Target_SetDsm_g(1U);

    /* End of Outputs for SubSystem: '<S388>/SetDsm' */

    /* MATLAB Function: '<S388>/rgainy ramper control' */
    /* MATLAB Function: '<S388>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S388>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol_d
        (Model_Target_B.sf_calculate_vol_gain_bl.gain_value,
         Model_Target_B.sf_get_ramp_parameters_b2.ramp_rate,
         Model_Target_B.sf_get_ramp_parameters_b2.ramp_ms, 44307.692307692312,
         32.0);

    /* Outputs for Function Call SubSystem: '<S388>/SetDsm1' */
    Model_Target_SetDsm_g(0U);

    /* End of Outputs for SubSystem: '<S388>/SetDsm1' */
}

/* Output and update for atomic system: '<S387>/rgainy process' */
void Model_Target_rgainyprocess_e(const uint8_T rtu_rampToChanMap[2], const
    real32_T rtu_audioIn[32], B_rgainyprocess_Model_Target_f_T *localB)
{
    int32_T b_tmp;
    int32_T n;
    real32_T gain;
    real32_T k;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S390>:1' */
    /*  set the size of the output buffer */
    /* '<S390>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S390>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S390>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S390>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S390>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S390>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S390>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain;

    /* '<S390>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.NearAnn2Ann2VolumeFreeze == 0U)
    {
        /* '<S390>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S390>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.targetGain;
        }
        else
        {
            /* '<S390>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S390>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.rampCoeff;

            /* '<S390>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.frameCount =
                Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S390>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S390>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S390>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        if (b_tmp - 1 >= 0)
        {
            localB->audioOut[n] = rtu_audioIn[n] * gain;
        }
    }

    /* '<S390>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S390>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S390>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut = gain;
    }

    /* '<S390>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain = gain;

    /* '<S390>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S390>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    if ((uint8_T)(rtu_rampToChanMap[0] + 2U) <= 2)
    {
        /* '<S390>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[0], &rtu_audioIn[0], sizeof(real32_T) << 5U);
    }
}

/* Output and update for function-call system: '<S400>/REQ' */
void HandleReqNearAnn3Ann3NonEntGainCalcvncEnableRTC(void)
{
    /* MATLAB Function: '<S395>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S416>:1' */
    /* '<S416>:1:3' go(); */
    Model_Target_MATLABFunction_i
        (Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable,
         &Model_Target_B.sf_MATLABFunction_ho);
}

/* Output and update for function-call system: '<S429>/REQ' */
void HandleReqNearAnn3Ann3MuteSet(void)
{
    real32_T quantum_ms;
    real32_T x;

    /* MATLAB Function: '<S427>/calculate_ramp_rate' */
    /* MATLAB Function: '<S427>/calculate_ramp_rate' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S436>:1' */
    /* '<S436>:1:3' go(); */
    Model_Target_calculate_ramp_rate
        (Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_Near0.Ann3Ann3MuteRampTime,
         &Model_Target_B.sf_calculate_ramp_rate_oj);

    /* MATLAB Function: '<S428>/get_ramp_coeffs' */
    /* MATLAB Function: '<S428>/get_ramp_coeffs' incorporates:
     *  DataStoreRead: '<S428>/Data Store Read'
     *  S-Function (AudioStats_MEX): '<S428>/Audio Stats'
     */
    x = Model_Target_B.sf_calculate_ramp_rate_oj.ramptime;

    /* MATLAB Function 'MuteRamper/get_ramp_coeffs': '<S441>:1' */
    /* '<S441>:1:5' targetLinearGain = single(1.0); */
    Model_TargetControlDsms.NearAnn3MuteTargetLinearGain = 1.0F;

    /* '<S441>:1:7' if muteSwitch */
    if (Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_mute_switch != 0U)
    {
        /* '<S441>:1:8' targetLinearGain = single(max(0, silentGainLinear)); */
        Model_TargetControlDsms.NearAnn3MuteTargetLinearGain = 4.7315126E-7F;
    }

    /*  % Nudge the gain values a bit if they are sitting at zero. */
    /*  % If current gain is zero, replace with a value very close to zero. What we */
    /*  % really want is a value which is on the edge of perception - not too small */
    /*  % or large. If the value is too small, we'll waste some of our ramp time */
    /*  % in perceived silence. If the value is too large, the audio will lurch */
    /*  % into perceptability at the start of the ramp. */
    /*  % So, 'max(currentGainValue, silentGainLinear)' & 'max(TargetGain, silentGainLinear)' are */
    /*  % used in equations */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Equivalent ramp rate is therefore calculated as follows: */
    /* '<S441>:1:24' if (rampingRate_dBPerSec) */
    if (Model_Target_B.sf_calculate_ramp_rate_oj.rampRate != 0.0F)
    {
        /* '<S441>:1:25' currentGain_db = 20*log10(max(currentGainValue, silentGainLinear)); */
        /* '<S441>:1:26' targetGain_db = 20*log10( targetLinearGain); */
        /* '<S441>:1:27' diff = abs(currentGain_db - targetGain_db); */
        /* '<S441>:1:28' rampingTime_ms = diff / single(rampingRate_dBPerSec) * 1000; */
        x = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f(fmaxf
                           (Model_TargetControlDsms.NearAnn3MuteCurrentGain,
                            4.7315126E-7F)) - 20.0F * qhmath_log10_f
                          (Model_TargetControlDsms.NearAnn3MuteTargetLinearGain)),
                         Model_Target_B.sf_calculate_ramp_rate_oj.rampRate) *
            1000.0F;
    }

    /* '<S441>:1:31' quantum_ms = 1000 * frameSize / Fs_Hz; */
    quantum_ms = qhmath_div_f(32000.0F, 44307.692307692312);

    /* '<S441>:1:32' numFrames = rampingTime_ms / quantum_ms; */
    /*  Do a ceil rather than a round to insure that we create enough */
    /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
    /* '<S441>:1:35' nFrames = max (1, ceil(numFrames)); */
    Model_TargetControlDsms.NearAnn3MuteNframes = fmaxf(1.0F, qhmath_ceil_f
        (qhmath_div_f(x, quantum_ms)));

    /* '<S441>:1:36' quantized_rampTime_ms = nFrames * quantum_ms; */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S441>:1:50' ramping_coeff= exp(log( targetLinearGain /max(currentGainValue, silentGainLinear) ) / (Fs_Hz * quantized_rampTime_ms / 1000)); */
    Model_Target_B.ramping_coeff_p = qhmath_div_f(qhmath_log_f(qhmath_div_f
        (Model_TargetControlDsms.NearAnn3MuteTargetLinearGain, fmaxf
         (Model_TargetControlDsms.NearAnn3MuteCurrentGain, 4.7315126E-7F))),
        qhmath_div_f(Model_TargetControlDsms.NearAnn3MuteNframes * quantum_ms *
                     44307.692307692312, 1000.0F));
    Model_Target_B.ramping_coeff_p = qhmath_exp_f(Model_Target_B.ramping_coeff_p);

    /* End of MATLAB Function: '<S428>/get_ramp_coeffs' */
}

/*
 * Output and update for function-call system:
 *    '<S468>/SetDsm'
 *    '<S468>/SetDsm1'
 */
void Model_Target_SetDsm_k(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S471>/Data Store Write' incorporates:
     *  Constant: '<S471>/Constant'
     */
    Model_TargetControlDsms.NearAnn3Ann3VolumeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S468>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol_c(real32_T rtu_target_gains_linear, real_T
    rtu_db_per_sec, real_T rtu_ramp_times_ms, real32_T rtu_sample_rate_in_hertz,
    real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S473>:1' */
    /* '<S473>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S473>:1:23' numGains = numel(target_gains_linear); */
    /* '<S473>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S473>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S473>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S473>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S473>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = (real32_T)rtu_ramp_times_ms;

        /* '<S473>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S473>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain,
             5.0118723E-7F);

        /* '<S473>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S473>:1:49' if (ramp_dbPerSec) */
        if ((real32_T)rtu_db_per_sec != 0.0F)
        {
            /* '<S473>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S473>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S473>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S473>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)), (real32_T)
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S473>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S473>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S473>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S473>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S473>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S473>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain,
                            currentGain)), qhmath_div_f(numFrames * quantum_ms *
                           rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S473>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.frameCount = (int32_T)
            numFrames;

        /* '<S473>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S473>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S473>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain =
            currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S451>/REQ' */
void HandleReqNearAnn3Ann3VolumeSet(void)
{
    /* MATLAB Function: '<S398>/rtcscalartovector' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S464>:1' */
    /* '<S464>:1:3' go(); */
    Model_Target_rtcscalartovector
        (Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_volume_index,
         &Model_Target_B.sf_rtcscalartovector_oe);

    /* MATLAB Function: '<S398>/calculate_vol_gain' */
    Model_Target_calculate_vol_gain(Model_Target_B.sf_rtcscalartovector_oe.Outp,
        &(Model_Target_Near0.Ann3Ann3VolumeTable_Idx[0]),
        &(Model_Target_Near0.Ann3Ann3VolumeTable_dB[0]),
        &Model_Target_B.sf_calculate_vol_gain_aa);

    /* MATLAB Function: '<S398>/rtcscalartovector2' */
    Model_Target_rtcscalartovector2
        (Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_db_per_second,
         &Model_Target_B.sf_rtcscalartovector2_nw);

    /* MATLAB Function: '<S398>/rtcscalartovector3' */
    Model_Target_rtcscalartovector3
        (Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_ramp_milliseconds,
         &Model_Target_B.sf_rtcscalartovector3_eg0);

    /* MATLAB Function: '<S398>/get_ramp_parameters' */
    Model_Target_get_ramp_parameters
        (Model_Target_B.sf_rtcscalartovector3_eg0.Outp,
         Model_Target_B.sf_rtcscalartovector2_nw.Outp,
         Model_Target_Near0.Ann3Ann3VolumeRampTime,
         &Model_Target_B.sf_get_ramp_parameters_e3);

    /* Outputs for Function Call SubSystem: '<S468>/SetDsm' */
    Model_Target_SetDsm_k(1U);

    /* End of Outputs for SubSystem: '<S468>/SetDsm' */

    /* MATLAB Function: '<S468>/rgainy ramper control' */
    /* MATLAB Function: '<S468>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S468>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol_c
        (Model_Target_B.sf_calculate_vol_gain_aa.gain_value,
         Model_Target_B.sf_get_ramp_parameters_e3.ramp_rate,
         Model_Target_B.sf_get_ramp_parameters_e3.ramp_ms, 44307.692307692312,
         32.0);

    /* Outputs for Function Call SubSystem: '<S468>/SetDsm1' */
    Model_Target_SetDsm_k(0U);

    /* End of Outputs for SubSystem: '<S468>/SetDsm1' */
}

/* Output and update for atomic system: '<S467>/rgainy process' */
void Model_Target_rgainyprocess_a(const uint8_T rtu_rampToChanMap[2], const
    real32_T rtu_audioIn[32], B_rgainyprocess_Model_Target_j_T *localB)
{
    int32_T b_tmp;
    int32_T n;
    real32_T gain;
    real32_T k;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S470>:1' */
    /*  set the size of the output buffer */
    /* '<S470>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S470>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S470>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S470>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S470>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S470>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S470>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain;

    /* '<S470>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.NearAnn3Ann3VolumeFreeze == 0U)
    {
        /* '<S470>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S470>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.targetGain;
        }
        else
        {
            /* '<S470>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S470>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.rampCoeff;

            /* '<S470>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.frameCount =
                Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S470>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S470>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S470>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        if (b_tmp - 1 >= 0)
        {
            localB->audioOut[n] = rtu_audioIn[n] * gain;
        }
    }

    /* '<S470>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S470>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S470>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut = gain;
    }

    /* '<S470>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain = gain;

    /* '<S470>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S470>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    if ((uint8_T)(rtu_rampToChanMap[0] + 2U) <= 2)
    {
        /* '<S470>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[0], &rtu_audioIn[0], sizeof(real32_T) << 5U);
    }
}

/* Output and update for function-call system: '<S480>/REQ' */
void HandleReqNearAnn4Ann4NonEntGainCalcvncEnableRTC(void)
{
    /* MATLAB Function: '<S475>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S496>:1' */
    /* '<S496>:1:3' go(); */
    Model_Target_MATLABFunction_i
        (Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable,
         &Model_Target_B.sf_MATLABFunction_fsi);
}

/* Output and update for function-call system: '<S509>/REQ' */
void HandleReqNearAnn4Ann4MuteSet(void)
{
    real32_T quantum_ms;
    real32_T x;

    /* MATLAB Function: '<S507>/calculate_ramp_rate' */
    /* MATLAB Function: '<S507>/calculate_ramp_rate' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S516>:1' */
    /* '<S516>:1:3' go(); */
    Model_Target_calculate_ramp_rate
        (Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_Near0.Ann4Ann4MuteRampTime,
         &Model_Target_B.sf_calculate_ramp_rate_j2);

    /* MATLAB Function: '<S508>/get_ramp_coeffs' */
    /* MATLAB Function: '<S508>/get_ramp_coeffs' incorporates:
     *  DataStoreRead: '<S508>/Data Store Read'
     *  S-Function (AudioStats_MEX): '<S508>/Audio Stats'
     */
    x = Model_Target_B.sf_calculate_ramp_rate_j2.ramptime;

    /* MATLAB Function 'MuteRamper/get_ramp_coeffs': '<S521>:1' */
    /* '<S521>:1:5' targetLinearGain = single(1.0); */
    Model_TargetControlDsms.NearAnn4MuteTargetLinearGain = 1.0F;

    /* '<S521>:1:7' if muteSwitch */
    if (Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_mute_switch != 0U)
    {
        /* '<S521>:1:8' targetLinearGain = single(max(0, silentGainLinear)); */
        Model_TargetControlDsms.NearAnn4MuteTargetLinearGain = 4.7315126E-7F;
    }

    /*  % Nudge the gain values a bit if they are sitting at zero. */
    /*  % If current gain is zero, replace with a value very close to zero. What we */
    /*  % really want is a value which is on the edge of perception - not too small */
    /*  % or large. If the value is too small, we'll waste some of our ramp time */
    /*  % in perceived silence. If the value is too large, the audio will lurch */
    /*  % into perceptability at the start of the ramp. */
    /*  % So, 'max(currentGainValue, silentGainLinear)' & 'max(TargetGain, silentGainLinear)' are */
    /*  % used in equations */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Equivalent ramp rate is therefore calculated as follows: */
    /* '<S521>:1:24' if (rampingRate_dBPerSec) */
    if (Model_Target_B.sf_calculate_ramp_rate_j2.rampRate != 0.0F)
    {
        /* '<S521>:1:25' currentGain_db = 20*log10(max(currentGainValue, silentGainLinear)); */
        /* '<S521>:1:26' targetGain_db = 20*log10( targetLinearGain); */
        /* '<S521>:1:27' diff = abs(currentGain_db - targetGain_db); */
        /* '<S521>:1:28' rampingTime_ms = diff / single(rampingRate_dBPerSec) * 1000; */
        x = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f(fmaxf
                           (Model_TargetControlDsms.NearAnn4MuteCurrentGain,
                            4.7315126E-7F)) - 20.0F * qhmath_log10_f
                          (Model_TargetControlDsms.NearAnn4MuteTargetLinearGain)),
                         Model_Target_B.sf_calculate_ramp_rate_j2.rampRate) *
            1000.0F;
    }

    /* '<S521>:1:31' quantum_ms = 1000 * frameSize / Fs_Hz; */
    quantum_ms = qhmath_div_f(32000.0F, 44307.692307692312);

    /* '<S521>:1:32' numFrames = rampingTime_ms / quantum_ms; */
    /*  Do a ceil rather than a round to insure that we create enough */
    /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
    /* '<S521>:1:35' nFrames = max (1, ceil(numFrames)); */
    Model_TargetControlDsms.NearAnn4MuteNframes = fmaxf(1.0F, qhmath_ceil_f
        (qhmath_div_f(x, quantum_ms)));

    /* '<S521>:1:36' quantized_rampTime_ms = nFrames * quantum_ms; */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S521>:1:50' ramping_coeff= exp(log( targetLinearGain /max(currentGainValue, silentGainLinear) ) / (Fs_Hz * quantized_rampTime_ms / 1000)); */
    Model_Target_B.ramping_coeff_l = qhmath_div_f(qhmath_log_f(qhmath_div_f
        (Model_TargetControlDsms.NearAnn4MuteTargetLinearGain, fmaxf
         (Model_TargetControlDsms.NearAnn4MuteCurrentGain, 4.7315126E-7F))),
        qhmath_div_f(Model_TargetControlDsms.NearAnn4MuteNframes * quantum_ms *
                     44307.692307692312, 1000.0F));
    Model_Target_B.ramping_coeff_l = qhmath_exp_f(Model_Target_B.ramping_coeff_l);

    /* End of MATLAB Function: '<S508>/get_ramp_coeffs' */
}

/*
 * Output and update for function-call system:
 *    '<S548>/SetDsm'
 *    '<S548>/SetDsm1'
 */
void Model_Target_SetDsm_d(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S551>/Data Store Write' incorporates:
     *  Constant: '<S551>/Constant'
     */
    Model_TargetControlDsms.NearAnn4Ann4VolumeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S548>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol_p(real32_T rtu_target_gains_linear, real_T
    rtu_db_per_sec, real_T rtu_ramp_times_ms, real32_T rtu_sample_rate_in_hertz,
    real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S553>:1' */
    /* '<S553>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S553>:1:23' numGains = numel(target_gains_linear); */
    /* '<S553>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S553>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S553>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S553>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S553>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = (real32_T)rtu_ramp_times_ms;

        /* '<S553>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S553>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain,
             5.0118723E-7F);

        /* '<S553>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S553>:1:49' if (ramp_dbPerSec) */
        if ((real32_T)rtu_db_per_sec != 0.0F)
        {
            /* '<S553>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S553>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S553>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S553>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)), (real32_T)
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S553>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S553>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S553>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S553>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S553>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S553>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain,
                            currentGain)), qhmath_div_f(numFrames * quantum_ms *
                           rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S553>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.frameCount = (int32_T)
            numFrames;

        /* '<S553>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S553>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S553>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain =
            currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S531>/REQ' */
void HandleReqNearAnn4Ann4VolumeSet(void)
{
    /* MATLAB Function: '<S478>/rtcscalartovector' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S544>:1' */
    /* '<S544>:1:3' go(); */
    Model_Target_rtcscalartovector
        (Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_volume_index,
         &Model_Target_B.sf_rtcscalartovector_dj);

    /* MATLAB Function: '<S478>/calculate_vol_gain' */
    Model_Target_calculate_vol_gain(Model_Target_B.sf_rtcscalartovector_dj.Outp,
        &(Model_Target_Near0.Ann4Ann4VolumeTable_Idx[0]),
        &(Model_Target_Near0.Ann4Ann4VolumeTable_dB[0]),
        &Model_Target_B.sf_calculate_vol_gain_gi);

    /* MATLAB Function: '<S478>/rtcscalartovector2' */
    Model_Target_rtcscalartovector2
        (Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_db_per_second,
         &Model_Target_B.sf_rtcscalartovector2_of);

    /* MATLAB Function: '<S478>/rtcscalartovector3' */
    Model_Target_rtcscalartovector3
        (Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_ramp_milliseconds,
         &Model_Target_B.sf_rtcscalartovector3_g2);

    /* MATLAB Function: '<S478>/get_ramp_parameters' */
    Model_Target_get_ramp_parameters
        (Model_Target_B.sf_rtcscalartovector3_g2.Outp,
         Model_Target_B.sf_rtcscalartovector2_of.Outp,
         Model_Target_Near0.Ann4Ann4VolumeRampTime,
         &Model_Target_B.sf_get_ramp_parameters_ld);

    /* Outputs for Function Call SubSystem: '<S548>/SetDsm' */
    Model_Target_SetDsm_d(1U);

    /* End of Outputs for SubSystem: '<S548>/SetDsm' */

    /* MATLAB Function: '<S548>/rgainy ramper control' */
    /* MATLAB Function: '<S548>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S548>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol_p
        (Model_Target_B.sf_calculate_vol_gain_gi.gain_value,
         Model_Target_B.sf_get_ramp_parameters_ld.ramp_rate,
         Model_Target_B.sf_get_ramp_parameters_ld.ramp_ms, 44307.692307692312,
         32.0);

    /* Outputs for Function Call SubSystem: '<S548>/SetDsm1' */
    Model_Target_SetDsm_d(0U);

    /* End of Outputs for SubSystem: '<S548>/SetDsm1' */
}

/* Output and update for atomic system: '<S547>/rgainy process' */
void Model_Target_rgainyprocess_i(const uint8_T rtu_rampToChanMap[2], const
    real32_T rtu_audioIn[32], B_rgainyprocess_Model_Target_i_T *localB)
{
    int32_T b_tmp;
    int32_T n;
    real32_T gain;
    real32_T k;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S550>:1' */
    /*  set the size of the output buffer */
    /* '<S550>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S550>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S550>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S550>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S550>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S550>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S550>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain;

    /* '<S550>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.NearAnn4Ann4VolumeFreeze == 0U)
    {
        /* '<S550>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S550>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.targetGain;
        }
        else
        {
            /* '<S550>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S550>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.rampCoeff;

            /* '<S550>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.frameCount =
                Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S550>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S550>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S550>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        if (b_tmp - 1 >= 0)
        {
            localB->audioOut[n] = rtu_audioIn[n] * gain;
        }
    }

    /* '<S550>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S550>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S550>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut = gain;
    }

    /* '<S550>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain = gain;

    /* '<S550>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S550>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    if ((uint8_T)(rtu_rampToChanMap[0] + 2U) <= 2)
    {
        /* '<S550>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[0], &rtu_audioIn[0], sizeof(real32_T) << 5U);
    }
}

/* System initialize for atomic system: '<S4>/SrcDownAnn' */
void Model_Target_SrcDownAnn_Init(void)
{
    int32_T i;

    /* Start for Constant: '<S561>/coeffs' */
    memcpy(&Model_Target_B.coeffs_c[0], &Model_Target_ConstP.pooled56[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Start for Constant: '<S561>/advance' */
        Model_Target_B.advance_h[i] = Model_Target_ConstP.pooled36[i];
    }

    /* InitializeConditions for S-Function (SampleRateConverter_sfunc): '<S561>/S-Function' */

    // S-Function Block: <S561>/S-Function (SampleRateConverter_sfunc)
    {
        // Temporary values/pointers
        int idx;
        int nCh = 2;
        int nFrameIn = 32;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = nFrameIn;
        else
            nFrameOut = (-1);

        // Pointer to filter coefficient blocks
        float *pFilter, *pFilterEnd, *pFilterCurr;
        int *pAdvance, *pAdvanceEnd, *pAdvanceCurr;
        int nBuffer;                   // Number of input samples

        // Pointer to input circular buffers and read/write pointers
        float **pInputBuffer, **pInputBufferEnd, **pInputWrite, **pInputRead;

        /*
         * Save filter and advance sample pointers
         */
        pFilter = (float*)(&Model_Target_B.coeffs_c[0]);
        pFilterEnd = pFilter + (240);
        pFilterCurr = pFilter;
        pAdvance = (int*)(&Model_Target_B.advance_h[0]);
        pAdvanceEnd = pAdvance + (12);
        pAdvanceCurr = pAdvance;

        /*
         * Allocate input buffers and pointers
         */

        // Calculate the number of input samples needed to produce output per input frame
        nBuffer = 2 * ceil(nFrameOut * (13) / (12)) + (20);

        // Quantize to input frame size
        nBuffer = (int)(ceil((float)nBuffer / (float)nFrameIn));//Number of frames
        if (nBuffer < 2)
            nBuffer = 2;               //Min num of frames = 2
        nBuffer = nBuffer * nFrameIn;

        // Allocate the circular buffers along with end/read/write pointers
        pInputBuffer = (float**)&Model_Target_DW.SFunction_pInputBuffer_i[0];
        pInputBufferEnd = (float**)&Model_Target_DW.SFunction_pInputBufferEnd_i
            [0];
        pInputWrite = (float**)&Model_Target_DW.SFunction_pInputWrite_n[0];
        pInputRead = (float**)&Model_Target_DW.SFunction_pInputRead_g[0];
        for (idx = 0; idx < nCh; idx++)
        {
            // Allocate twice what is needed ("double buffer")
            pInputBuffer[idx] = (float*)
                &Model_Target_DW.SFunction_InputBuffer_p[0] + (idx * nBuffer);
            pInputBufferEnd[idx] = pInputBuffer[idx] + nBuffer;
            pInputWrite[idx] = pInputBuffer[idx] ;
            pInputRead[idx] = pInputBuffer[idx] + (nBuffer >> 1) - 1;
        }

#if defined (__HEXAGON_ARCH__)
#ifdef MULITITHREAD

        Src_t* src = (Src_t*)&Model_Target_DW.SFunction_ThreadBuffer_m[0];
        int maxNumberOfThreads = MAX_THREAD_NUM;
        unsigned int tLoad = roundf((float) nCh / (float) maxNumberOfThreads);
        for (int i = 0; i < MAX_THREAD_NUM - 1; i++)
        {
            src->thread_arg[i].numChannels = tLoad;
            src->thread_arg[i].startChannel = i * tLoad;
        }

        //sum of number of channels processed by previous threads
        unsigned int lastTLoad = src->thread_arg[maxNumberOfThreads - 2].
            startChannel + src->thread_arg[maxNumberOfThreads - 2].numChannels;
        src->thread_arg[maxNumberOfThreads - 1].numChannels = nCh - lastTLoad;
        src->thread_arg[maxNumberOfThreads - 1].startChannel = lastTLoad;
        src->numThreadsToRun = maxNumberOfThreads;

        //calculation of filter output offset
        src->thread_arg[0].outOffset= 0;
        for (int i = 1 ;i < src->numThreadsToRun; i++)
        {
            src->thread_arg[i].outOffset = src->thread_arg[i - 1].outOffset +
                nFrameOut*src->thread_arg[i - 1].numChannels;
        }

        real32_T* pThreadStack = &Model_Target_DW.SFunction_ThreadStack_h[0];
        for (int i = 0; i < src->numThreadsToRun; i++)
        {
            qurt_sem_init_val(&src->thread_arg[i].semaWork, 0);
            qurt_sem_init_val(&src->thread_arg[i].semaDone, 0);
            src->thread_stack_addr[i] = pThreadStack+STACK_SIZE*i;
            qurt_thread_attr_init(&src->attr[i]);
            char threadName[THREAD_NAME_LEN];
            snprintf(threadName, THREAD_NAME_LEN, "SRC_%x", (unsigned int)
                     src->thread_stack_addr[i]);
            qurt_thread_attr_set_name(&src->attr[i], threadName);
            qurt_thread_attr_set_stack_addr(&src->attr[i],
                src->thread_stack_addr[i]);
            qurt_thread_attr_set_stack_size(&src->attr[i], STACK_SIZE);
            qurt_thread_attr_set_priority(&src->attr[i], 0);
            qurt_thread_create(&src->threads[i], &src->attr[i], src_thread,
                               (void *) &src->thread_arg[i]);
        }

#endif
#endif

        // Save pointers
        Model_Target_DW.SFunction_PWORK_p[0] = (void*)pInputBuffer;
        Model_Target_DW.SFunction_PWORK_p[1] = (void*)pInputBufferEnd;
        Model_Target_DW.SFunction_PWORK_p[2] = (void*)pInputWrite;
        Model_Target_DW.SFunction_PWORK_p[3] = (void*)pInputRead;
        Model_Target_DW.SFunction_PWORK_p[4] = (void*)pFilter;
        Model_Target_DW.SFunction_PWORK_p[5] = (void*)pFilterEnd;
        Model_Target_DW.SFunction_PWORK_p[6] = (void*)pFilterCurr;
        Model_Target_DW.SFunction_PWORK_p[7] = (void*)pAdvance;
        Model_Target_DW.SFunction_PWORK_p[8] = (void*)pAdvanceEnd;
        Model_Target_DW.SFunction_PWORK_p[9] = (void*)pAdvanceCurr;
        Model_Target_DW.SFunction_IWORK_mr = nBuffer;
    }
}

/* Output and update for atomic system: '<S4>/SrcDownAnn' */
void Model_Target_SrcDownAnnTID1(void)
{
    int_T tid = 1;

    /* S-Function (SampleRateConverter_sfunc): '<S561>/S-Function' */
    /* Because the Outputs function of multirate block
       <S561>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S561>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 2;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction_d[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_p[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_p[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_p[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_p[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_p[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_p[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_p[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_p[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_p[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_p[9]);

#ifdef MULITITHREAD

            Src_t *src = (Src_t*)&(Model_Target_DW.SFunction_ThreadBuffer_m[0]);
            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                src->thread_arg[i].out = out;
                src->thread_arg[i].pInputBuffer = pInputBuffer;
                src->thread_arg[i].pInputBufferEnd = pInputBufferEnd;
                src->thread_arg[i].pInputWrite = pInputWrite;
                src->thread_arg[i].pInputRead = pInputRead;
                src->thread_arg[i].pFilter = pFilter;
                src->thread_arg[i].pFilterEnd = pFilterEnd;
                src->thread_arg[i].pFilterCurr = pFilterCurr;
                src->thread_arg[i].pAdvance = pAdvance;
                src->thread_arg[i].pAdvanceEnd = pAdvanceEnd;
                src->thread_arg[i].pAdvanceCurr = pAdvanceCurr;
                src->thread_arg[i].nFrameOut = nFrameOut;
                src->thread_arg[i].nFilterBlocks = 20;
                src->thread_arg[i].nBuffer = Model_Target_DW.SFunction_IWORK_mr ;
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_up( &src->thread_arg[i].semaWork );
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_down( &src->thread_arg[i].semaDone );
            }

            Model_Target_DW.SFunction_PWORK_p[6] = (void*)src->thread_arg[0].
                pFilterCurr;
            Model_Target_DW.SFunction_PWORK_p[9] = (void*)src->thread_arg[0].
                pAdvanceCurr;

#else

            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh >> 1) << 1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_mr;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_mr *
                                      sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_mr;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_mr;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_mr *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_mr *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_mr;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_mr *
                                      sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_mr;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_mr * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_p[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_p[9] = (void*)pAdvanceCurr;

#endif

        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S561>/S-Function' */
    /* Because the Update function of multirate block
       <S561>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S561>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 2;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector2[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_p[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_p[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_p[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_mr) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Output and update for atomic system: '<S4>/SrcDownAnn' */
void Model_Target_SrcDownAnnTID2(void)
{
    int_T tid = 2;
    int32_T i;

    /* Constant: '<S561>/coeffs' */
    memcpy(&Model_Target_B.coeffs_c[0], &Model_Target_ConstP.pooled56[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Constant: '<S561>/advance' */
        Model_Target_B.advance_h[i] = Model_Target_ConstP.pooled36[i];
    }

    /* S-Function (SampleRateConverter_sfunc): '<S561>/S-Function' */
    /* Because the Outputs function of multirate block
       <S561>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S561>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 2;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction_d[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_p[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_p[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_p[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_p[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_p[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_p[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_p[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_p[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_p[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_p[9]);

#ifdef MULITITHREAD

            Src_t *src = (Src_t*)&(Model_Target_DW.SFunction_ThreadBuffer_m[0]);
            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                src->thread_arg[i].out = out;
                src->thread_arg[i].pInputBuffer = pInputBuffer;
                src->thread_arg[i].pInputBufferEnd = pInputBufferEnd;
                src->thread_arg[i].pInputWrite = pInputWrite;
                src->thread_arg[i].pInputRead = pInputRead;
                src->thread_arg[i].pFilter = pFilter;
                src->thread_arg[i].pFilterEnd = pFilterEnd;
                src->thread_arg[i].pFilterCurr = pFilterCurr;
                src->thread_arg[i].pAdvance = pAdvance;
                src->thread_arg[i].pAdvanceEnd = pAdvanceEnd;
                src->thread_arg[i].pAdvanceCurr = pAdvanceCurr;
                src->thread_arg[i].nFrameOut = nFrameOut;
                src->thread_arg[i].nFilterBlocks = 20;
                src->thread_arg[i].nBuffer = Model_Target_DW.SFunction_IWORK_mr ;
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_up( &src->thread_arg[i].semaWork );
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_down( &src->thread_arg[i].semaDone );
            }

            Model_Target_DW.SFunction_PWORK_p[6] = (void*)src->thread_arg[0].
                pFilterCurr;
            Model_Target_DW.SFunction_PWORK_p[9] = (void*)src->thread_arg[0].
                pAdvanceCurr;

#else

            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh >> 1) << 1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_mr;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_mr *
                                      sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_mr;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_mr;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_mr *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_mr *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_mr;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_mr *
                                      sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_mr;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_mr * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_p[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_p[9] = (void*)pAdvanceCurr;

#endif

        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S561>/S-Function' */
    /* Because the Update function of multirate block
       <S561>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S561>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 2;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector2[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_p[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_p[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_p[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_mr) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Termination for atomic system: '<S4>/SrcDownAnn' */
void Model_Target_SrcDownAnn_Term(void)
{
    /* Terminate for S-Function (SampleRateConverter_sfunc): '<S561>/S-Function' */

    /* S-Function Block: <S561>/S-Function (SampleRateConverter_sfunc) */
    {
    }
}

/* Output and update for function-call system: '<S678>/REQ' */
void HandleReqPreAmpAudiopilotsetHVACSetting(void)
{
    int32_T idx;
    int32_T low_i;
    int32_T low_ip1;
    int32_T mid_i;
    int32_T y_size_idx_0;
    real32_T b_x_data[16];
    real32_T y_data[16];
    real32_T r;
    real32_T xtmp;
    int8_T ii_data[16];
    boolean_T x[16];
    boolean_T exitg1;

    /* MATLAB Function: '<S673>/MATLAB Function' */
    /* MATLAB Function: '<S673>/MATLAB Function' incorporates:
     *  S-Function (TOP_MEX): '<S679>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S683>:1' */
    /* '<S683>:1:3' go(); */
    r = Model_TargetPreAmpAudiopilotsetHVACSettingRtcOut.REQ_HVACSetting;

    /*  "hvacSetting": Float value between [0,1.0], coming in as a control message */
    /*  "table": Table containing noise values corresponding to different */
    /*           HVAC settings */
    /*  "hvacDbspl": Interpolated HVAC noise value (dBSPL) */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/ConfigurationRtcInputs/Hvac/MATLAB Function': '<S677>:1' */
    /*  Ensuring the RTC hvac setting is always in the range [0,1.0] */
    /* '<S677>:1:10' if (hvacSettingRTC < 0.0) */
    if (Model_TargetPreAmpAudiopilotsetHVACSettingRtcOut.REQ_HVACSetting < 0.0F)
    {
        /* '<S677>:1:11' hvacSettingRTC = single(0.0); */
        r = 0.0F;
    }
    else if (Model_TargetPreAmpAudiopilotsetHVACSettingRtcOut.REQ_HVACSetting >
             1.0F)
    {
        /* '<S677>:1:12' elseif (hvacSettingRTC > 1.0) */
        /* '<S677>:1:13' hvacSettingRTC = single(1.0); */
        r = 1.0F;
    }

    /*  Since the HVACtable size is variable, the tune variable translation fills */
    /*  the empty elements with 0s. The tune translation ensures that the first */
    /*  HVAC setting will be a 0.0. Hence we extract the table upto the index of */
    /*  the trailing zero. */
    /* '<S677>:1:20' zeroIdx = find(table(:,1) == 0); */
    for (idx = 0; idx < 16; idx++)
    {
        x[idx] = (Model_Target_PreAmp0.AudiopilotHvacTable[idx] == 0.0F);
    }

    idx = 0;
    low_i = 0;
    exitg1 = false;
    while ((!exitg1) && (low_i < 16))
    {
        if (x[low_i])
        {
            idx++;
            ii_data[idx - 1] = (int8_T)(low_i + 1);
            if (idx >= 16)
            {
                exitg1 = true;
            }
            else
            {
                low_i++;
            }
        }
        else
        {
            low_i++;
        }
    }

    if (idx < 1)
    {
        idx = 0;
    }

    /* '<S677>:1:21' if length(zeroIdx) > 1 */
    if (idx > 1)
    {
        /* '<S677>:1:22' trailingZeroIdx = zeroIdx(2); */
        /* '<S677>:1:23' tableSetting = table(1: trailingZeroIdx-1,1); */
        if (ii_data[1] - 1 < 1)
        {
            low_i = -1;
        }
        else
        {
            low_i = ii_data[1] - 2;
        }

        idx = low_i + 1;
        if (low_i >= 0)
        {
            memcpy(&b_x_data[0], &(Model_Target_PreAmp0.AudiopilotHvacTable[0]),
                   (uint32_T)(low_i + 1) * sizeof(real32_T));
        }

        /* '<S677>:1:24' tableNoise   = table(1: trailingZeroIdx-1,2); */
        if (ii_data[1] - 1 < 1)
        {
            low_i = -1;
        }
        else
        {
            low_i = ii_data[1] - 2;
        }

        y_size_idx_0 = low_i + 1;
        if (low_i >= 0)
        {
            memcpy(&y_data[0], &(Model_Target_PreAmp0.AudiopilotHvacTable[16]),
                   (uint32_T)(low_i + 1) * sizeof(real32_T));
        }
    }
    else
    {
        /* '<S677>:1:25' else */
        /* '<S677>:1:26' tableSetting = table(:,1); */
        idx = 16;

        /* '<S677>:1:27' tableNoise   = table(:,2); */
        y_size_idx_0 = 16;
        memcpy(&b_x_data[0], &(Model_Target_PreAmp0.AudiopilotHvacTable[0]),
               sizeof(real32_T) << 4U);
        memcpy(&y_data[0], &(Model_Target_PreAmp0.AudiopilotHvacTable[16]),
               sizeof(real32_T) << 4U);
    }

    /*  [tableSetting, idx] = unique(table(:,1)); */
    /*  tableNoise = table(idx,2); */
    /*  Interpolate to find where the incoming */
    /*  hvacSetting lies in the noise table. */
    /* '<S677>:1:34' hvacDbspl = interp1(tableSetting, tableNoise, hvacSettingRTC); */
    if (b_x_data[1] < b_x_data[0])
    {
        low_i = idx >> 1;
        for (low_ip1 = 0; low_ip1 < low_i; low_ip1++)
        {
            xtmp = b_x_data[low_ip1];
            b_x_data[low_ip1] = b_x_data[(idx - low_ip1) - 1];
            b_x_data[(idx - low_ip1) - 1] = xtmp;
        }

        if ((y_size_idx_0 != 0) && (y_size_idx_0 > 1))
        {
            low_i = y_size_idx_0 >> 1;
            for (low_ip1 = 0; low_ip1 < low_i; low_ip1++)
            {
                xtmp = y_data[low_ip1];
                mid_i = (y_size_idx_0 - low_ip1) - 1;
                y_data[low_ip1] = y_data[mid_i];
                y_data[mid_i] = xtmp;
            }
        }
    }

    Model_Target_B.hvacDbspl = 0.0F;
    if ((r <= b_x_data[idx - 1]) && (r >= b_x_data[0]))
    {
        low_i = 1;
        low_ip1 = 2;
        while (idx > low_ip1)
        {
            mid_i = (low_i >> 1) + (idx >> 1);
            if (((low_i & 1) == 1) && ((idx & 1) == 1))
            {
                mid_i++;
            }

            if (r >= b_x_data[mid_i - 1])
            {
                low_i = mid_i;
                low_ip1 = mid_i + 1;
            }
            else
            {
                idx = mid_i;
            }
        }

        xtmp = b_x_data[low_i - 1];
        r = qhmath_div_f(r - xtmp, b_x_data[low_i] - xtmp);
        if (r == 0.0F)
        {
            Model_Target_B.hvacDbspl = y_data[low_i - 1];
        }
        else if (r == 1.0F)
        {
            Model_Target_B.hvacDbspl = y_data[low_i];
        }
        else
        {
            xtmp = y_data[low_i - 1];
            if (xtmp == y_data[low_i])
            {
                Model_Target_B.hvacDbspl = xtmp;
            }
            else
            {
                Model_Target_B.hvacDbspl = (1.0F - r) * xtmp + r * y_data[low_i];
            }
        }
    }

    /* End of MATLAB Function: '<S673>/MATLAB Function' */
}

/*
 * Output and update for atomic system:
 *    '<S698>/ApplyBpfGain'
 *    '<S698>/ApplyLpfGain'
 */
void Model_Target_ApplyBpfGain(const real32_T rtu_audio[64], const real32_T
    rtu_gain[32], B_ApplyBpfGain_Model_Target_T *localB)
{
    int32_T i;
    real32_T rtu_gain_0[64];

    /*  This applies a frame of gains to the input audio */
    /*  It should work for any number of channels */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainApplication/Compensation/ApplyBpfGain': '<S703>:1' */
    /* '<S703>:1:5' numchan = size(audio,2); */
    /* '<S703>:1:6' out = audio .* (gain * ones(1,numchan)); */
    for (i = 0; i < 2; i++)
    {
        memcpy(&rtu_gain_0[i << 5], &rtu_gain[0], sizeof(real32_T) << 5U);
    }

    for (i = 0; i < 64; i++)
    {
        localB->out[i] = rtu_audio[i] * rtu_gain_0[i];
    }
}

/* Output and update for function-call system: '<S737>/REQ' */
void HandleReqPreAmpAudiopilotgetAverageAudioPilotBoostLevel(void)
{
    int32_T count;
    real32_T divBass;
    real32_T divMid;
    real32_T divTreble;

    /* MATLAB Function: '<S669>/AverageBoostLevel' */
    /* MATLAB Function: '<S669>/AverageBoostLevel' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S819>:1' */
    /* '<S819>:1:3' go(); */
    /*  This function calculates the average boost value for a given set of bass, */
    /*  mid, and treble boost values. A boost value is included in the average if */
    /*  the corresponding maximum boost value is greater than a threshold. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/AverageBoostLevel': '<S734>:1' */
    /*  Constants */
    /* '<S734>:1:8' cTHRESHOLD = single(1e-12); */
    /* '<S734>:1:9' cONE = single(1); */
    /*  States */
    /* '<S734>:1:13' count = single(0); */
    count = 0;

    /* '<S734>:1:14' divBass = single(0); */
    divBass = 0.0F;

    /* '<S734>:1:15' divMid = single(0); */
    divMid = 0.0F;

    /* '<S734>:1:16' divTreble = single(0); */
    divTreble = 0.0F;

    /*  The value formulates the boost as a percentage/fraction  */
    /*  of the maximum. */
    /*  If the max boost for the band is zero,  */
    /*  that band is disabled and not counted towards the average. */
    /* '<S734>:1:23' if (maxBassBoost > cTHRESHOLD) */
    if (Model_Target_PreAmp0.AudiopilotBassMaxAudiopilotBoostDb > 1.0E-12F)
    {
        /* '<S734>:1:24' divBass = bassBoost/maxBassBoost; */
        divBass = qhmath_div_f(Model_Target_B.Product2,
                               Model_Target_PreAmp0.AudiopilotBassMaxAudiopilotBoostDb);

        /* '<S734>:1:25' count = count + 1; */
        count = 1;
    }

    /* '<S734>:1:28' if (maxMidBoost > cTHRESHOLD) */
    if (Model_Target_PreAmp0.AudiopilotMidrangeMaxTotalBoostDb > 1.0E-12F)
    {
        /* '<S734>:1:29' divMid = midBoost/maxMidBoost; */
        divMid = qhmath_div_f(Model_Target_B.Product1_o,
                              Model_Target_PreAmp0.AudiopilotMidrangeMaxTotalBoostDb);

        /* '<S734>:1:30' count = count + 1; */
        count++;
    }

    /* '<S734>:1:33' if (maxTrebleBoost > cTHRESHOLD) */
    if (Model_Target_PreAmp0.AudiopilotTrebleMaxTotalBoostDb > 1.0E-12F)
    {
        /* '<S734>:1:34' divTreble = trebleBoost/maxTrebleBoost; */
        divTreble = qhmath_div_f(Model_Target_B.Product,
            Model_Target_PreAmp0.AudiopilotTrebleMaxTotalBoostDb);

        /* '<S734>:1:35' count = count + 1; */
        count++;
    }

    /*  Calculate the average */
    /* '<S734>:1:40' boostAverage = (divBass + divMid + divTreble); */
    Model_Target_B.boostAverage = (divBass + divMid) + divTreble;

    /* '<S734>:1:42' if (count > cONE) */
    if (count > 1)
    {
        /* '<S734>:1:43' boostAverage = boostAverage/count; */
        Model_Target_B.boostAverage = qhmath_div_f(Model_Target_B.boostAverage,
            (real32_T)count);
    }

    /* End of MATLAB Function: '<S669>/AverageBoostLevel' */
}

/*
 * Output and update for function-call system:
 *    '<S1007>/Reset'
 *    '<S1014>/Reset'
 */
void Model_Target_Reset_l(real32_T rtd_states_f[6])
{
    int32_T i;

    /*  Reset the states DSM to zeros */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/Reset': '<S1009>:1' */
    /* '<S1009>:1:6' states(:) = 0; */
    for (i = 0; i < 6; i++)
    {
        rtd_states_f[i] = 0.0F;
    }
}

/*
 * Output and update for atomic system:
 *    '<S1007>/PoolIirProcess'
 *    '<S1014>/PoolIirProcess'
 */
void Model_Target_PoolIirProcess_n(const real32_T rtu_x[32], uint32_T
    rtu_numStages, const real32_T rtu_coeffs[13], real32_T rtd_states_f[6],
    B_PoolIirProcess_Model_Target_c_T *localB)
{
    real_T stateIdx;
    int32_T i;
    real32_T a2;
    real32_T gain;
    real32_T q;
    real32_T w1;
    real32_T w2;
    real32_T xx;
    real32_T yy;
    uint32_T st;

    /*  Extract configuration information from inputs */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/PoolIirProcess': '<S1008>:1' */
    /* '<S1008>:1:5' [frame_size, num_channels] = size(x); */
    /*  Initialize variables */
    /*  Typecast the variables */
    /* '<S1008>:1:11' frame_size = uint32(frame_size); */
    /* '<S1008>:1:12' num_channels = uint32(num_channels); */
    /* Compute the filter coefficients */
    /* '<S1008>:1:15' y = pooliir(x, frame_size, num_channels, numStages, coeffs, states); */
    /*  We have to use a different state buffer than the one passed in.  Matlab */
    /*  value objects are passed by value, not by reference, so the saving of */
    /*  states here does not work.  The state buffer is still necessary to pass */
    /*  allocate in the calling function and pass here in order to trigger CRL. */
    /*  This double buffering is annoying, however only happens during */
    /*  simulation, not code generation. */
    /*  num_states = (length(coeffs) - numChannels) / 2; */
    /*  persistent states; */
    /*  if isempty(states) */
    /*      states = single(zeros(1, num_states)); */
    /*  end */
    /* 'pooliir:15' stateIdx = 1; */
    /* 'pooliir:16' coeffIdx = 1; */
    /* 'pooliir:18' frameMinus1  = frameSize-1; */
    /*  number of samples minus one */
    /* 'pooliir:19' y     = coder.nullcopy(x); */
    /*  output matrix */
    /*  OUTER LOOP over all channels                  */
    /* 'pooliir:22' for cha = 1:numChannels */
    /*  FIRST STAGE */
    /*  prologue: get coefficients, states and input vector  */
    /*  and perform some computations */
    /* 'pooliir:28' w1 = states(stateIdx); */
    /* 'pooliir:28' stateIdx = stateIdx+1; */
    /* 'pooliir:29' gain = coeffs(coeffIdx); */
    gain = rtu_coeffs[0];

    /* 'pooliir:29' coeffIdx = coeffIdx+1; */
    /* 'pooliir:30' w2 = states(stateIdx); */
    w2 = rtd_states_f[1];

    /* 'pooliir:30' stateIdx = stateIdx-1; */
    /* 'pooliir:31' a2   = coeffs(coeffIdx); */
    a2 = rtu_coeffs[1];

    /* 'pooliir:31' coeffIdx = coeffIdx+1; */
    /* 'pooliir:32' xx  = x(1,cha); */
    /* 'pooliir:32' a1   = coeffs(coeffIdx); */
    /* 'pooliir:32' coeffIdx = coeffIdx+1; */
    /* 'pooliir:33' xx  = xx*gain; */
    xx = rtu_x[0] * rtu_coeffs[0];

    /* 'pooliir:33' b2   = coeffs(coeffIdx); */
    /* 'pooliir:33' coeffIdx = coeffIdx+1; */
    /* 'pooliir:34' yy  = w1+xx; */
    yy = rtd_states_f[0] + xx;

    /* 'pooliir:34' b1   = coeffs(coeffIdx); */
    /* 'pooliir:34' coeffIdx = coeffIdx+1; */
    /* 'pooliir:35' w1  = b1*xx; */
    w1 = rtu_coeffs[4] * xx;

    /*  main loop: 5 ops/sample */
    /* 'pooliir:38' i = 1; */
    /* 'pooliir:39' while i <= frameMinus1 */
    for (i = 0; i < 31; i++)
    {
        /* 'pooliir:40' r  = a1*yy; */
        /* 'pooliir:40' w1 = w1+w2; */
        w1 += w2;

        /* 'pooliir:40' y(i,cha) = yy; */
        localB->y[i] = yy;

        /* 'pooliir:41' q  = b2*xx; */
        q = rtu_coeffs[3] * xx;

        /* 'pooliir:41' w1 = w1-r; */
        /* 'pooliir:41' xx = x(i+1,cha); */
        /* 'pooliir:42' xx = xx*gain; */
        xx = rtu_x[i + 1] * gain;

        /* 'pooliir:43' w2 = a2*yy; */
        w2 = a2 * yy;

        /* 'pooliir:43' yy = w1+xx; */
        yy = (w1 - rtu_coeffs[2] * yy) + xx;

        /* 'pooliir:44' w1 = b1*xx; */
        w1 = rtu_coeffs[4] * xx;

        /* 'pooliir:44' w2 = q-w2; */
        w2 = q - w2;

        /* 'pooliir:44' i = i + 1; */
    }

    /*  epilogue: drain pipe and write states */
    /* 'pooliir:48' r  = a1*yy; */
    /* 'pooliir:48' w1 = w1+w2; */
    /* 'pooliir:48' y(frameMinus1+1,cha) = yy; */
    localB->y[31] = yy;

    /* 'pooliir:49' q  = b2*xx; */
    /* 'pooliir:49' w1 = w1-r; */
    rtd_states_f[0] = (w1 + w2) - rtu_coeffs[2] * yy;

    /* 'pooliir:50' w2 = a2*yy; */
    /* 'pooliir:50' states(stateIdx) = w1; */
    /* 'pooliir:50' stateIdx = stateIdx+1; */
    /* 'pooliir:51' w2 = q-w2; */
    rtd_states_f[1] = rtu_coeffs[3] * xx - rtu_coeffs[1] * yy;

    /* 'pooliir:51' states(stateIdx) = w2; */
    /* 'pooliir:51' stateIdx = stateIdx+1; */
    stateIdx = 3.0;

    /*  NOTE: asm implementation needs to exit here if it's only */
    /*  one stage, NOTE: all subsequent stages work in-place */
    /* 'pooliir:55' for st = 2:numStages(cha) */
    for (st = 2U; st <= rtu_numStages; st++)
    {
        real_T a2_tmp;
        real_T stateIdx_0;
        real32_T w1_tmp;

        /*  prologue: get coefficients, states and input vector,  */
        /*  and perform some computations */
        /* 'pooliir:58' w1 = states(stateIdx); */
        w1 = rtd_states_f[(int32_T)stateIdx - 1];

        /* 'pooliir:58' stateIdx = stateIdx+1; */
        stateIdx_0 = stateIdx + 1.0;

        /* 'pooliir:59' a2 = coeffs(coeffIdx); */
        a2_tmp = ((real_T)st - 2.0) * 4.0 + 6.0;
        a2 = rtu_coeffs[(int32_T)a2_tmp - 1];

        /* 'pooliir:59' coeffIdx = coeffIdx+1; */
        /* 'pooliir:60' w2 = states(stateIdx); */
        w2 = rtd_states_f[(int32_T)(stateIdx + 1.0) - 1];

        /* 'pooliir:60' stateIdx = stateIdx-1; */
        stateIdx = (stateIdx + 1.0) - 1.0;

        /* 'pooliir:61' a1 = coeffs(coeffIdx); */
        gain = rtu_coeffs[(int32_T)(a2_tmp + 1.0) - 1];

        /* 'pooliir:61' coeffIdx = coeffIdx+1; */
        /* 'pooliir:62' xx = y(1,cha); */
        xx = localB->y[0];

        /* 'pooliir:62' b2 = coeffs(coeffIdx); */
        /* 'pooliir:62' coeffIdx = coeffIdx+1; */
        /* 'pooliir:63' yy = w1+xx; */
        yy = w1 + localB->y[0];

        /* 'pooliir:63' b1 = coeffs(coeffIdx); */
        /* 'pooliir:63' coeffIdx = coeffIdx+1; */
        /* 'pooliir:64' w1 = b1*xx; */
        w1_tmp = rtu_coeffs[(int32_T)(((a2_tmp + 1.0) + 1.0) + 1.0) - 1];
        w1 = w1_tmp * localB->y[0];

        /*  main loop: 4 ops/sample */
        /* 'pooliir:67' i = 1; */
        /* 'pooliir:68' while i <= frameMinus1 */
        for (i = 0; i < 31; i++)
        {
            /* 'pooliir:69' r  = a1*yy; */
            /* 'pooliir:69' w1 = w1+w2; */
            w1 += w2;

            /* 'pooliir:69' y(i,cha) = yy; */
            localB->y[i] = yy;

            /* 'pooliir:70' q  = b2*xx; */
            q = rtu_coeffs[(int32_T)((a2_tmp + 1.0) + 1.0) - 1] * xx;

            /* 'pooliir:70' w1 = w1-r ; */
            /* 'pooliir:70' xx = y(i+1,cha); */
            xx = localB->y[i + 1];

            /* 'pooliir:71' w2 = a2*yy; */
            w2 = a2 * yy;

            /* 'pooliir:71' yy = w1+xx; */
            yy = (w1 - gain * yy) + xx;

            /* 'pooliir:72' w1 = b1*xx; */
            w1 = w1_tmp * xx;

            /* 'pooliir:72' w2 = q-w2; */
            w2 = q - w2;

            /* 'pooliir:72' i = i + 1; */
        }

        /*  epilogue: drain pipe and write states */
        /* 'pooliir:76' r  = a1*yy; */
        /* 'pooliir:76' w1 = w1+w2; */
        /* 'pooliir:76' y(frameMinus1+1,cha) = yy; */
        localB->y[31] = yy;

        /* 'pooliir:77' q  = b2*xx; */
        /* 'pooliir:77' w1 = w1-r; */
        rtd_states_f[(int32_T)(stateIdx_0 - 1.0) - 1] = (w1 + w2) - gain * yy;

        /* 'pooliir:78' w2 = a2*yy; */
        /* 'pooliir:78' states(stateIdx) = w1; */
        /* 'pooliir:78' stateIdx = stateIdx+1; */
        /* 'pooliir:79' w2 = q-w2; */
        rtd_states_f[(int32_T)(stateIdx + 1.0) - 1] = rtu_coeffs[(int32_T)
            ((a2_tmp + 1.0) + 1.0) - 1] * xx - a2 * yy;

        /* 'pooliir:79' states(stateIdx) = w2; */
        /* 'pooliir:79' stateIdx = stateIdx+1; */
        stateIdx = (stateIdx + 1.0) + 1.0;
    }
}

/*
 * System initialize for atomic system:
 *    '<S1079>/InnerLink'
 *    '<S1092>/InnerLink'
 */
void Model_Target_InnerLink_i_Init(DW_InnerLink_Model_Target_g_T *localDW)
{
    localDW->holdFlag = 1.0;
}

/*
 * Output and update for atomic system:
 *    '<S1079>/InnerLink'
 *    '<S1092>/InnerLink'
 */
void Model_Target_InnerLink_p(real32_T rtu_rmsInput, real32_T rtu_peakInput,
    real32_T rtu_predictionDbspl, real32_T rtu_slowDecayDbPerSample, real32_T
    rtu_holdMarginDb, real32_T rtu_holdTimeSamples, real32_T
    rtu_fastDecayDbPerSample, real32_T rtu_minVolumeDb, real32_T rtu_maxVolumeDb,
    real32_T rtu_volumeDb, real_T rtu_AnnTrigger, real32_T rtu_mode1,
    B_InnerLink_Model_Target_b_T *localB, DW_InnerLink_Model_Target_g_T *localDW)
{
    real32_T input1;
    input1 = rtu_rmsInput;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'LevelDetector': '<S1083>:1' */
    /*  States */
    /* '<S1083>:1:11' if (isempty(holdFlag)) */
    if (!localDW->holdFlag_not_empty)
    {
        /* '<S1083>:1:12' holdFlag = 1; */
        localDW->holdFlag_not_empty = true;

        /* '<S1083>:1:13' holdState = 0; */
        /* '<S1083>:1:14' envelope1 = -abs(minVolumeDb); */
        localDW->envelope1 = -qhmath_abs_f(rtu_minVolumeDb);
    }

    /*  By default we use the RMS input */
    /* '<S1083>:1:18' input1 = rmsInput; */
    /* '<S1083>:1:19' level = single(0.0); */
    localB->level = 0.0F;

    /* '<S1083>:1:21' if mode1 >= 0.0 */
    if (rtu_mode1 >= 0.0F)
    {
        real32_T delta;

        /*  Choose input1 based on mode1 */
        /* '<S1083>:1:23' if (mode1 > 0.0) */
        if (rtu_mode1 > 0.0F)
        {
            /* '<S1083>:1:24' input1 = peakInput; */
            input1 = rtu_peakInput;
        }

        /* '<S1083>:1:26' delta = single( envelope1 - input1 ); */
        delta = localDW->envelope1 - input1;

        /* '<S1083>:1:27' if ( delta <= single(0) ) */
        if (delta <= 0.0F)
        {
            /*  Attack phase */
            /* '<S1083>:1:29' envelope1 = input1; */
            localDW->envelope1 = input1;

            /* '<S1083>:1:30' holdState = 0; */
            localDW->holdState = 0.0;

            /* '<S1083>:1:31' holdFlag = 1; */
            localDW->holdFlag = 1.0;
        }
        else
        {
            /* '<S1083>:1:32' else */
            /*  Slow Decay phase */
            /* '<S1083>:1:34' coef = slowDecayDbPerSample; */
            input1 = rtu_slowDecayDbPerSample;

            /*  Hold phase */
            /* '<S1083>:1:37' if ( delta >= holdMarginDb ) */
            if (delta >= rtu_holdMarginDb)
            {
                /* '<S1083>:1:38' holdState = holdState + 1; */
                localDW->holdState++;

                /* '<S1083>:1:39' if ( holdState > holdTimeSamples ) */
                if (localDW->holdState > rtu_holdTimeSamples)
                {
                    /* '<S1083>:1:40' holdFlag = 0; */
                    localDW->holdFlag = 0.0;
                }
            }
            else
            {
                /* '<S1083>:1:42' else */
                /* '<S1083>:1:43' holdState = 0; */
                localDW->holdState = 0.0;
            }

            /*  Fast decay phase */
            /* '<S1083>:1:47' if holdFlag == 0 */
            if (localDW->holdFlag == 0.0)
            {
                /* '<S1083>:1:48' coef = fastDecayDbPerSample; */
                input1 = rtu_fastDecayDbPerSample;
            }

            /*  Super fast decay phase */
            /* '<S1083>:1:52' if ( AnnTrigger > AnnTriggerThreshold ) */
            if (rtu_AnnTrigger > 0.5)
            {
                /* '<S1083>:1:53' coef = SuperFastDecayMultiplier * fastDecayDbPerSample; */
                input1 = Model_Target_SuperFastDecayMultiplier_k *
                    rtu_fastDecayDbPerSample;
            }

            /*  Update the envelope1 */
            /* '<S1083>:1:57' envelope1 = envelope1 + coef; */
            localDW->envelope1 += input1;
        }

        /*  Boundary Check */
        /* '<S1083>:1:60' envelope1 = max(minVolumeDb, envelope1); */
        localDW->envelope1 = fmaxf(rtu_minVolumeDb, localDW->envelope1);

        /* '<S1083>:1:61' envelope1 = min(maxVolumeDb, envelope1); */
        localDW->envelope1 = fminf(rtu_maxVolumeDb, localDW->envelope1);

        /*  dBSPL Conversion */
        /* '<S1083>:1:64' level = max(0, envelope1 + predictionDbspl + volumeDb); */
        localB->level = fmaxf(0.0F, (localDW->envelope1 + rtu_predictionDbspl) +
                              rtu_volumeDb);
    }
}

/* Output and update for function-call system: '<S1113>/lookup db from index' */
void Model_Target_lookupdbfromindex(const uint32_T rtu_volTableIdx[8], const
    real32_T rtu_volTabledB[8], uint32_T rtu_idx, int32_T rtu_db_offset,
    real32_T rtu_maxgain, B_lookupdbfromindex_Model_Target_T *localB)
{
    int32_T db_offset;
    int32_T tmp;
    real32_T percent;
    uint32_T idx;
    uint8_T j;
    boolean_T exitg1;
    idx = rtu_idx;
    db_offset = rtu_db_offset;

    /*  */
    /*  Lookup volume table  */
    /*  Output Gain vlue from table */
    /*  */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Volume/Index2DbTable/lookup db from index': '<S1121>:1' */
    /* '<S1121>:1:8' j = uint8(1); */
    j = 1U;

    /* '<S1121>:1:9' gain_value = single(0.0); */
    localB->gain_value = 0.0F;

    /* '<S1121>:1:10' interpolated_gain_dB=single(0.0); */
    /* '<S1121>:1:11' interpolated_gain_dB_with_offset=single(0.0); */
    /*  workaround to type problem */
    /* '<S1121>:1:14' idx = cast(idx, class(volTableIdx(end))); */
    /*   bounds checking for vol - clip to max idx */
    /* '<S1121>:1:17' if (idx > volTableIdx(end)) */
    if (rtu_idx > rtu_volTableIdx[7])
    {
        /* '<S1121>:1:18' idx = volTableIdx(end); */
        idx = rtu_volTableIdx[7];
    }

    /*   bounds checking for gain offset(No Boost) - clip to max offset level */
    /* '<S1121>:1:21' if (db_offset > int32(maxgain)) */
    percent = roundf(rtu_maxgain);
    if (percent < 2.14748365E+9F)
    {
        if (percent >= -2.14748365E+9F)
        {
            tmp = (int32_T)percent;
        }
        else
        {
            tmp = MIN_int32_T;
        }
    }
    else
    {
        tmp = MAX_int32_T;
    }

    if (rtu_db_offset > tmp)
    {
        /* '<S1121>:1:22' db_offset = int32(maxgain); */
        if (percent < 2.14748365E+9F)
        {
            if (percent >= -2.14748365E+9F)
            {
                db_offset = (int32_T)percent;
            }
            else
            {
                db_offset = MIN_int32_T;
            }
        }
        else
        {
            db_offset = MAX_int32_T;
        }
    }

    /* '<S1121>:1:24' if (db_offset < int32(-10.0)) */
    if (db_offset < -10)
    {
        /* '<S1121>:1:25' db_offset = int32(-10.0); */
        db_offset = -10;
    }

    /*  search through volume table to find index closest to vol */
    /* '<S1121>:1:29' while (j <= numel(volTableIdx)) */
    exitg1 = false;
    while ((!exitg1) && (j <= 8))
    {
        uint32_T q0;

        /* '<S1121>:1:30' if (idx <= volTableIdx(j)) */
        q0 = rtu_volTableIdx[j - 1];
        if (idx <= q0)
        {
            /* '<S1121>:1:31' if (j <= 1) */
            if (j <= 1)
            {
                /*  first indexed value is linearly interpolated to zero */
                /* '<S1121>:1:32' if (volTableIdx(j)) */
                if (rtu_volTableIdx[0] != 0U)
                {
                    /* '<S1121>:1:33' percent = single(idx) / single(volTableIdx(j)); */
                    percent = qhmath_div_f((real32_T)idx, (real32_T)
                                           rtu_volTableIdx[0]);
                }
                else
                {
                    /* '<S1121>:1:34' else */
                    /* '<S1121>:1:35' percent = single(1); */
                    percent = 1.0F;
                }

                /* '<S1121>:1:37' gain_value = percent * 10 ^ ( (volTabledB(j)+ single(db_offset)) / 20); */
                localB->gain_value = qhmath_pow_f(10.0F, qhmath_div_f
                    (rtu_volTabledB[0] + (real32_T)db_offset, 20.0F)) * percent;
            }
            else
            {
                uint32_T qY;
                uint32_T qY_tmp;

                /* '<S1121>:1:38' else */
                /*  other values are interpolated in db space */
                /* '<S1121>:1:39' lastIdx = volTableIdx(j-1); */
                /* '<S1121>:1:40' percent = single(idx - lastIdx) / single(volTableIdx(j) - lastIdx); */
                /* '<S1121>:1:41' interpolated_gain_dB = (percent * (volTabledB(j) - volTabledB(j-1) ) ) + volTabledB(j-1); */
                /* '<S1121>:1:42' interpolated_gain_dB_with_offset= interpolated_gain_dB + single(db_offset); */
                /* '<S1121>:1:43' gain_value = 10 ^ ( (interpolated_gain_dB_with_offset) / 20); */
                qY_tmp = rtu_volTableIdx[j - 2];
                qY = idx - /*MW:OvSatOk*/ qY_tmp;
                if (qY > idx)
                {
                    qY = 0U;
                }

                idx = q0 - /*MW:OvSatOk*/ qY_tmp;
                if (idx > q0)
                {
                    idx = 0U;
                }

                percent = rtu_volTabledB[j - 2];
                localB->gain_value = qhmath_pow_f(10.0F, qhmath_div_f
                    (((rtu_volTabledB[j - 1] - percent) * qhmath_div_f((real32_T)
                    qY, (real32_T)idx) + percent) + (real32_T)db_offset, 20.0F));
            }

            exitg1 = true;
        }
        else
        {
            /* '<S1121>:1:46' else */
            /* '<S1121>:1:47' j = j + 1; */
            j++;
        }
    }
}

/* Output and update for function-call system: '<S666>/ramp parameters' */
void Model_Target_rampparameters(uint32_T rtu_rampRateRTC, uint32_T
    rtu_rampTimeRTC, real32_T rtu_rampTimeTune, B_rampparameters_Model_Target_T *
    localB)
{
    real32_T y;
    y = rtu_rampTimeTune;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Volume/ramp parameters': '<S1118>:1' */
    /*  Ramp time and rate are provided to the block through RTC messages. However  */
    /*  in case neither of them are provided, the block will use the default ramp  */
    /*  time given in the tune variables. */
    /* '<S1118>:1:9' ramptime = single(rampTimeTune); */
    /* '<S1118>:1:10' rampRate = single(0); */
    localB->rampRate = 0.0F;

    /* '<S1118>:1:12' if (rampRateRTC) */
    if (rtu_rampRateRTC != 0U)
    {
        /* '<S1118>:1:13' rampRate = single(rampRateRTC); */
        /* '<S1118>:1:14' rampRate = max(rampRateBounds(1), rampRate); */
        /* '<S1118>:1:15' rampRate = min(rampRateBounds(2), rampRate); */
        localB->rampRate = fminf(50000.0F, fmaxf(5.0F, (real32_T)rtu_rampRateRTC));
    }

    /* '<S1118>:1:17' if (rampTimeRTC) */
    if (rtu_rampTimeRTC != 0U)
    {
        /* '<S1118>:1:18' ramptime = single(rampTimeRTC); */
        y = (real32_T)rtu_rampTimeRTC;
    }

    /* '<S1118>:1:20' ramptime = max(rampTimeBounds(1), ramptime); */
    /* '<S1118>:1:21' ramptime = min(rampTimeBounds(2), ramptime); */
    localB->ramptime = fminf(3000.0F, fmaxf(1.0F, y));
}

/*
 * Output and update for function-call system:
 *    '<S1129>/SetDsm'
 *    '<S1129>/SetDsm1'
 */
void Model_Target_SetDsm_gr(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S1132>/Data Store Write' incorporates:
     *  Constant: '<S1132>/Constant'
     */
    Model_TargetControlDsms.PreAmpVolumeCfgFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1129>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol_h(real32_T rtu_target_gains_linear,
    real32_T rtu_db_per_sec, real32_T rtu_ramp_times_ms, real32_T
    rtu_sample_rate_in_hertz, real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S1134>:1' */
    /* '<S1134>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S1134>:1:23' numGains = numel(target_gains_linear); */
    /* '<S1134>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S1134>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S1134>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.PreAmpVolumeCfgRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S1134>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S1134>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = rtu_ramp_times_ms;

        /* '<S1134>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S1134>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain,
             5.0118723E-7F);

        /* '<S1134>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S1134>:1:49' if (ramp_dbPerSec) */
        if (rtu_db_per_sec != 0.0F)
        {
            /* '<S1134>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S1134>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S1134>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S1134>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)),
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S1134>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S1134>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S1134>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S1134>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S1134>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S1134>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.PreAmpVolumeCfgRampers.rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain, currentGain)),
                          qhmath_div_f(numFrames * quantum_ms *
               rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S1134>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.PreAmpVolumeCfgRampers.frameCount = (int32_T)
            numFrames;

        /* '<S1134>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S1134>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S1134>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain = currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S1114>/REQ' */
void HandleReqPreAmpVolumeCfgSet(void)
{
    /* MATLAB Function: '<S1113>/lookup db from index' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1125>:1' */
    /* '<S1125>:1:3' go(); */
    Model_Target_lookupdbfromindex(&(Model_Target_PreAmp0.VolumeCfgTable_Idx[0]),
        &(Model_Target_PreAmp0.VolumeCfgTable_dB[0]),
        Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_index,
        Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_offset,
        Model_Target_PreAmp0.VolumeCfgmaxgain,
        &Model_Target_B.sf_lookupdbfromindex);

    /* MATLAB Function: '<S666>/ramp parameters' */
    Model_Target_rampparameters
        (Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_PreAmp0.VolumeCfgRampTime,
         &Model_Target_B.sf_rampparameters);

    /* Outputs for Function Call SubSystem: '<S1129>/SetDsm' */
    Model_Target_SetDsm_gr(1U);

    /* End of Outputs for SubSystem: '<S1129>/SetDsm' */

    /* MATLAB Function: '<S1129>/rgainy ramper control' */
    /* MATLAB Function: '<S1129>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S1129>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol_h
        (Model_Target_B.sf_lookupdbfromindex.gain_value,
         Model_Target_B.sf_rampparameters.rampRate,
         Model_Target_B.sf_rampparameters.ramptime, 44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S1129>/SetDsm1' */
    Model_Target_SetDsm_gr(0U);

    /* End of Outputs for SubSystem: '<S1129>/SetDsm1' */
}

/* Output and update for atomic system: '<S1128>/rgainy process' */
void Model_Target_rgainyprocess_k(const uint8_T rtu_rampToChanMap[3], const
    real32_T rtu_audioIn[64], B_rgainyprocess_Model_Target_g_T *localB)
{
    int32_T b_tmp;
    int32_T chanCount;
    int32_T n;
    real32_T gain;
    real32_T k;
    uint8_T d;
    uint8_T noRampChannel;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S1131>:1' */
    /*  set the size of the output buffer */
    /* '<S1131>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S1131>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S1131>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut[0] = 1.0F;
    localB->gainOut[1] = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S1131>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S1131>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S1131>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S1131>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain;

    /* '<S1131>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.PreAmpVolumeCfgFreeze == 0U)
    {
        /* '<S1131>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.PreAmpVolumeCfgRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S1131>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.PreAmpVolumeCfgRampers.targetGain;
        }
        else
        {
            /* '<S1131>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S1131>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.PreAmpVolumeCfgRampers.rampCoeff;

            /* '<S1131>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.PreAmpVolumeCfgRampers.frameCount =
                Model_TargetControlDsms.PreAmpVolumeCfgRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S1131>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S1131>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S1131>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        for (chanCount = 0; chanCount < b_tmp; chanCount++)
        {
            int32_T audioOut_tmp;

            /* '<S1131>:1:38' chanIdx = rampToChanMap(chanIterator + chanCount); */
            /* '<S1131>:1:39' audioOut(n,chanIdx) = audioIn(n,chanIdx) * gain; */
            audioOut_tmp = ((rtu_rampToChanMap[(uint8_T)((uint32_T)chanCount +
                              2U) - 1] - 1) << 5) + n;
            localB->audioOut[audioOut_tmp] = rtu_audioIn[audioOut_tmp] * gain;
        }
    }

    /* '<S1131>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S1131>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S1131>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut[rtu_rampToChanMap[(uint8_T)((uint32_T)n + 2U) - 1] - 1] =
            gain;
    }

    /* '<S1131>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain = gain;

    /* '<S1131>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S1131>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    d = (uint8_T)(rtu_rampToChanMap[0] + 2U);
    for (noRampChannel = d; noRampChannel < 4; noRampChannel++)
    {
        uint8_T chanIdx;

        /* '<S1131>:1:51' chanIdx = rampToChanMap(noRampChannel); */
        chanIdx = rtu_rampToChanMap[noRampChannel - 1];

        /* '<S1131>:1:52' for n=1:frame_size */
        /* '<S1131>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[(chanIdx << 5) + -32], &rtu_audioIn[(chanIdx <<
                5) + -32], sizeof(real32_T) << 5U);
    }
}

/*
 * Output and update for function-call system:
 *    '<S1142>/SetDsm'
 *    '<S1142>/SetDsm1'
 */
void Model_Target_SetDsm_c(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S1144>/Data Store Write' incorporates:
     *  Constant: '<S1144>/Constant'
     */
    Model_TargetControlDsms.PreAmpBalance_CfgFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1142>/control' */
void Model_Target_control(const real32_T rtu_targetGainLinear[4], real32_T
    rtu_rampdbPerSec, real32_T rtu_rampTimesMs, real32_T rtu_sampleRateInHertz,
    real32_T rtu_frameSize)
{
    real32_T currentGainLinear_idx_0;
    real32_T currentGainLinear_idx_1;
    real32_T currentGainLinear_idx_2;
    real32_T currentGainLinear_idx_3;
    real32_T diff_idx_0;
    real32_T diff_idx_1;
    real32_T diff_idx_2;
    real32_T diff_idx_3;
    real32_T quantumMs;
    real32_T targetGainLinear;
    real32_T targetGainLinear_0;
    real32_T targetGainLinear_1;
    real32_T targetGainLinear_2;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/Balance/Balance/control': '<S1157>:1' */
    /*  CONTROL LOGIC: */
    /*  Shift of 'balance' between the 'Right' and 'Left' channel groups is */
    /*  achieved by multiplying the corresponding 'cut' or 'boost' gain. As the */
    /*  index increases from 0, the balance shifts from left to right. Channels */
    /*  corresponding to the 'center' group are not modified.  */
    /*  rampdbPerSec takes precidence: */
    /*  If dbPerSec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the dbPerSec is used to determine ramper timing. */
    /*  Inputs: */
    /*    targetGainLinear: Indicates the gain (in linear scale) which needs to */
    /*        be applied to the audio. Gain values can be mapped to the ramper */
    /*        configuration. */
    /*    rampTimeMs: Indicates the time in milliseconds in which the gain of the */
    /*        rampers must change from their current to target values. */
    /*    rampdbPerSecond: Indicates the rate in dB/second at which the gain of the */
    /*        rampers must change from their current to target values. If this */
    /*        value is non-zero, it is used to compute the ramp time and */
    /*        'rampTimeMs' is discarded (if specified). */
    /*    rgain_SILENT_GAIN: Parameter defined in the initFcn callback. */
    /*  Control Data: */
    /*    Freeze(1) freezes the processing during this control operation */
    /*    Rampers(1) is the ramper for the 'Left' group. Boost vs. cut  */
    /*         is determined by the value of the balance index. */
    /*    Rampers(2) is the ramper for the 'Right' group. Boost vs. cut is determined by */
    /*         the value of the balance index. */
    /*    Rampers(3) is the ramper for the 'Center' group. Boost vs. cut is determined by */
    /*         the value of the balance index. */
    /*    Rampers(4) is the ramper for the 'Mono' group (supporting "Sleeping */
    /*        Beauty Mutes Bass"). Boost vs. cut is determined by the value of  */
    /*        the balance index. */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /*  This block replaces much of rgainy, but uses its own silent gain value. */
    /*  The reason why is not documented, but it does impact all the test cases. */
    /*  Use this special value instead of RgainBusUtil.GetSilentGainLinear */
    /* '<S1157>:1:46' rgain_SILENT_GAIN = single(10^(-126/20)); */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /*  UPDATE: This will now loop over 4 rampers */
    /* '<S1157>:1:57' currentGainLinear = zeros(1,MaskNumRampers,'single'); */
    /* '<S1157>:1:58' for i = 1:MaskNumRampers */
    /* '<S1157>:1:59' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
    currentGainLinear_idx_0 = fmaxf
        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].currentGain,
         5.0118723E-7F);

    /* '<S1157>:1:60' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
    targetGainLinear = fmaxf(rtu_targetGainLinear[0], 5.0118723E-7F);

    /* '<S1157>:1:59' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
    currentGainLinear_idx_1 = fmaxf
        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].currentGain,
         5.0118723E-7F);

    /* '<S1157>:1:60' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
    targetGainLinear_0 = fmaxf(rtu_targetGainLinear[1], 5.0118723E-7F);

    /* '<S1157>:1:59' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
    currentGainLinear_idx_2 = fmaxf
        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].currentGain,
         5.0118723E-7F);

    /* '<S1157>:1:60' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
    targetGainLinear_1 = fmaxf(rtu_targetGainLinear[2], 5.0118723E-7F);

    /* '<S1157>:1:59' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
    currentGainLinear_idx_3 = fmaxf
        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].currentGain,
         5.0118723E-7F);

    /* '<S1157>:1:60' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
    targetGainLinear_2 = fmaxf(rtu_targetGainLinear[3], 5.0118723E-7F);

    /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
    /*  and instead calculate a new ramp time that matches the slope. */
    /* '<S1157>:1:65' rampMs = zeros(1,MaskNumRampers,'single'); */
    /* '<S1157>:1:66' if (rampdbPerSec) */
    if (rtu_rampdbPerSec != 0.0F)
    {
        /* '<S1157>:1:67' currentGainDb = 20*log10(currentGainLinear); */
        /* '<S1157>:1:68' targetGainDb = 20*log10(targetGainLinear); */
        /* '<S1157>:1:69' diff = abs(currentGainDb - targetGainDb); */
        /* '<S1157>:1:70' rampMs = diff / single(rampdbPerSec) * 1000; */
        diff_idx_0 = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
            (currentGainLinear_idx_0) - 20.0F * qhmath_log10_f(targetGainLinear)),
            rtu_rampdbPerSec) * 1000.0F;
        diff_idx_1 = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
            (currentGainLinear_idx_1) - 20.0F * qhmath_log10_f
            (targetGainLinear_0)), rtu_rampdbPerSec) * 1000.0F;
        diff_idx_2 = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
            (currentGainLinear_idx_2) - 20.0F * qhmath_log10_f
            (targetGainLinear_1)), rtu_rampdbPerSec) * 1000.0F;
        diff_idx_3 = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
            (currentGainLinear_idx_3) - 20.0F * qhmath_log10_f
            (targetGainLinear_2)), rtu_rampdbPerSec) * 1000.0F;
    }
    else
    {
        /* '<S1157>:1:71' else */
        /* '<S1157>:1:72' rampMs(:) = single(rampTimesMs); */
        diff_idx_0 = rtu_rampTimesMs;
        diff_idx_1 = rtu_rampTimesMs;
        diff_idx_2 = rtu_rampTimesMs;
        diff_idx_3 = rtu_rampTimesMs;
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1157>:1:79' quantumMs = 1000 * frameSize / sampleRateInHertz; */
    quantumMs = qhmath_div_f(1000.0F * rtu_frameSize, rtu_sampleRateInHertz);

    /* '<S1157>:1:80' numFrames = rampMs / quantumMs; */
    /* '<S1157>:1:81' numFrames = max (1, ceil(numFrames)); */
    /* '<S1157>:1:82' quantizedRampTimeMs = numFrames * quantumMs; */
    /*  UPDATE: Loop over 4 rampers now (L, R, C, and Mono) */
    /* '<S1157>:1:85' for ramper=1:MaskNumRampers */
    diff_idx_0 = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(diff_idx_0, quantumMs)));

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1157>:1:98' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
    /* '<S1157>:1:99' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
    /*  Output control signals */
    /* '<S1157>:1:102' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].frameCount = (int32_T)
        diff_idx_0;

    /* '<S1157>:1:103' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].targetGain =
        targetGainLinear;

    /* '<S1157>:1:104' Rampers(ramper).rampCoeff = single(RampCoef); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].rampCoeff = qhmath_exp_f
        (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGainLinear,
            currentGainLinear_idx_0)), qhmath_div_f(diff_idx_0 * quantumMs *
           rtu_sampleRateInHertz, 1000.0F)));

    /* '<S1157>:1:105' Rampers(ramper).currentGain = currentGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].currentGain =
        currentGainLinear_idx_0;
    diff_idx_0 = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(diff_idx_1, quantumMs)));

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1157>:1:98' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
    /* '<S1157>:1:99' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
    /*  Output control signals */
    /* '<S1157>:1:102' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].frameCount = (int32_T)
        diff_idx_0;

    /* '<S1157>:1:103' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].targetGain =
        targetGainLinear_0;

    /* '<S1157>:1:104' Rampers(ramper).rampCoeff = single(RampCoef); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].rampCoeff = qhmath_exp_f
        (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGainLinear_0,
            currentGainLinear_idx_1)), qhmath_div_f(diff_idx_0 * quantumMs *
           rtu_sampleRateInHertz, 1000.0F)));

    /* '<S1157>:1:105' Rampers(ramper).currentGain = currentGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].currentGain =
        currentGainLinear_idx_1;
    diff_idx_0 = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(diff_idx_2, quantumMs)));

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1157>:1:98' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
    /* '<S1157>:1:99' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
    /*  Output control signals */
    /* '<S1157>:1:102' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].frameCount = (int32_T)
        diff_idx_0;

    /* '<S1157>:1:103' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].targetGain =
        targetGainLinear_1;

    /* '<S1157>:1:104' Rampers(ramper).rampCoeff = single(RampCoef); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].rampCoeff = qhmath_exp_f
        (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGainLinear_1,
            currentGainLinear_idx_2)), qhmath_div_f(diff_idx_0 * quantumMs *
           rtu_sampleRateInHertz, 1000.0F)));

    /* '<S1157>:1:105' Rampers(ramper).currentGain = currentGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].currentGain =
        currentGainLinear_idx_2;
    diff_idx_0 = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(diff_idx_3, quantumMs)));

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1157>:1:98' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
    /* '<S1157>:1:99' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
    /*  Output control signals */
    /* '<S1157>:1:102' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].frameCount = (int32_T)
        diff_idx_0;

    /* '<S1157>:1:103' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].targetGain =
        targetGainLinear_2;

    /* '<S1157>:1:104' Rampers(ramper).rampCoeff = single(RampCoef); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].rampCoeff = qhmath_exp_f
        (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGainLinear_2,
            currentGainLinear_idx_3)), qhmath_div_f(diff_idx_0 * quantumMs *
           rtu_sampleRateInHertz, 1000.0F)));

    /* '<S1157>:1:105' Rampers(ramper).currentGain = currentGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].currentGain =
        currentGainLinear_idx_3;

    /*  unfreeze the gain (This step is done outside on canvas now) */
}

/* Output and update for function-call system: '<S1143>/REQ' */
void HandleReqPreAmpBalance_CfgSet(void)
{
    real32_T targetGains_h[4];
    real32_T boost_linear;
    real32_T cut_linear;
    real32_T left;
    uint8_T j;
    boolean_T exitg1;

    /* MATLAB Function: '<S1142>/calculate_balance_gain' */
    /* MATLAB Function: '<S1142>/calculate_balance_gain' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1161>:1' */
    /* '<S1161>:1:3' go(); */
    /*  Computes the balance gains for the 'left' and 'right' channel groups.  */
    /*  Based on the position of the balance index in 'balanceTableIdx', the  */
    /*  corresponding 'cut' gain is computed from the 'balanceTableDb'. If the  */
    /*  index lies between two entries in the table, the gain is computed by  */
    /*  linear interpolation between the corresponding gain table entries.  */
    /*  The 'boost' gain is computed based from the 'cut' gain depending on the */
    /*  value of the tune variable, 'boostDisable'. If set to '1', boost is 0 dB  */
    /*  and if '0', in order to preserve energy, the boost is computed based on */
    /*  the following equation: Boost^2 + Cut^2 = 2.  */
    /*  If 'silent extreme' is enabled and the index at either extreme is */
    /*  requested, channels belonging to the group which receives a gain 'cut' */
    /*  are muted. */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/Balance/Balance/calculate_balance_gain': '<S1154>:1' */
    /* '<S1154>:1:18' j = uint8(1); */
    j = 1U;

    /* '<S1154>:1:19' cut_linear = single(0.0); */
    cut_linear = 0.0F;

    /* '<S1154>:1:21' targetGains = coder.nullcopy(ones(1,MaskNumRampers,'single')); */
    /* '<S1154>:1:22' balanceIndex = single(balanceIndex); */
    /*  random comment */
    /*  Find the left and the right gains */
    /*  Based on the balance table, the dB value of the index is calculated */
    /* '<S1154>:1:28' while (j <= numel(balanceTableIdx)) */
    exitg1 = false;
    while ((!exitg1) && (j <= 30))
    {
        /* '<S1154>:1:29' if (balanceIndex <= balanceTableIdx(j)) */
        boost_linear = Model_Target_PreAmp0.Balance_CfgTableIdx[j - 1];
        if (Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index <=
                boost_linear)
        {
            /* '<S1154>:1:30' if (j <= 1) */
            if (j <= 1)
            {
                /*  first indexed value is linearly interpolated to zero */
                /* '<S1154>:1:31' if (balanceTableIdx(j)) */
                if (Model_Target_PreAmp0.Balance_CfgTableIdx[0] != 0.0F)
                {
                    /* '<S1154>:1:32' percent = balanceIndex / balanceTableIdx(j); */
                    cut_linear = qhmath_div_f((real32_T)
                        Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index,
                        Model_Target_PreAmp0.Balance_CfgTableIdx[0]);
                }
                else
                {
                    /* '<S1154>:1:33' else */
                    /* '<S1154>:1:34' percent = single(1); */
                    cut_linear = 1.0F;
                }

                /* '<S1154>:1:36' cut_linear = percent * 10 ^ (balanceTableDb(j) / 20); */
                cut_linear *= qhmath_pow_f(10.0F, qhmath_div_f
                    (Model_Target_PreAmp0.Balance_CfgTableDb[0], 20.0F));
            }
            else
            {
                /* '<S1154>:1:37' else */
                /*  other values are interpolated in db space */
                /* '<S1154>:1:38' lastIdx = single(balanceTableIdx(j-1)); */
                /* '<S1154>:1:39' percent = (balanceIndex - lastIdx) / (balanceTableIdx(j) - lastIdx); */
                /* '<S1154>:1:40' cut_linear = 10 ^ (((percent * (balanceTableDb(j) - balanceTableDb(j-1))) + balanceTableDb(j-1)) / 20); */
                cut_linear = Model_Target_PreAmp0.Balance_CfgTableIdx[j - 2];
                left = Model_Target_PreAmp0.Balance_CfgTableDb[j - 2];
                cut_linear = qhmath_pow_f(10.0F, qhmath_div_f
                    ((Model_Target_PreAmp0.Balance_CfgTableDb[j - 1] - left) *
                     qhmath_div_f((real32_T)
                                  Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index
                                  - cut_linear, boost_linear - cut_linear) +
                     left, 20.0F));
            }

            exitg1 = true;
        }
        else
        {
            /* '<S1154>:1:43' else */
            /* '<S1154>:1:44' j = j + 1; */
            j++;
        }
    }

    /*  Boost of > 0 dB is dependant on tuning. If the tune variable is SET (1), */
    /*  boost of 0 dB is applied (i.e. linear value of 1). If the tune variable */
    /*  is RESET (0), a boost of 3 dB is applied */
    /* '<S1154>:1:51' if boostDisable == 0 */
    if (Model_Target_PreAmp0.Balance_CfgBoostDisable == 0.0F)
    {
        /* '<S1154>:1:52' boost_linear = sqrt(2.0 - cut_linear^2); */
        boost_linear = qhmath_sqrt_f(2.0F - cut_linear * cut_linear);
    }
    else
    {
        /* '<S1154>:1:53' else */
        /* '<S1154>:1:54' boost_linear = single(1); */
        boost_linear = 1.0F;
    }

    /*  % if silent extreme is enabled and we're extreme, make the cut complete */
    /*  % (Sleeping Beauty) */
    /* '<S1154>:1:59' if (EnableSilentExtreme && abs(balanceIndex - indexOffset) >= (indexOffset-1)) */
    if ((Model_Target_PreAmp0.Balance_CfgEnableSilentExtreme != 0.0F) &&
            (qhmath_abs_f((real32_T)
                          Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index
                          - Model_Target_PreAmp0.Balance_CfgOffset) >=
             Model_Target_PreAmp0.Balance_CfgOffset - 1.0F))
    {
        /* '<S1154>:1:60' cut_linear = single(0); */
        cut_linear = 0.0F;
    }

    /*  Assign left and right Gain Values */
    /* '<S1154>:1:64' if (balanceIndex - indexOffset) > 0 */
    if ((real32_T)Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index -
            Model_Target_PreAmp0.Balance_CfgOffset > 0.0F)
    {
        /*  Left speakers attenuated */
        /* '<S1154>:1:65' left = single(cut_linear); */
        left = cut_linear;

        /* '<S1154>:1:66' right = single(boost_linear); */
        cut_linear = boost_linear;
    }
    else
    {
        /* '<S1154>:1:67' else */
        /* '<S1154>:1:68' left = single(boost_linear); */
        left = boost_linear;

        /* '<S1154>:1:69' right = single(cut_linear); */
    }

    /*  Assign remaining gain values  */
    /* '<S1154>:1:73' center = (left + right) * 0.5; */
    boost_linear = (left + cut_linear) * 0.5F;

    /* '<S1154>:1:74' mono = center; */
    /*  Number to Content Key */
    /* '<S1154>:1:77' targetGains(1) = left; */
    targetGains_h[0] = left;

    /* '<S1154>:1:78' targetGains(2) = right; */
    targetGains_h[1] = cut_linear;

    /* '<S1154>:1:79' targetGains(3) = center; */
    targetGains_h[2] = boost_linear;

    /* '<S1154>:1:80' targetGains(4) = mono; */
    targetGains_h[3] = boost_linear;

    /*  (Sleeping Beauty) */
    /*  if silent extreme is enabled and we're extreme, cut center freqs */
    /* '<S1154>:1:84' if (EnableSilentExtreme && abs(balanceIndex - indexOffset) >= (indexOffset-1)) */
    if ((Model_Target_PreAmp0.Balance_CfgEnableSilentExtreme != 0.0F) &&
            (qhmath_abs_f((real32_T)
                          Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index
                          - Model_Target_PreAmp0.Balance_CfgOffset) >=
             Model_Target_PreAmp0.Balance_CfgOffset - 1.0F))
    {
        /* '<S1154>:1:85' targetGains(3) = 0; */
        targetGains_h[2] = 0.0F;

        /* '<S1154>:1:86' if (SleepingBeautyMutesBass) */
        if (Model_Target_PreAmp0.Balance_CfgSleepingBeautyMutesBass != 0.0F)
        {
            /* '<S1154>:1:87' targetGains(4) = 0; */
            targetGains_h[3] = 0.0F;
        }
    }

    /* End of MATLAB Function: '<S1142>/calculate_balance_gain' */

    /* MATLAB Function: '<S1142>/calculate_ramp_parameters' */
    /* MATLAB Function: '<S1142>/calculate_ramp_parameters' */
    cut_linear = Model_Target_PreAmp0.Balance_CfgRampTime;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/Balance/Balance/calculate_ramp_parameters': '<S1155>:1' */
    /*  Ramp time and rate are provided to the block through RTC messages. However  */
    /*  in case neither of them are provided, the block will use the default ramp  */
    /*  time given in the tune variables. */
    /* '<S1155>:1:9' ramptime = single(rampTimeTune); */
    /* '<S1155>:1:10' rampRate = single(0); */
    left = 0.0F;

    /* '<S1155>:1:12' if (rampRateRTC) */
    if (Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_db_per_second != 0U)
    {
        /* '<S1155>:1:13' rampRate = single(rampRateRTC); */
        /* '<S1155>:1:14' rampRate = max(rampRateBounds(1), rampRate); */
        /* '<S1155>:1:15' rampRate = min(rampRateBounds(2), rampRate); */
        left = fminf(50000.0F, fmaxf(5.0F, (real32_T)
                      Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_db_per_second));
    }

    /* '<S1155>:1:17' if (rampTimeRTC) */
    if (Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_milliseconds != 0U)
    {
        /* '<S1155>:1:18' ramptime = single(rampTimeRTC); */
        cut_linear = (real32_T)
            Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_milliseconds;
    }

    /* Outputs for Function Call SubSystem: '<S1142>/SetDsm' */
    /* '<S1155>:1:20' ramptime = max(rampTimeBounds(1), ramptime); */
    /* '<S1155>:1:21' ramptime = min(rampTimeBounds(2), ramptime); */
    Model_Target_SetDsm_c(1U);

    /* End of Outputs for SubSystem: '<S1142>/SetDsm' */

    /* MATLAB Function: '<S1142>/control' */
    /* MATLAB Function: '<S1142>/calculate_ramp_parameters' */
    /* MATLAB Function: '<S1142>/control' incorporates:
     *  MATLAB Function: '<S1142>/calculate_ramp_parameters'
     *  S-Function (AudioStats_MEX): '<S1142>/Audio Stats1'
     */
    Model_Target_control(targetGains_h, left, fminf(3000.0F, fmaxf(1.0F,
                           cut_linear)), 44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S1142>/SetDsm1' */
    Model_Target_SetDsm_c(0U);

    /* End of Outputs for SubSystem: '<S1142>/SetDsm1' */
}

/* Output and update for function-call system: '<S1179>/init' */
void InitTrigger_Model_141_246_85_172_156(void)
{
    /* MATLAB Function: '<S1178>/PoolIirInit' */
    /* MATLAB Function: '<S1178>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S1175>/TOP'
     *  S-Function (TOP_MEX): '<S1175>/TOP1'
     *  Selector: '<S1170>/Selector1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1182>:1' */
    /* '<S1182>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1180>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1180>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1180>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1180>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1180>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1180>:1:28' else */
    /* '<S1180>:1:29' switch(VariantStr) */
    /* '<S1180>:1:30' case{"Hexagon"} */
    /* '<S1180>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1180>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1180>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaBassMgrHpf18828states[0], &Model_Target_B.LR_m[0], 32U,
                 2U,
                 &(Model_Target_PreAmp0.MedusaBassManagerHpfPooliirNumStages[0]),
                 &(Model_Target_PreAmp0.MedusaBassManagerHpfpooliirCoeffs[0]),
                 &MedusaBassMgrHpf18828states[0], 65U, 0U, 24U);

    /* '<S1180>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1187>/init' */
void InitTrigger_Model_141_246_91_172_156(void)
{
    /* MATLAB Function: '<S1186>/PoolIirInit' */
    /* MATLAB Function: '<S1186>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S1183>/TOP'
     *  S-Function (TOP_MEX): '<S1183>/TOP1'
     *  Selector: '<S1170>/Selector1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1190>:1' */
    /* '<S1190>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1188>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1188>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1188>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1188>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1188>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1188>:1:28' else */
    /* '<S1188>:1:29' switch(VariantStr) */
    /* '<S1188>:1:30' case{"Hexagon"} */
    /* '<S1188>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1188>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1188>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaBassMgrLpf11643states[0], &Model_Target_B.LR_m[0], 32U,
                 2U,
                 &(Model_Target_PreAmp0.MedusaBassManagerLpfPooliirNumStages[0]),
                 &(Model_Target_PreAmp0.MedusaBassManagerLpfpooliirCoeffs[0]),
                 &MedusaBassMgrLpf11643states[0], 65U, 0U, 24U);

    /* '<S1188>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1201>/init' */
void InitTrigger_Model_141_248_38_65(void)
{
    /* MATLAB Function: '<S1198>/FirEvenInit' */
    /* MATLAB Function: '<S1198>/FirEvenInit' incorporates:
     *  Constant: '<S1172>/Image Rejection Filter Coeffs'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1202>:1' */
    /* '<S1202>:1:3' init(); */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenInit': '<S1199>:1' */
    /* '<S1199>:1:4' [FilterLength, NumFilters] = size(FlippedCoefficients); */
    /* '<S1199>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Simulation */
    /* '<S1199>:1:10' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1199>:1:12' else */
    /* '<S1199>:1:13' y = fireven_hexagon_init(uint32(FrameSize), uint32(NumChannels), uint32(NumFilters), uint32(FilterLength), single(FlippedCoefficients), uint32(CodeWorkMemory), uint32(MaxNumOfThreds)); */
    fireven_init(&MedusaBandSplitImgRejCodeWorkMemory[0], 32U, 2U, 1U, 24U,
                 &Model_Target_ConstP.ImageRejectionFilterCoeffs_Value_p[0],
                 &MedusaBandSplitImgRejCodeWorkMemory[0], 4U);

    /*  NOTE: The CRL mechanism requires an output for the function call, */
    /*  and appears to be optimized out if that return value isn't used.  */
    /*  This is a dummy operation to make sure CRL ends up in generated code */
    /* '<S1199>:1:17' CodeWorkMemory(1) = y; */
}

/* System initialize for atomic system: '<S1137>/Medusa5H1 Part 1' */
void Model_Target_Medusa5H1Part1_Init(void)
{
    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S1179>/ITC1' */
    InitTrigger_Model_141_246_85_172_156();

    /* InitTriggerControl '<S1187>/ITC1' */
    InitTrigger_Model_141_246_91_172_156();

    /* InitTriggerControl '<S1201>/ITC1' */
    InitTrigger_Model_141_248_38_65();

    /* '<S1200>:1:12' States = single(zeros(FilterLength + FrameSize*2 + 2, NumChannels)); */
}

/* Output and update for atomic system: '<S1137>/Medusa5H1 Part 1' */
void Model_Target_Medusa5H1Part1(void)
{
    int32_T i;
    int32_T m;
    int32_T outidx;
    int_T frameIdx;
    real32_T rtb_BandSeparationDelay[64];
    real32_T rtb_ReconstructionFilter[64];
    real32_T y_a[64];

    /* Selector: '<S1170>/Selector1' */
    memcpy(&Model_Target_B.LR_m[0], &Model_Target_B.FRIn[0], sizeof(real32_T) <<
           6U);

    /* End of Outputs for S-Function (InitTriggerControl): '<S1179>/ITC1' */

    /* MATLAB Function: '<S1178>/PoolIirProcess' incorporates:
     *  Selector: '<S1170>/Selector1'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1181>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1181>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S1181>:1:20' VariantStr = char(VariantUint8); */
    /* '<S1181>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1181>:1:29' else */
    /* '<S1181>:1:30' switch(VariantStr) */
    /* '<S1181>:1:31' case{"Hexagon"} */
    /* '<S1181>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&Model_Target_B.LoRoLimpRimp[0], &Model_Target_B.LR_m[0],
                    &MedusaBassMgrHpf18828states[0]);

    /* End of Outputs for S-Function (InitTriggerControl): '<S1187>/ITC1' */

    /* MATLAB Function: '<S1186>/PoolIirProcess' incorporates:
     *  Selector: '<S1170>/Selector1'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1189>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1189>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S1189>:1:20' VariantStr = char(VariantUint8); */
    /* '<S1189>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1189>:1:29' else */
    /* '<S1189>:1:30' switch(VariantStr) */
    /* '<S1189>:1:31' case{"Hexagon"} */
    /* '<S1189>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&Model_Target_B.PreAmp2HeadrestDr[0], &Model_Target_B.LR_m[0],
                    &MedusaBassMgrLpf11643states[0]);

    /* Constant: '<S1191>/Constant3' */
    Model_Target_B.Constant3 = 0;

    /* S-Function (sdspstatfcns): '<S1164>/Mean' */
    outidx = 0;
    for (frameIdx = 0; frameIdx < 32; frameIdx++)
    {
        Model_Target_DW.Mean_AccVal[outidx] = Model_Target_B.FRIn[frameIdx];
        Model_Target_DW.Mean_AccVal[outidx] += Model_Target_B.FRIn[frameIdx + 32];
        Model_Target_B.Mean[outidx] = qhmath_div_f
            (Model_Target_DW.Mean_AccVal[outidx], 2.0F);
        outidx++;
    }

    /* End of S-Function (sdspstatfcns): '<S1164>/Mean' */

    /* Delay: '<S1172>/Band Separation Delay' */
    for (frameIdx = 0; frameIdx < 2; frameIdx++)
    {
        memcpy(&rtb_BandSeparationDelay[frameIdx << 5],
               &Model_Target_DW.BandSeparationDelay_DSTATE[frameIdx * 136],
               sizeof(real32_T) << 5U);
    }

    /* End of Delay: '<S1172>/Band Separation Delay' */

    /* Outputs for Atomic SubSystem: '<S1172>/Ifir' */
    Model_Target_Ifir_e();

    /* End of Outputs for SubSystem: '<S1172>/Ifir' */

    /* MATLAB Function: '<S1198>/FirEvenProcess' incorporates:
     *  Constant: '<S1172>/Constant'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenProcess': '<S1200>:1' */
    /* '<S1200>:1:4' [FilterLength, ~] = size(FlippedCoeffs); */
    /* '<S1200>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Initialize variables */
    /* '<S1200>:1:11' if isempty(States) */
    /*  Set correct data types */
    /* '<S1200>:1:16' FilterLength = uint32(FilterLength); */
    /* '<S1200>:1:17' FrameSize = uint32(FrameSize); */
    /* '<S1200>:1:18' ActiveCoeffSet = uint32(ActiveCoeffSet); */
    /* '<S1200>:1:21' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1200>:1:24' else */
    /*  FIR EVEN HEXAGON */
    /* '<S1200>:1:26' if (FilterLength > FrameSize) */
    /* '<S1200>:1:28' else */
    /* '<S1200>:1:29' y = fireven_hexagon_process_lt(single(u), uint32(ActiveCoeffSet), single(States), uint32(CodeWorkMemory)); */
    fireven_process_lt(&y_a[0], &Model_Target_B.audioOut_ni[0],
                       &Model_Target_ConstP.pooled102[0],
                       &Model_Target_DW.States_l[0],
                       &MedusaBandSplitImgRejCodeWorkMemory[0]);

    /* DownSample: '<S1172>/Downsample' */
    for (i = 0; i < 16; i++)
    {
        Model_Target_B.Downsample[i] = y_a[i << 2];
    }

    /* End of DownSample: '<S1172>/Downsample' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1201>/ITC1' */

    /* S-Function (sdspupfir2): '<S1172>/Reconstruction Filter' incorporates:
     *  DownSample: '<S1172>/Downsample'
     */
    /* Loop over each input channel */
    for (outidx = 0; outidx < 2; outidx++)
    {
        int32_T dataInArrayIdx;
        int32_T dataOutArrayIdx;
        int32_T delayBuffIdx;
        delayBuffIdx = outidx * 34;
        dataInArrayIdx = outidx << 3;
        dataOutArrayIdx = dataInArrayIdx << 2;
        for (m = 0; m < 4; m++)
        {
            int32_T coefArrayIdx;
            int32_T oIdx;
            oIdx = dataOutArrayIdx + m;
            coefArrayIdx = m * 35;

            /* Consume delay line and beginning of input samples */
            for (i = 0; i < 8; i++)
            {
                real32_T accumulator;
                accumulator = 0.0F;
                for (frameIdx = 0; frameIdx < i + 1; frameIdx++)
                {
                    accumulator += Model_Target_B.Downsample[(dataInArrayIdx + i)
                        - frameIdx] * Model_Target_ConstP.pooled74[coefArrayIdx
                        + frameIdx];
                }

                for (frameIdx = 0; frameIdx < 34 - i; frameIdx++)
                {
                    accumulator += Model_Target_ConstP.pooled74[((coefArrayIdx +
                        i) + frameIdx) + 1] *
                        Model_Target_DW.ReconstructionFilter_TapDelayBuff[delayBuffIdx
                        + frameIdx];
                }

                rtb_ReconstructionFilter[oIdx] = accumulator;
                oIdx += 4;
            }
        }

        /* Update delay line for next frame */
        for (i = delayBuffIdx + 25; i >= delayBuffIdx; i--)
        {
            Model_Target_DW.ReconstructionFilter_TapDelayBuff[i + 8] =
                Model_Target_DW.ReconstructionFilter_TapDelayBuff[i];
        }

        for (i = 0; i < 8; i++)
        {
            Model_Target_DW.ReconstructionFilter_TapDelayBuff[(delayBuffIdx - i)
                + 7] = Model_Target_B.Downsample[dataInArrayIdx + i];
        }
    }

    /* End of S-Function (sdspupfir2): '<S1172>/Reconstruction Filter' */

    /* Sum: '<S1172>/Sum' incorporates:
     *  Delay: '<S1172>/Band Separation Delay'
     *  S-Function (sdspupfir2): '<S1172>/Reconstruction Filter'
     */
    for (i = 0; i < 64; i++)
    {
        Model_Target_B.Sum[i] = rtb_BandSeparationDelay[i] -
            rtb_ReconstructionFilter[i];
    }

    /* End of Sum: '<S1172>/Sum' */
    /* Update for M-S-Function: '<S1192>/TSP' incorporates:
     *  Constant: '<S1191>/Constant'
     */
    // TSP advanced triggered capture for PreAmpMedusaDummyState '<S1192>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 52, &Model_Target_ConstP.pooled33);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for Delay: '<S1172>/Band Separation Delay' */
    for (i = 0; i < 2; i++)
    {
        for (frameIdx = 0; frameIdx < 104; frameIdx++)
        {
            outidx = i * 136 + frameIdx;
            Model_Target_DW.BandSeparationDelay_DSTATE[outidx] =
                Model_Target_DW.BandSeparationDelay_DSTATE[outidx + 32];
        }
    }

    memcpy(&rtb_BandSeparationDelay[0], &Model_Target_B.LoRoLimpRimp[0], sizeof
           (real32_T) << 6U);
    for (frameIdx = 0; frameIdx < 2; frameIdx++)
    {
        memcpy(&Model_Target_DW.BandSeparationDelay_DSTATE[frameIdx * 136 + 104],
               &rtb_BandSeparationDelay[frameIdx << 5], sizeof(real32_T) << 5U);
    }

    /* End of Update for Delay: '<S1172>/Band Separation Delay' */
}

/* Output and update for atomic system: '<S1165>/Alignment Delay' */
void Model_Target_AlignmentDelay(void)
{
    int32_T bufferIndex;
    int32_T channel;
    int32_T sample;
    int32_T writeIndex;

    /* MATLAB Function: '<S1209>/MATLAB Function' incorporates:
     *  Sum: '<S1172>/Sum'
     */
    /* [Param:maxDelay] */
    /* MATLAB Function 'MedusaAlignmentDelay/MATLAB Function': '<S1210>:1' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /*  figure out the frame size and channel count */
    /* '<S1210>:1:9' [frameSize, numChannels] = size(audioIn); */
    /* '<S1210>:1:10' frameSize = int32(frameSize); */
    /* '<S1210>:1:11' stateLen = int32(maxDelay)+frameSize; */
    /* '<S1210>:1:12' totalLen = int32(stateLen * numChannels); */
    /* '<S1210>:1:13' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1210>:1:17' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1210>:1:24' bufferIndex = delayIndex; */
    bufferIndex = Model_Target_AlignmentDelay_DW.delayIndex;

    /* '<S1210>:1:26' for channel = 1:numChannels */
    for (channel = 0; channel < 2; channel++)
    {
        /*  Save writeIndex for next channel */
        /* '<S1210>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(bufferIndex, 0, 8552);

        /* '<S1210>:1:31' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1210>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            TrebleDelay[writeIndex] = Model_Target_B.Sum[(channel << 5) + sample];

            /*  increment write pointer */
            /* '<S1210>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 8552);
        }

        /*  Advance buffer index for next channel */
        /* '<S1210>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 4276, 8552);
    }

    /*  Reset */
    /* '<S1210>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    bufferIndex = circindex(Model_Target_AlignmentDelay_DW.delayIndex, 32, 8552);

    /* '<S1210>:1:46' delayIndex = bufferIndex; */
    Model_Target_AlignmentDelay_DW.delayIndex = bufferIndex;

    /*  Read samples from delay line */
    /* '<S1210>:1:49' for channel = 1:numChannels */
    for (channel = 0; channel < 2; channel++)
    {
        /*  Setup read pointer */
        /* '<S1210>:1:52' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
        writeIndex = circindex(bufferIndex,
                               -(Model_Target_PreAmp0.MedusaTrebleDelay + 32),
                               8552);

        /* '<S1210>:1:54' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1210>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_AlignmentDelay_B.audioOut[sample + (channel << 5)] =
                TrebleDelay[writeIndex];

            /*  increment write pointer */
            /* '<S1210>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 8552);
        }

        /*  Advance buffer index for next channel */
        /* '<S1210>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 4276, 8552);
    }

    /* End of MATLAB Function: '<S1209>/MATLAB Function' */
}

/*
 * Output and update for atomic system:
 *    '<S1220>/Coeffs 1st Stage'
 *    '<S1316>/Coeffs 1st Stage'
 */
void Model_Target_Coeffs1stStage(const creal32_T rtu_Lin[129], const creal32_T
    rtu_Rin[129], B_Coeffs1stStage_Model_Target_T *localB)
{
    int32_T k;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Coeffs 1st Stage': '<S1221>:1' */
    /* '<S1221>:1:4' epsf = single(eps); */
    /*  Magnitude calculations */
    /* '<S1221>:1:7' absLi = abs(Lin) + epsf; */
    /* '<S1221>:1:8' absRi = abs(Rin) + epsf; */
    /* '<S1221>:1:9' minAbsLiRi = min(absLi, absRi); */
    /*  Excess coefficients (after removing far left/right) */
    /* '<S1221>:1:12' Lxk = minAbsLiRi ./ absLi; */
    /* '<S1221>:1:13' Rxk = minAbsLiRi ./ absRi; */
    /*  Far left/right coefficients */
    /* '<S1221>:1:16' Lok = 1 - Lxk; */
    /*  1 - min(|L|,|R|)/|L| */
    /* '<S1221>:1:17' Rok = 1 - Rxk; */
    /*  1 - min(|L|,|R|)/|R| */
    /*  Surround Phase Selectivity computation */
    /*  New SPS = |Lx - Rx|/(|Lx| + |Rx|) */
    /* '<S1221>:1:21' Lx = Lin .* Lxk; */
    /* '<S1221>:1:22' Rx = Rin .* Rxk; */
    /* '<S1221>:1:23' SPS = abs(Lx - Rx) ./ (abs(Lx) + abs(Rx) + epsf); */
    for (k = 0; k < 129; k++)
    {
        real32_T absLi_tmp;
        real32_T absLi_tmp_0;
        real32_T absRi_tmp;
        real32_T absRi_tmp_0;
        real32_T b_z;
        real32_T minval;
        real32_T z;
        absLi_tmp = rtu_Lin[k].re;
        absLi_tmp_0 = rtu_Lin[k].im;
        localB->absLi[k] = qhmath_hypot_f(absLi_tmp, absLi_tmp_0);
        localB->absLi[k] += 2.22044605E-16F;
        absRi_tmp = rtu_Rin[k].re;
        absRi_tmp_0 = rtu_Rin[k].im;
        localB->absRi[k] = qhmath_hypot_f(absRi_tmp, absRi_tmp_0);
        localB->absRi[k] += 2.22044605E-16F;
        minval = fminf(localB->absLi[k], localB->absRi[k]);
        z = qhmath_div_f(minval, localB->absLi[k]);
        b_z = qhmath_div_f(minval, localB->absRi[k]);
        localB->Lok[k] = 1.0F - z;
        localB->Rok[k] = 1.0F - b_z;
        absLi_tmp *= z;
        absLi_tmp_0 *= z;
        absRi_tmp *= b_z;
        absRi_tmp_0 *= b_z;
        localB->SPS[k] = qhmath_hypot_f(absLi_tmp - absRi_tmp, absLi_tmp_0 -
            absRi_tmp_0);
        localB->SPS[k] = qhmath_div_f(localB->SPS[k], (qhmath_hypot_f(absLi_tmp,
            absLi_tmp_0) + qhmath_hypot_f(absRi_tmp, absRi_tmp_0)) +
            2.22044605E-16F);
        localB->Lxk[k] = z;
        localB->Rxk[k] = b_z;
        localB->minAbsLiRi[k] = minval;
    }
}

/*
 * Output and update for atomic system:
 *    '<S1232>/MATLAB Function'
 *    '<S1234>/MATLAB Function'
 *    '<S1239>/MATLAB Function'
 *    '<S1240>/MATLAB Function'
 *    '<S1243>/MATLAB Function'
 *    '<S1244>/MATLAB Function'
 *    '<S1248>/MATLAB Function'
 *    '<S1249>/MATLAB Function'
 *    '<S1258>/MATLAB Function'
 *    '<S1260>/MATLAB Function'
 *    ...
 */
void Model_Target_MATLABFunction_nq(const real32_T rtu_x[129], real32_T rtu_pole,
    real32_T rtu_gain, B_MATLABFunction_Model_Target_b_T *localB,
    DW_MATLABFunction_Model_Target_k_T *localDW)
{
    int32_T i;

    /* MATLAB Function 'LeastSquareSmooth/MATLAB Function': '<S1233>:1' */
    /* '<S1233>:1:3' if isempty(xLast) */
    /* '<S1233>:1:8' if isempty(yLast) */
    /* '<S1233>:1:12' y = (gain * (x + xLast)) + (pole * yLast); */
    /*  Update states */
    /* '<S1233>:1:15' xLast = x; */
    /* '<S1233>:1:16' yLast = y; */
    for (i = 0; i < 129; i++)
    {
        localB->y[i] = (rtu_x[i] + localDW->xLast[i]) * rtu_gain + rtu_pole *
            localDW->yLast[i];
        localDW->xLast[i] = rtu_x[i];
        localDW->yLast[i] = localB->y[i];
    }
}

/*
 * Output and update for atomic system:
 *    '<S1228>/Update Steering Coeffs'
 *    '<S1323>/Update Steering Coeffs'
 */
void Model_Target_UpdateSteeringCoeffs(const real32_T rtu_Lstrks[129], const
    real32_T rtu_Rstrks[129], const real32_T rtu_Loks[129], const real32_T
    rtu_Roks[129], const real32_T rtu_Lxks[129], const real32_T rtu_Rxks[129],
    B_UpdateSteeringCoeffs_Model_Target_T *localB)
{
    int32_T i;

    /*  Update the steering coeffs using final stretch coeffs */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Updated Stretch Coeffs and Steering Coeffs/Update Steering Coeffs': '<S1255>:1' */
    /*  Update Lok/Rok */
    /* '<S1255>:1:5' Lok = Loks + ((2 - Rstrks) .* Lstrks) .* Lxks; */
    /* '<S1255>:1:6' Rok = Roks + ((2 - Lstrks) .* Rstrks) .* Rxks; */
    /*  Update Lxk/Rxk */
    /* '<S1255>:1:9' LxRxStretchFactor = (1 - Lstrks) .* (1 - Rstrks); */
    /* '<S1255>:1:10' Lxk = LxRxStretchFactor .* Lxks; */
    /* '<S1255>:1:11' Rxk = LxRxStretchFactor .* Rxks; */
    for (i = 0; i < 129; i++)
    {
        localB->Lok[i] = (2.0F - rtu_Rstrks[i]) * rtu_Lstrks[i] * rtu_Lxks[i] +
            rtu_Loks[i];
        localB->Rok[i] = (2.0F - rtu_Lstrks[i]) * rtu_Rstrks[i] * rtu_Rxks[i] +
            rtu_Roks[i];
        localB->Rxk[i] = (1.0F - rtu_Lstrks[i]) * (1.0F - rtu_Rstrks[i]);
        localB->Lxk[i] = localB->Rxk[i] * rtu_Lxks[i];
        localB->Rxk[i] *= rtu_Rxks[i];
    }
}

/* Output and update for function-call system: '<S1295>/init' */
void InitTrigger_Model_141_2207_65(void)
{
    /* MATLAB Function: '<S1294>/MATLAB Function1' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1298>:1' */
    /* '<S1298>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'RifftWola/RifftWola/Hexagon/MATLAB Function1': '<S1297>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S1297>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&MedusaFdpDeciRateRifftRifftBufferTwiddle1[0],
              &MedusaFdpDeciRateRifftRifftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S1303>/init' */
void InitTrigger_Model_141_2212_100(void)
{
    /* MATLAB Function: '<S1302>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1306>:1' */
    /* '<S1306>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function': '<S1304>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S1304>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&MedusaFdpDeciRateRfftRfftBufferTwiddle1[0],
              &MedusaFdpDeciRateRfftRfftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S1379>/init' */
void InitTrigger_Model_141_2873_65(void)
{
    /* MATLAB Function: '<S1378>/MATLAB Function1' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1382>:1' */
    /* '<S1382>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'RifftWola/RifftWola/Hexagon/MATLAB Function1': '<S1381>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S1381>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&MedusaFdpFullRateRifftRifftBufferTwiddle1[0],
              &MedusaFdpFullRateRifftRifftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S1387>/init' */
void InitTrigger_Model_141_2878_100(void)
{
    /* MATLAB Function: '<S1386>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1390>:1' */
    /* '<S1390>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function': '<S1388>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S1388>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&MedusaFdpFullRateRfftRfftBufferTwiddle1[0],
              &MedusaFdpFullRateRfftRfftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S1402>/init' */
void InitTrigger_Model_141_2931_156(void)
{
    /* MATLAB Function: '<S1401>/PoolIirInit' */
    /* MATLAB Function: '<S1401>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S1399>/TOP10'
     *  S-Function (TOP_MEX): '<S1399>/TOP11'
     *  Selector: '<S1165>/Selector'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1405>:1' */
    /* '<S1405>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1403>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1403>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1403>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1403>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1403>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1403>:1:28' else */
    /* '<S1403>:1:29' switch(VariantStr) */
    /* '<S1403>:1:30' case{"Hexagon"} */
    /* '<S1403>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1403>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1403>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaMonoDetectorHpf32323states[0], &Model_Target_B.LR[0],
                 32U, 2U, &(Model_Target_PreAmp0.MedusaMonoDetectorHPFNumStages
                            [0]),
                 &(Model_Target_PreAmp0.MedusaMonoDetectorHPFCoeffs[0]),
                 &MedusaMonoDetectorHpf32323states[0], 33U, 0U, 8U);

    /* '<S1403>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1424>/init' */
void InitTrigger_Model_141_3070_49_172_156(void)
{
    /* MATLAB Function: '<S1423>/PoolIirInit' */
    /* MATLAB Function: '<S1423>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S1420>/TOP'
     *  S-Function (TOP_MEX): '<S1420>/TOP1'
     *  Sum: '<S1172>/Sum'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1427>:1' */
    /* '<S1427>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1425>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1425>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1425>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1425>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1425>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1425>:1:28' else */
    /* '<S1425>:1:29' switch(VariantStr) */
    /* '<S1425>:1:30' case{"Hexagon"} */
    /* '<S1425>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1425>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1425>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&SPUMDecayIir57735states[0], &Model_Target_B.Sum[0], 32U, 2U,
                 &(Model_Target_PreAmp0.MedusaSPUMDecayEstHPFPooliirNumStages[0]),
                 &(Model_Target_PreAmp0.MedusaSPUMDecayEstHPFpooliirCoeffs[0]),
                 &SPUMDecayIir57735states[0], 113U, 0U, 48U);

    /* '<S1425>:1:34' states(1) = y; */
}

/* System initialize for atomic system: '<S1137>/Medusa5H1 Part 2' */
void Model_Target_Medusa5H1Part2_Init(void)
{
    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S1295>/ITC1' */
    InitTrigger_Model_141_2207_65();

    /* InitTriggerControl '<S1303>/ITC1' */
    InitTrigger_Model_141_2212_100();

    /* InitTriggerControl '<S1379>/ITC1' */
    InitTrigger_Model_141_2873_65();

    /* InitTriggerControl '<S1387>/ITC1' */
    InitTrigger_Model_141_2878_100();

    /* InitTriggerControl '<S1424>/ITC1' */
    InitTrigger_Model_141_3070_49_172_156();

    /* Start for SwitchCase: '<S1206>/Switch Case' */
    Model_Target_DW.SwitchCase_ActiveSubsystem = -1;

    /* InitializeConditions for Buffer: '<S1204>/BufferIn' */
    Model_Target_DW.BufferIn_inBufPtrIdx = 128;

    /* InitializeConditions for Buffer: '<S1204>/BufferOut' */
    Model_Target_DW.BufferOut_inBufPtrIdx = 128;

    /* InitializeConditions for Buffer: '<S1205>/BufferIn' */
    Model_Target_DW.BufferIn_inBufPtrIdx_e = 128;

    /* InitializeConditions for Buffer: '<S1205>/BufferOut' */
    Model_Target_DW.BufferOut_inBufPtrIdx_a = 128;

    /* InitializeConditions for Buffer: '<S1207>/Buffer' */
    Model_Target_DW.Buffer_inBufPtrIdx = 128;

    /* SystemInitialize for IfAction SubSystem: '<S1206>/Mono Detector' */
    /* '<S1275>:1:5' ; */
    /* '<S1275>:1:5' counter = 0; */
    /* '<S1275>:1:6' ; */
    /* '<S1275>:1:6' state = 0; */
    /* '<S1286>:1:5' ; */
    /* '<S1286>:1:5' counter = 0; */
    /* '<S1286>:1:6' ; */
    /* '<S1286>:1:6' state = 0; */
    /* '<S1296>:1:13' outputOverlap = single(zeros(numOverlap, numChannels)); */
    /* '<S1300>:1:9' InputOverlap = single(zeros(Overlap, NumChannels)); */
    /* '<S1359>:1:5' ; */
    /* '<S1359>:1:5' counter = 0; */
    /* '<S1359>:1:6' ; */
    /* '<S1359>:1:6' state = 0; */
    /* '<S1370>:1:5' ; */
    /* '<S1370>:1:5' counter = 0; */
    /* '<S1370>:1:6' ; */
    /* '<S1370>:1:6' state = 0; */
    /* '<S1380>:1:13' outputOverlap = single(zeros(numOverlap, numChannels)); */
    /* '<S1384>:1:9' InputOverlap = single(zeros(Overlap, NumChannels)); */

    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S1402>/ITC1' */
    InitTrigger_Model_141_2931_156();

    /* SystemInitialize for MATLAB Function: '<S1392>/Mono Detector' */
    /* '<S1396>:1:13' ; */
    /* '<S1396>:1:13' zeroLevelCount = 0; */
    /* '<S1396>:1:14' ; */
    /* '<S1396>:1:14' Llevel = single(0); */
    /* '<S1396>:1:15' ; */
    /* '<S1396>:1:15' Rlevel = single(0); */
    /* '<S1396>:1:16' ; */
    /* '<S1396>:1:16' smoothedSumOfEnergies = single(0); */
    /* '<S1396>:1:17' ; */
    /* '<S1396>:1:17' smoothedEnergyOfSum = single(0); */
    /* '<S1396>:1:18' ; */
    /* '<S1396>:1:18' levelCenter = single(0); */
    /* '<S1396>:1:19' ; */
    /* '<S1396>:1:19' lastSpumOn = true; */
    Model_Target_DW.lastSpumOn = true;

    /* End of SystemInitialize for SubSystem: '<S1206>/Mono Detector' */

    /* SystemInitialize for MATLAB Function: '<S1406>/Estimate Decay' */
    /* '<S1409>:1:14' ; */
    /* '<S1409>:1:14' onsetOn = 0; */
    /* '<S1409>:1:15' ; */
    /* '<S1409>:1:15' onsetOff = 0; */
    /* '<S1409>:1:16' ; */
    /* '<S1409>:1:16' onsetCounter = 0; */
    /* '<S1409>:1:17' ; */
    /* '<S1409>:1:17' noOnsetOnOffCounter = 0; */
    /* '<S1409>:1:18' ; */
    /* '<S1409>:1:18' prevDecay = decayConst.decayDefaultSlope; */
    Model_Target_DW.prevDecay = -0.173333332F;

    /* '<S1409>:1:19' ; */
    /* '<S1409>:1:19' smoothedDecay = decayConst.decayDefaultSlope; */
    Model_Target_DW.smoothedDecay = -0.173333332F;

    /* '<S1409>:1:21' thresholdForFrameEnergy = decayConst.minGateFrameEnergydB; */
    Model_Target_DW.thresholdForFrameEnergy = -25.0F;

    /* '<S1410>:1:8' ; */
    /* '<S1410>:1:8' prevDelta = single(0); */
    /* '<S1410>:1:9' ; */
    /* '<S1410>:1:9' prevStepSize = single(0); */
}

/* Output and update for atomic system: '<S1137>/Medusa5H1 Part 2' */
void Model_Target_Medusa5H1Part2TID2(void)
{
    int32_T chanIdx;
    int32_T currentOffset;
    int32_T i;
    int32_T offsetFromMemBase;
    int32_T uIdx;
    real32_T y_l3[64];
    int8_T rtAction;
    int8_T rtPrevAction;
    static const int8_T tmp[4] =
    {
        0, 1, 2, 4
    };

    /* Outputs for Atomic SubSystem: '<S1165>/Alignment Delay' */
    Model_Target_AlignmentDelay();

    /* End of Outputs for SubSystem: '<S1165>/Alignment Delay' */

    /* Buffer: '<S1204>/BufferIn' */
    uIdx = 0;
    for (chanIdx = 0; chanIdx < 2; chanIdx++)
    {
        offsetFromMemBase = (chanIdx << 8) +
            Model_Target_DW.BufferIn_inBufPtrIdx;
        for (i = 0; i < 8; i++)
        {
            Model_Target_DW.BufferIn_CircBuf[offsetFromMemBase + i] =
                Model_Target_B.crossfadedOutput[uIdx + i];
        }

        uIdx += 8;
    }

    Model_Target_DW.BufferIn_inBufPtrIdx += 8;
    if (Model_Target_DW.BufferIn_inBufPtrIdx >= 256)
    {
        Model_Target_DW.BufferIn_inBufPtrIdx -= 256;
    }

    /* End of Buffer: '<S1204>/BufferIn' */

    /* Buffer: '<S1204>/BufferOut' */
    uIdx = 0;
    for (chanIdx = 0; chanIdx < 8; chanIdx++)
    {
        currentOffset = (chanIdx << 8) + Model_Target_DW.BufferOut_outBufPtrIdx;
        for (i = 0; i < 8; i++)
        {
            Model_Target_B.BufferOut[uIdx + i] =
                Model_Target_DW.BufferOut_CircBuf[currentOffset + i];
        }

        uIdx += 8;
        currentOffset = Model_Target_DW.BufferOut_outBufPtrIdx + 8;
    }

    if (currentOffset == 256)
    {
        currentOffset = 0;
    }

    Model_Target_DW.BufferOut_outBufPtrIdx = currentOffset;

    /* End of Buffer: '<S1204>/BufferOut' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1295>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1303>/ITC1' */
    /* Buffer: '<S1205>/BufferIn' */
    uIdx = 0;
    for (chanIdx = 0; chanIdx < 2; chanIdx++)
    {
        offsetFromMemBase = (chanIdx << 8) +
            Model_Target_DW.BufferIn_inBufPtrIdx_e;
        memcpy(&Model_Target_DW.BufferIn_CircBuf_l[offsetFromMemBase],
               &Model_Target_AlignmentDelay_B.audioOut[uIdx], sizeof(real32_T) <<
               5U);
        uIdx += 32;
    }

    Model_Target_DW.BufferIn_inBufPtrIdx_e += 32;
    if (Model_Target_DW.BufferIn_inBufPtrIdx_e >= 256)
    {
        Model_Target_DW.BufferIn_inBufPtrIdx_e -= 256;
    }

    /* End of Buffer: '<S1205>/BufferIn' */

    /* Buffer: '<S1205>/BufferOut' */
    uIdx = 0;
    offsetFromMemBase = Model_Target_DW.BufferOut_outBufPtrIdx_e + 32;
    for (chanIdx = 0; chanIdx < 6; chanIdx++)
    {
        currentOffset = (chanIdx << 8) +
            Model_Target_DW.BufferOut_outBufPtrIdx_e;
        memcpy(&Model_Target_B.BufferOut_c[uIdx],
               &Model_Target_DW.BufferOut_CircBuf_j[currentOffset], sizeof
               (real32_T) << 5U);
        uIdx += 32;
    }

    if (Model_Target_DW.BufferOut_outBufPtrIdx_e + 32 == 256)
    {
        offsetFromMemBase = 0;
    }

    Model_Target_DW.BufferOut_outBufPtrIdx_e = offsetFromMemBase;

    /* End of Buffer: '<S1205>/BufferOut' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1379>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1387>/ITC1' */
    /* Selector: '<S1165>/Selector' */
    memcpy(&Model_Target_B.LR[0], &Model_Target_B.FRIn[0], sizeof(real32_T) <<
           6U);

    /* SwitchCase: '<S1206>/Switch Case' */
    rtPrevAction = Model_Target_DW.SwitchCase_ActiveSubsystem;
    if (Model_Target_PreAmp0.MedusaMonoDetectorEnable == 1)
    {
        rtAction = 0;
    }
    else
    {
        rtAction = 1;
    }

    Model_Target_DW.SwitchCase_ActiveSubsystem = rtAction;
    if ((rtPrevAction != rtAction) && (rtPrevAction == 0))
    {
    }

    if (rtAction == 0)
    {
        real32_T absLeft;
        real32_T absRight;
        real32_T curL;
        real32_T curR;
        real32_T sumOfEnergies;
        if (rtPrevAction != 0)
        {
        }

        /* MATLAB Function: '<S1401>/PoolIirProcess' incorporates:
         *  Selector: '<S1165>/Selector'
         */
        /*  Process function for Pooliir */
        /*  */
        /*  Parameters: */
        /*    x:              input channels [frame size x number of inputs] */
        /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
        /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
        /*   */
        /*  Global parameters: */
        /*    states: working memory set up during roommode reset/init CRL */
        /*                    function call [StatesSize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1404>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1404>:1:15' [~, NumChannels] = size(x); */
        /*  Initialize variables */
        /* '<S1404>:1:20' VariantStr = char(VariantUint8); */
        /* '<S1404>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1404>:1:29' else */
        /* '<S1404>:1:30' switch(VariantStr) */
        /* '<S1404>:1:31' case{"Hexagon"} */
        /* '<S1404>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
        pooliir_process(&y_l3[0], &Model_Target_B.LR[0],
                        &MedusaMonoDetectorHpf32323states[0]);

        /* MATLAB Function: '<S1392>/Mono Detector' incorporates:
         *  BusCreator generated from: '<S1392>/Mono Detector'
         *  DownSample: '<S1392>/Downsample'
         *  DownSample: '<S1392>/Downsample1'
         *  Selector: '<S1165>/Selector'
         */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Mono Detector/Mono Detector/Mono Detector': '<S1396>:1' */
        /*  basically isStereo, since we turn on SPUM if input is stereo */
        /* '<S1396>:1:13' if isempty(zeroLevelCount) */
        /* '<S1396>:1:14' if isempty(Llevel) */
        /* '<S1396>:1:15' if isempty(Rlevel) */
        /* '<S1396>:1:16' if isempty(smoothedSumOfEnergies) */
        /* '<S1396>:1:17' if isempty(smoothedEnergyOfSum) */
        /* '<S1396>:1:18' if isempty(levelCenter) */
        /* '<S1396>:1:19' if isempty(lastSpumOn) */
        /* '<S1396>:1:21' absLeft = abs(L); */
        absLeft = qhmath_abs_f(Model_Target_B.LR[0]);

        /* '<S1396>:1:22' absRight = abs(R); */
        absRight = qhmath_abs_f(Model_Target_B.LR[32]);

        /*  Recursive averaging */
        /* '<S1396>:1:25' a1 = monoDetectorTunable.levelPole; */
        /* '<S1396>:1:26' b0 = monoDetectorTunable.levelGain; */
        /* '<S1396>:1:27' Llevel = Llevel * a1 +  absLeft * b0; */
        Model_Target_DW.Llevel = Model_Target_DW.Llevel *
            Model_Target_PreAmp0.MedusaMonoDetectorLevelPole + absLeft *
            Model_Target_PreAmp0.MedusaMonoDetectorLevelGain;

        /* '<S1396>:1:28' Rlevel = Rlevel * a1 +  absRight * b0; */
        Model_Target_DW.Rlevel = Model_Target_DW.Rlevel *
            Model_Target_PreAmp0.MedusaMonoDetectorLevelPole + absRight *
            Model_Target_PreAmp0.MedusaMonoDetectorLevelGain;

        /*  Compute saturated signals from predetermined miss-match tolerance */
        /* '<S1396>:1:31' LlevelSat = min(Llevel, Rlevel*monoDetectorTunable.leftRightMatchTolerance); */
        /* '<S1396>:1:32' RlevelSat = min(Rlevel, Llevel*monoDetectorTunable.leftRightMatchTolerance); */
        /*  Compute mono content variables */
        /* '<S1396>:1:35' curL = hpfL * RlevelSat; */
        curL = fminf(Model_Target_DW.Rlevel, Model_Target_DW.Llevel *
                     Model_Target_PreAmp0.MedusaMonoDetectorLRMatchTolerance) *
            y_l3[0];

        /* '<S1396>:1:36' curR = hpfR * LlevelSat; */
        curR = fminf(Model_Target_DW.Llevel, Model_Target_DW.Rlevel *
                     Model_Target_PreAmp0.MedusaMonoDetectorLRMatchTolerance) *
            y_l3[32];

        /* '<S1396>:1:37' sumOfEnergies = curL^2 + curR^2; */
        sumOfEnergies = curL * curL + curR * curR;

        /*  tgtX2 */
        /* '<S1396>:1:38' energyOfSum = 0.5*(curL + curR)^2; */
        curL += curR;
        curL = curL * curL * 0.5F;

        /*  tgtX2Center */
        /*  Check if signal has been low for awhile */
        /* '<S1396>:1:41' if (absLeft + absRight) < monoDetectorTunable.thresholdZeroLevel */
        if (absLeft + absRight <
                Model_Target_PreAmp0.MedusaMonoDetectorThresholdZeroLevel)
        {
            /* '<S1396>:1:42' zeroLevelCount = zeroLevelCount + 1; */
            Model_Target_DW.zeroLevelCount++;
        }
        else
        {
            /* '<S1396>:1:43' else */
            /* '<S1396>:1:44' zeroLevelCount = 0; */
            Model_Target_DW.zeroLevelCount = 0.0;
        }

        /*  Pole selection (determine LPF coefficient) for least square smoothing */
        /*  If the signal level is very low (or zero) for awhile, rest params and  */
        /*  select correct poles so that we don't miss fast changes in input */
        /* '<S1396>:1:50' if zeroLevelCount > maxZeroLevelCount */
        if (Model_Target_DW.zeroLevelCount > Model_Target_maxZeroLevelCount)
        {
            /* '<S1396>:1:51' sumOfEnergies = single(0); */
            sumOfEnergies = 0.0F;

            /* '<S1396>:1:52' energyOfSum = single(0); */
            curL = 0.0F;

            /* '<S1396>:1:53' smoothedSumOfEnergies = single(0); */
            Model_Target_DW.smoothedSumOfEnergies = 0.0F;

            /* '<S1396>:1:54' smoothedEnergyOfSum = single(0); */
            Model_Target_DW.smoothedEnergyOfSum = 0.0F;

            /* '<S1396>:1:55' lsPole = monoDetectorTunable.lsSmoothResetPole; */
            absLeft = Model_Target_PreAmp0.MedusaMonoDetectorLSSmoothResetPole;

            /* '<S1396>:1:56' lsGain = monoDetectorTunable.lsSmoothResetGain; */
            absRight = Model_Target_PreAmp0.MedusaMonoDetectorLSSmoothResetGain;

            /* '<S1396>:1:57' zeroLevelCount = maxZeroLevelCount + 1; */
            Model_Target_DW.zeroLevelCount = 694.0;
        }
        else
        {
            /* '<S1396>:1:58' else */
            /* '<S1396>:1:59' lsPole = monoDetectorTunable.lsSmoothPole; */
            absLeft = Model_Target_PreAmp0.MedusaMonoDetectorLSSmoothPole;

            /* '<S1396>:1:60' lsGain = monoDetectorTunable.lsSmoothGain; */
            absRight = Model_Target_PreAmp0.MedusaMonoDetectorLSSmoothGain;
        }

        /*  Least square smoothing  */
        /* '<S1396>:1:64' smoothedSumOfEnergies = lsPole * smoothedSumOfEnergies + lsGain * sumOfEnergies; */
        Model_Target_DW.smoothedSumOfEnergies = absLeft *
            Model_Target_DW.smoothedSumOfEnergies + absRight * sumOfEnergies;

        /* '<S1396>:1:65' smoothedEnergyOfSum = lsPole * smoothedEnergyOfSum + lsGain * energyOfSum; */
        Model_Target_DW.smoothedEnergyOfSum = absLeft *
            Model_Target_DW.smoothedEnergyOfSum + absRight * curL;

        /*  Compute measure of center (or mono) level */
        /* '<S1396>:1:68' levelCenter = smoothedEnergyOfSum/(smoothedSumOfEnergies + single(eps)); */
        sumOfEnergies = qhmath_div_f(Model_Target_DW.smoothedEnergyOfSum,
            Model_Target_DW.smoothedSumOfEnergies + 2.22044605E-16F);

        /*  Determine if input is stereo and turn SPUM on/off accordingly */
        /*  stereo case 1: was stereo last time (SPUM on) and this mono level < mono threhold */
        /*  stereo case 2: was mono last time (SPUM off) and this mono level < stereo threshold */
        /* '<S1396>:1:73' lastSpumOn = (lastSpumOn && (levelCenter < monoDetectorTunable.thresholdMono)) ... */
        /* '<S1396>:1:74'     || (~lastSpumOn && (levelCenter <= monoDetectorTunable.thresholdStereo)); */
        Model_Target_DW.lastSpumOn = ((Model_Target_DW.lastSpumOn &&
            (sumOfEnergies <
             Model_Target_PreAmp0.MedusaMonoDetectorThresholdMono)) ||
            ((!Model_Target_DW.lastSpumOn) && (sumOfEnergies <=
            Model_Target_PreAmp0.MedusaMonoDetectorThresholdStereo)));

        /* '<S1396>:1:76' spumOn = uint32(lastSpumOn); */
        /*  equivalent to isStereo */
        /* '<S1396>:1:78' center = levelCenter; */
        Model_Target_B.center = sumOfEnergies;

        /* Merge: '<S1206>/Merge' incorporates:
         *  MATLAB Function: '<S1392>/Mono Detector'
         *  SignalConversion generated from: '<S1392>/IsStereo'
         */
        Model_Target_B.Merge = Model_Target_DW.lastSpumOn;

        /* End of Outputs for S-Function (InitTriggerControl): '<S1402>/ITC1' */

        /* Update for M-S-Function: '<S1398>/TSP' */
        // TSP advanced triggered capture for PreAmpMedusaMonoDetectorLevelCenter '<S1398>/TSP':
#if TSP_ENABLE_ADVANCED

        TSP_StepCapture(TspDispatchTable0000, 55, &Model_Target_B.center);

#endif                                 //TSP_ENABLE_ADVANCED

        /* End of Outputs for SubSystem: '<S1206>/Mono Detector' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1206>/Bypass' incorporates:
         *  ActionPort: '<S1391>/Action Port'
         */
        /* Merge: '<S1206>/Merge' incorporates:
         *  Constant: '<S1391>/Constant'
         *  SignalConversion generated from: '<S1391>/IsStereo'
         */
        Model_Target_B.Merge = 1U;

        /* End of Outputs for SubSystem: '<S1206>/Bypass' */
    }

    /* End of SwitchCase: '<S1206>/Switch Case' */
    /* MATLAB Function: '<S1423>/PoolIirProcess' incorporates:
     *  Sum: '<S1172>/Sum'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1426>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1426>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S1426>:1:20' VariantStr = char(VariantUint8); */
    /* '<S1426>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1426>:1:29' else */
    /* '<S1426>:1:30' switch(VariantStr) */
    /* '<S1426>:1:31' case{"Hexagon"} */
    /* '<S1426>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&y_l3[0], &Model_Target_B.Sum[0], &SPUMDecayIir57735states[0]);

    /* Buffer: '<S1207>/Buffer' */
    uIdx = 0;
    for (chanIdx = 0; chanIdx < 2; chanIdx++)
    {
        offsetFromMemBase = (chanIdx << 8) + Model_Target_DW.Buffer_inBufPtrIdx;
        memcpy(&Model_Target_DW.Buffer_CircBuf[offsetFromMemBase], &y_l3[uIdx],
               sizeof(real32_T) << 5U);
        uIdx += 32;
    }

    Model_Target_DW.Buffer_inBufPtrIdx += 32;
    if (Model_Target_DW.Buffer_inBufPtrIdx >= 256)
    {
        Model_Target_DW.Buffer_inBufPtrIdx -= 256;
    }

    /* End of Buffer: '<S1207>/Buffer' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1424>/ITC1' */
    /* Selector: '<S1165>/Selector1' incorporates:
     *  Buffer: '<S1205>/BufferOut'
     */
    for (uIdx = 0; uIdx < 4; uIdx++)
    {
        for (chanIdx = 0; chanIdx < 32; chanIdx++)
        {
            Model_Target_B.LoRoLimpRimp[chanIdx + (uIdx << 5)] =
                Model_Target_B.BufferOut_c[(tmp[uIdx] << 5) + chanIdx];
        }
    }

    /* End of Selector: '<S1165>/Selector1' */
    /* Update for M-S-Function: '<S1393>/TSP' */
    // TSP advanced triggered capture for PreAmpMedusaMonoDetectorIsStereo '<S1393>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 54, &Model_Target_B.Merge);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1394>/TSP' */
    // TSP advanced triggered capture for PreAmpMedusaMonoDetectorIsActive '<S1394>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 53,
                    &(Model_Target_PreAmp0.MedusaMonoDetectorEnable));

#endif                                 //TSP_ENABLE_ADVANCED

}

/* Output and update for atomic system: '<S1137>/Medusa5H1 Part 2' */
void Model_Target_Medusa5H1Part2TID4(void)
{
    int32_T currentOffset;
    int32_T delayLen;
    int32_T i;
    int32_T memIdx;
    int32_T row;
    int32_T rtb_isImpulsive_g;
    real32_T rtb_Add1_lk[129];
    real32_T rtb_Add1_mry[129];
    real32_T rtb_Rxks[129];
    real32_T y[5];
    real32_T maxXp;
    real32_T minXp;
    real32_T minXp_tmp;
    real32_T rtb_Delay_og;
    real32_T rtb_R_im_tmp;
    real32_T rtb_R_re;
    real32_T rtb_R_re_tmp;
    real32_T rtb_Sumhighfrequencyenergy;
    real32_T slewedStepSize;
    real32_T updatedLokRokScaleFactor;
    real32_T updatedLokRokScaleFactor_tmp;
    static const real32_T b[128] =
    {
        0.0F, 0.0122715384F, 0.024541229F, 0.0368072242F, 0.0490676761F,
        0.061320737F, 0.0735645667F, 0.0857973099F, 0.0980171412F, 0.110222206F,
        0.122410677F, 0.134580702F, 0.146730468F, 0.15885815F, 0.170961887F,
        0.183039889F, 0.195090324F, 0.207111374F, 0.219101235F, 0.231058106F,
        0.242980182F, 0.254865646F, 0.266712755F, 0.27851969F, 0.290284663F,
        0.302005947F, 0.313681751F, 0.32531029F, 0.336889863F, 0.348418683F,
        0.359895051F, 0.371317208F, 0.382683426F, 0.393992037F, 0.405241311F,
        0.416429549F, 0.427555084F, 0.438616246F, 0.449611336F, 0.460538715F,
        0.471396744F, 0.482183784F, 0.492898196F, 0.50353837F, 0.514102757F,
        0.524589658F, 0.534997642F, 0.545325F, 0.555570245F, 0.565731823F,
        0.575808167F, 0.585797846F, 0.59569931F, 0.605511069F, 0.615231574F,
        0.624859512F, 0.634393275F, 0.643831551F, 0.653172851F, 0.662415802F,
        0.671559F, 0.680601F, 0.689540565F, 0.698376238F, 0.707106769F,
        0.715730846F, 0.724247098F, 0.732654274F, 0.740951121F, 0.749136388F,
        0.757208824F, 0.765167236F, 0.773010433F, 0.780737221F, 0.78834641F,
        0.795836926F, 0.803207517F, 0.81045717F, 0.817584813F, 0.824589312F,
        0.831469595F, 0.838224709F, 0.84485358F, 0.851355195F, 0.857728601F,
        0.863972843F, 0.870086968F, 0.876070082F, 0.881921291F, 0.887639642F,
        0.893224299F, 0.898674488F, 0.903989315F, 0.909168F, 0.914209783F,
        0.919113874F, 0.923879504F, 0.928506076F, 0.932992816F, 0.937339F,
        0.941544056F, 0.945607305F, 0.949528158F, 0.953306F, 0.956940353F,
        0.960430503F, 0.963776052F, 0.966976464F, 0.970031261F, 0.972939968F,
        0.975702107F, 0.97831738F, 0.980785251F, 0.983105481F, 0.985277653F,
        0.987301409F, 0.989176512F, 0.990902662F, 0.992479563F, 0.993907F,
        0.99518472F, 0.996312618F, 0.997290432F, 0.998118103F, 0.99879545F,
        0.999322355F, 0.999698818F, 0.999924719F
    };

    static const real32_T c[128] =
    {
        1.0F, 0.999924719F, 0.999698818F, 0.999322355F, 0.99879545F,
        0.998118103F, 0.997290432F, 0.996312618F, 0.99518472F, 0.993907F,
        0.992479563F, 0.990902662F, 0.989176512F, 0.987301409F, 0.985277653F,
        0.983105481F, 0.980785251F, 0.97831738F, 0.975702107F, 0.972939968F,
        0.970031261F, 0.966976464F, 0.963776052F, 0.960430503F, 0.956940353F,
        0.953306F, 0.949528158F, 0.945607305F, 0.941544056F, 0.937339F,
        0.932992816F, 0.928506076F, 0.923879504F, 0.919113874F, 0.914209783F,
        0.909168F, 0.903989315F, 0.898674488F, 0.893224299F, 0.887639642F,
        0.881921291F, 0.876070082F, 0.870086968F, 0.863972843F, 0.857728601F,
        0.851355195F, 0.84485358F, 0.838224709F, 0.831469595F, 0.824589312F,
        0.817584813F, 0.81045717F, 0.803207517F, 0.795836926F, 0.78834641F,
        0.780737221F, 0.773010433F, 0.765167236F, 0.757208824F, 0.749136388F,
        0.740951121F, 0.732654274F, 0.724247098F, 0.715730846F, 0.707106769F,
        0.698376238F, 0.689540565F, 0.680601F, 0.671559F, 0.662415802F,
        0.653172851F, 0.643831551F, 0.634393275F, 0.624859512F, 0.615231574F,
        0.605511069F, 0.59569931F, 0.585797846F, 0.575808167F, 0.565731823F,
        0.555570245F, 0.545325F, 0.534997642F, 0.524589658F, 0.514102757F,
        0.50353837F, 0.492898196F, 0.482183784F, 0.471396744F, 0.460538715F,
        0.449611336F, 0.438616246F, 0.427555084F, 0.416429549F, 0.405241311F,
        0.393992037F, 0.382683426F, 0.371317208F, 0.359895051F, 0.348418683F,
        0.336889863F, 0.32531029F, 0.313681751F, 0.302005947F, 0.290284663F,
        0.27851969F, 0.266712755F, 0.254865646F, 0.242980182F, 0.231058106F,
        0.219101235F, 0.207111374F, 0.195090324F, 0.183039889F, 0.170961887F,
        0.15885815F, 0.146730468F, 0.134580702F, 0.122410677F, 0.110222206F,
        0.0980171412F, 0.0857973099F, 0.0735645667F, 0.061320737F, 0.0490676761F,
        0.0368072242F, 0.024541229F, 0.0122715384F
    };

    creal32_T *rtb_y_i_0;

    /* Buffer: '<S1205>/BufferIn' */
    delayLen = 0;
    for (row = 0; row < 2; row++)
    {
        memIdx = (row << 8) + Model_Target_DW.BufferIn_outBufPtrIdx_c;
        memcpy(&Model_Target_B.BufferIn[delayLen],
               &Model_Target_DW.BufferIn_CircBuf_l[memIdx], sizeof(real32_T) <<
               7U);
        delayLen += 128;
        i = Model_Target_DW.BufferIn_outBufPtrIdx_c + 128;
    }

    if (i == 256)
    {
        i = 0;
    }

    Model_Target_DW.BufferIn_outBufPtrIdx_c = i;

    /* End of Buffer: '<S1205>/BufferIn' */

    /* MATLAB Function: '<S1310>/Windowing' incorporates:
     *  Buffer: '<S1205>/BufferIn'
     */
    /*  Get sizes */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/ShortTimeFourierTransform/Windowing': '<S1384>:1' */
    /* '<S1384>:1:4' [~, NumChannels] = size(AudioIn); */
    /* '<S1384>:1:5' HopSize = FftSize - Overlap; */
    /* '<S1384>:1:8' if isempty(InputOverlap) */
    /* '<S1384>:1:12' AudioOut = [InputOverlap.*Window(1:Overlap); AudioIn.*Window((HopSize + 1):end)]; */
    for (delayLen = 0; delayLen < 2; delayLen++)
    {
        for (i = 0; i < 128; i++)
        {
            rtb_isImpulsive_g = (delayLen << 7) + i;
            row = (delayLen << 8) + i;
            MedusaFdpFullRateRfftRfftInput[row] =
                Model_Target_DW.InputOverlap[rtb_isImpulsive_g] * b[i];
            MedusaFdpFullRateRfftRfftInput[row + 128] =
                Model_Target_B.BufferIn[rtb_isImpulsive_g] * c[i];
        }
    }

    /*  Update overlapping samples */
    /* '<S1384>:1:15' InputOverlap = AudioIn; */
    memcpy(&Model_Target_DW.InputOverlap[0], &Model_Target_B.BufferIn[0], sizeof
           (real32_T) << 8U);

    /* End of MATLAB Function: '<S1310>/Windowing' */

    /* MATLAB Function: '<S1386>/MATLAB Function1' */
    /*  Computes the Real FFT of a Multi-Channel Signal.  */
    /*  During Code Generation, hexagon rfft crl function is used. */
    /*  Inputs: */
    /*      u - purely real signal.  */
    /*          size = [fftSize, numChannels] */
    /*      fftSize - size of each input channel. Also the size of FFT */
    /*  Outputs: */
    /*      y - fftSize/2 + 1 unique FFT coefficients of each channel of u. */
    /*          size = [fftSize/2 + 1, numChannels] */
    /*  ------------------------------------------------------------------------- */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function1': '<S1389>:1' */
    /* '<S1389>:1:17' numChannels = size(u, 2); */
    /* '<S1389>:1:18' spectrumSize = (fftSize/2) + 1; */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S1389>:1:21' y = coder.nullcopy(complex(single(zeros(spectrumSize, numChannels)))); */
    /*  Simulation */
    /* '<S1389>:1:24' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1389>:1:27' else */
    /* '<S1389>:1:28' y = rfft_process(single(u), Twiddle1, Twiddle2, RfftOutputTmp, int32(fftSize), int32(numChannels)); */
    rfft_process(&Model_Target_B.y_i[0], &MedusaFdpFullRateRfftRfftInput[0],
                 &MedusaFdpFullRateRfftRfftBufferTwiddle1[0],
                 &MedusaFdpFullRateRfftRfftBufferTwiddle2[0],
                 &MedusaFdpFullRateRfftRfftBufferRfftOutputTmp[0], 256, 2);

    /* Math: '<S1331>/Math Function'
     *
     * About '<S1331>/Math Function':
     *  Operator: magnitude^2
     */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        /* Selector: '<S1310>/Selector' incorporates:
         *  Math: '<S1313>/Math Function'
         *  Math: '<S1313>/Math Function1'
         *  Math: '<S1331>/Math Function1'
         *  Selector: '<S1310>/Selector1'
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1313>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1331>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_i_0 = &Model_Target_B.y_i[delayLen];
        Model_Target_B.Lin2[delayLen] = rtb_y_i_0->re * rtb_y_i_0->re +
            rtb_y_i_0->im * rtb_y_i_0->im;
    }

    /* MATLAB Function: '<S1316>/Coeffs 1st Stage' incorporates:
     *  Selector: '<S1310>/Selector'
     *  Selector: '<S1310>/Selector1'
     */
    Model_Target_Coeffs1stStage(&Model_Target_B.y_i[0], &Model_Target_B.y_i[129],
        &Model_Target_B.sf_Coeffs1stStage_m);

    /* MATLAB Function: '<S1319>/MATLAB Function' incorporates:
     *  Math: '<S1331>/Math Function'
     *  Product: '<S1346>/Multiply'
     *
     * About '<S1331>/Math Function':
     *  Operator: magnitude^2
     */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/FullRate/Calculate coefficients/Instantaneous Stretch Coeffs /MATLAB Function': '<S1324>:1' */
    /* '<S1324>:1:6' coder.inline('always'); */
    /* '<S1324>:1:7' epsf = single(eps); */
    /*  Step 1: Compute the estimated stretch coefficients or worst-case estimate */
    /*  based on maximum allowable stretching Xpmax */
    /*  NOTE: The Xp used for detect here is the decimated rate Xp, which means */
    /*  the pre-calculated LokRokMaxScaleFactor for treble stretching is done */
    /*  using the decimated rate XpMax. */
    /* '<S1324>:1:16' Lstrk = min(Lxk, LokRokMaxScaleFactor * Lok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] =
            Model_Target_PreAmp0.MedusaFullRateFdpCoeffsLokRokMaxScaleFactor *
            Model_Target_B.sf_Coeffs1stStage_m.Lok[i];
    }

    for (row = 0; row < 129; row++)
    {
        Model_Target_B.Multiply_c[row] = fminf
            (Model_Target_B.sf_Coeffs1stStage_m.Lxk[row],
             Model_Target_B.Multiply_n[row]);
    }

    /* '<S1324>:1:17' Rstrk = min(Rxk, LokRokMaxScaleFactor * Rok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] =
            Model_Target_PreAmp0.MedusaFullRateFdpCoeffsLokRokMaxScaleFactor *
            Model_Target_B.sf_Coeffs1stStage_m.Rok[i];
    }

    for (row = 0; row < 129; row++)
    {
        Model_Target_B.Lstrk[row] = fminf
            (Model_Target_B.sf_Coeffs1stStage_m.Rxk[row],
             Model_Target_B.Multiply_n[row]);
    }

    /*  Step 2: Compute Excessive Stretch Detector (ESD) - used to update Xp */
    /*  */
    /*                    sum_over_FFT_bins( Lstrki * |Lin|) + sum_over_FFT_bins( Rstrki * |Rin|)   */
    /*  ESD = abs( db20 ( ----------------------------------------------------------------------- ) ) */
    /*                                      sum_over_FFT_bins( Lxki * |Lin| ) */
    /*  */
    /*  since Lxki * |Lin| = min (|Lin|,|Rin|) (per bin), we store the minima  */
    /*  beforehand and use it here */
    /*  Note the matrix shorthand for sum_over_FFT_bins(Lstrki * Lin) is Lstrk' * p.absLi */
    /*  A small positive value is added to the numerator, to avoid db20(0) */
    /* '<S1324>:1:30' ESDdB = db20( (epsf + Lstrk(:)' * absLi(:) + Rstrk(:)' * absRi(:)) ... */
    /* '<S1324>:1:31'             / (epsf + sum(minAbsLiRi)) ); */
    maxXp = Model_Target_B.sf_Coeffs1stStage_m.minAbsLiRi[0];
    for (row = 0; row < 128; row++)
    {
        maxXp += Model_Target_B.sf_Coeffs1stStage_m.minAbsLiRi[row + 1];
    }

    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    updatedLokRokScaleFactor = 0.0F;
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        updatedLokRokScaleFactor += Model_Target_B.Multiply_c[delayLen] *
            Model_Target_B.sf_Coeffs1stStage_m.absLi[delayLen];
    }

    rtb_Sumhighfrequencyenergy = 0.0F;
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        rtb_Sumhighfrequencyenergy += Model_Target_B.Lstrk[delayLen] *
            Model_Target_B.sf_Coeffs1stStage_m.absRi[delayLen];
    }

    updatedLokRokScaleFactor = qhmath_log_f(qhmath_abs_f(qhmath_div_f
        ((updatedLokRokScaleFactor + 2.22044605E-16F) +
         rtb_Sumhighfrequencyenergy, maxXp + 2.22044605E-16F))) * 8.68588924F;

    /*  "Turn off" stretching by setting minXp and maxXp to zero,  */
    /*  if CAE_enable is zero. */
    /* '<S1324>:1:35' if (CAE_enable == 0) */
    if (Model_Target_B.Constant3 == 0)
    {
        /* '<S1324>:1:36' minXp = single(0.0); */
        minXp = 0.0F;

        /* '<S1324>:1:37' maxXp = single(0.0); */
        maxXp = 0.0F;
    }
    else
    {
        /* '<S1324>:1:38' else */
        /* '<S1324>:1:39' minXp = Xpmin; */
        minXp = Model_Target_PreAmp0.MedusaFullRateFdpCoeffsXpMin;

        /* '<S1324>:1:40' maxXp = Xpmax; */
        maxXp = Model_Target_PreAmp0.MedusaFullRateFdpCoeffsXpMax;
    }

    /*  Calculate new stretch factor, Xp, based on ESD value. */
    /*  The following curve is applied: */
    /*         Xp */
    /*         ^ */
    /*         | */
    /*   maxXp +----------. */
    /*         |          .\ */
    /*         |          . \ */
    /*         |          .  \ */
    /*         |          .   \ */
    /*         |          .    \ */
    /*         |          .     \ */
    /*   minXp +          .      --------------- minXp */
    /*         |          .      . */
    /*         +----------+------+-------------> ESD (dB) */
    /*        0           |      | */
    /*                    |     ESD_upper_bound_in_dB - thresh2 */
    /*                    | */
    /*                   ESD_lower_bound_in_dB - thresh1 */
    /* '<S1324>:1:63' if (ESDdB < ESDLowerBound) */
    if (updatedLokRokScaleFactor <
            Model_Target_PreAmp0.MedusaFullRateFdpCoeffsESDLowerbounddB)
    {
        /*  Stretching is lower than the lower threshold, use largest allowable Xp. */
        /* '<S1324>:1:65' Xp = maxXp; */
        minXp = maxXp;
    }
    else if (updatedLokRokScaleFactor <=
             Model_Target_PreAmp0.MedusaFullRateFdpCoeffsESDUpperbounddB)
    {
        /* '<S1324>:1:69' else */
        /*  Stretching in between, compute Xp as a linear interpolation between  */
        /*  max and min based on the two thresholds */
        /* '<S1324>:1:72' Xp = minXp + (maxXp - minXp) * ESDStepSize * (ESDUpperBound - ESDdB); */
        minXp += (maxXp - minXp) *
            Model_Target_PreAmp0.MedusaFullRateFdpCoeffsESDStepSize *
            (Model_Target_PreAmp0.MedusaFullRateFdpCoeffsESDUpperbounddB -
             updatedLokRokScaleFactor);
    }
    else
    {
        /* '<S1324>:1:66' elseif (ESDdB > ESDUpperBound) */
        /*  Stretching is higher than the upper threshold, use smallest allowable Xp. */
        /* '<S1324>:1:68' Xp = minXp; */
    }

    /*  Step 3: Compute updated instantaneous stretch coefficients */
    /* '<S1324>:1:76' updatedLokRokScaleFactor = 0.5 * (Xp/(1-Xp+epsf)); */
    updatedLokRokScaleFactor = qhmath_div_f(minXp, (1.0F - minXp) +
        2.22044605E-16F) * 0.5F;

    /*  Calculate instanstaneous Center Selectivity coefficients based on SPS */
    /* '<S1324>:1:79' instCPS = 1 - SPS; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS[i] = 1.0F -
            Model_Target_B.sf_Coeffs1stStage_m.SPS[i];
    }

    /* '<S1324>:1:80' Lck = instCPS .* Lxk; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk[i] = Model_Target_B.instCPS[i] *
            Model_Target_B.sf_Coeffs1stStage_m.Lxk[i];
    }

    /* '<S1324>:1:81' Rck = instCPS .* Rxk; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.instCPS[delayLen] *=
            Model_Target_B.sf_Coeffs1stStage_m.Rxk[delayLen];
    }

    /*  Use the updated value of Xp to calculate stretch coefficients */
    /* '<S1324>:1:84' Lstrk = min(Lck, updatedLokRokScaleFactor * Lok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] = updatedLokRokScaleFactor *
            Model_Target_B.sf_Coeffs1stStage_m.Lok[i];
    }

    for (row = 0; row < 129; row++)
    {
        Model_Target_B.Lstrk[row] = fminf(Model_Target_B.Lstrk[row],
            Model_Target_B.Multiply_n[row]);
    }

    /* '<S1324>:1:85' Rstrk = min(Rck, updatedLokRokScaleFactor * Rok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] = updatedLokRokScaleFactor *
            Model_Target_B.sf_Coeffs1stStage_m.Rok[i];
    }

    for (row = 0; row < 129; row++)
    {
        Model_Target_B.Multiply_c[row] = fminf(Model_Target_B.instCPS[row],
            Model_Target_B.Multiply_n[row]);
        Model_Target_B.Lstrk[row] *= Model_Target_B.Lin2[row];
    }

    /* MATLAB Function: '<S1348>/MATLAB Function' incorporates:
     *  Constant: '<S1321>/lsGain1'
     *  Constant: '<S1321>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lstrk, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_eb,
        &Model_Target_DW.sf_MATLABFunction_eb);

    /* MATLAB Function: '<S1332>/MATLAB Function' incorporates:
     *  Constant: '<S1321>/lsGain1'
     *  Constant: '<S1321>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lin2, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_ap,
        &Model_Target_DW.sf_MATLABFunction_ap);

    /* Math: '<S1331>/Math Function2' incorporates:
     *  Constant: '<S1331>/Constant1'
     *  S-Function (sdspmultiportsel): '<S1407>/Stereo Split'
     *  Sum: '<S1331>/Add'
     *
     * About '<S1331>/Math Function2':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_ap.y[i] + 2.22044605E-16F);
    }

    /* End of Math: '<S1331>/Math Function2' */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        /* Math: '<S1331>/Math Function1' incorporates:
         *  Math: '<S1313>/Math Function'
         *  Math: '<S1313>/Math Function1'
         *  Math: '<S1331>/Math Function'
         *  Selector: '<S1310>/Selector'
         *  Selector: '<S1310>/Selector1'
         *
         * About '<S1331>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1313>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1331>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_y_i_0 = &Model_Target_B.y_i[delayLen + 129];
        rtb_Sumhighfrequencyenergy = rtb_y_i_0->re * rtb_y_i_0->re +
            rtb_y_i_0->im * rtb_y_i_0->im;

        /* Product: '<S1347>/Multiply' incorporates:
         *  MATLAB Function: '<S1319>/MATLAB Function'
         *  Math: '<S1331>/Math Function1'
         *
         * About '<S1331>/Math Function1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Multiply_n[delayLen] = rtb_Sumhighfrequencyenergy *
            Model_Target_B.Multiply_c[delayLen];

        /* Math: '<S1331>/Math Function1'
         *
         * About '<S1331>/Math Function1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Lstrk[delayLen] = rtb_Sumhighfrequencyenergy;
    }

    /* MATLAB Function: '<S1350>/MATLAB Function' incorporates:
     *  Constant: '<S1321>/lsGain1'
     *  Constant: '<S1321>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Multiply_n, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_ii,
        &Model_Target_DW.sf_MATLABFunction_ii);

    /* MATLAB Function: '<S1333>/MATLAB Function' incorporates:
     *  Constant: '<S1321>/lsGain1'
     *  Constant: '<S1321>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lstrk, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_n0,
        &Model_Target_DW.sf_MATLABFunction_n0);

    /* Math: '<S1331>/Math Function3' incorporates:
     *  Constant: '<S1331>/Constant2'
     *  Product: '<S1366>/Divide'
     *  Sum: '<S1331>/Add1'
     *
     * About '<S1331>/Math Function3':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_n0.y[i] + 2.22044605E-16F);
    }

    /* End of Math: '<S1331>/Math Function3' */

    /* Product: '<S1325>/Multiply' incorporates:
     *  Math: '<S1331>/Math Function'
     *
     * About '<S1331>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_c[i] = Model_Target_B.Lin2[i] *
            Model_Target_B.sf_Coeffs1stStage_m.Lok[i];
    }

    /* End of Product: '<S1325>/Multiply' */

    /* MATLAB Function: '<S1327>/MATLAB Function' incorporates:
     *  Constant: '<S1321>/lsGain1'
     *  Constant: '<S1321>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Multiply_c, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_c,
        &Model_Target_DW.sf_MATLABFunction_c);

    /* Product: '<S1325>/Multiply1' incorporates:
     *  S-Function (sdspmultiportsel): '<S1407>/Stereo Split'
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply1_e[i] = Model_Target_B.sf_MATLABFunction_c.y[i] *
            Model_Target_B.instCPS[i];
    }

    /* End of Product: '<S1325>/Multiply1' */

    /* Product: '<S1326>/Multiply' incorporates:
     *  Math: '<S1331>/Math Function1'
     *
     * About '<S1331>/Math Function1':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_c[i] = Model_Target_B.Lstrk[i] *
            Model_Target_B.sf_Coeffs1stStage_m.Rok[i];
    }

    /* End of Product: '<S1326>/Multiply' */

    /* MATLAB Function: '<S1329>/MATLAB Function' incorporates:
     *  Constant: '<S1321>/lsGain1'
     *  Constant: '<S1321>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Multiply_c, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_ec,
        &Model_Target_DW.sf_MATLABFunction_ec);

    /* Product: '<S1326>/Multiply1' incorporates:
     *  Product: '<S1366>/Divide'
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply1_m[i] = Model_Target_B.sf_MATLABFunction_ec.y[i]
            * Model_Target_B.Multiply_n[i];
    }

    /* End of Product: '<S1326>/Multiply1' */

    /* MATLAB Function: '<S1316>/Coeffs 2nd Stage' incorporates:
     *  Product: '<S1325>/Multiply1'
     *  Product: '<S1326>/Multiply1'
     */
    /*  Update mono coeffs after smoothing far left/right coeffs */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/FullRate/Calculate coefficients/Coeffs 2nd Stage': '<S1318>:1' */
    /*  Left only/right only coefficients */
    /* '<S1318>:1:5' Lxks = 1 - Loks; */
    /* '<S1318>:1:6' Rxks = 1 - Roks; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lxks[i] = 1.0F - Model_Target_B.Multiply1_e[i];
        rtb_Rxks[i] = 1.0F - Model_Target_B.Multiply1_m[i];
    }

    /* End of MATLAB Function: '<S1316>/Coeffs 2nd Stage' */

    /* MATLAB Function: '<S1323>/Normalize Stretch Coeffs' incorporates:
     *  Math: '<S1331>/Math Function'
     *  Product: '<S1340>/Multiply'
     *  Product: '<S1346>/Multiply1'
     *  Product: '<S1347>/Multiply1'
     *  Product: '<S1366>/Divide'
     *  S-Function (sdspmultiportsel): '<S1407>/Stereo Split'
     *
     * About '<S1331>/Math Function':
     *  Operator: magnitude^2
     */
    /*  Normalize stretch coefficients against mono portion  */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/FullRate/Calculate coefficients/Updated Stretch Coeffs and Steering Coeffs/Normalize Stretch Coeffs': '<S1336>:1' */
    /*  Take only difference of L&R strecth coeffs as the total stretch  */
    /* '<S1336>:1:6' netStretch = (Lstrks .* absLi) - (Rstrks.* absRi); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_c[i] = Model_Target_B.sf_MATLABFunction_eb.y[i] *
            Model_Target_B.instCPS[i] *
            Model_Target_B.sf_Coeffs1stStage_m.absLi[i] -
            Model_Target_B.sf_MATLABFunction_ii.y[i] *
            Model_Target_B.Multiply_n[i] *
            Model_Target_B.sf_Coeffs1stStage_m.absRi[i];
    }

    /*  Normalize by the smoothed total shared level  */
    /* '<S1336>:1:9' epsf = single(eps); */
    /* '<S1336>:1:10' LxSmth = (Lxks .* absLi) + epsf; */
    /* '<S1336>:1:11' RxSmth = (Rxks .* absRi) + epsf; */
    /* '<S1336>:1:13' Lstrki = max(0.0, netStretch) ./ LxSmth; */
    for (row = 0; row < 129; row++)
    {
        rtb_Add1_lk[row] = fmaxf(0.0F, Model_Target_B.Multiply_c[row]);
    }

    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        rtb_Add1_lk[delayLen] = qhmath_div_f(rtb_Add1_lk[delayLen],
            Model_Target_B.Lxks[delayLen] *
            Model_Target_B.sf_Coeffs1stStage_m.absLi[delayLen] + 2.22044605E-16F);
    }

    /* '<S1336>:1:14' Rstrki = max(0.0, (-netStretch)) ./ RxSmth; */
    for (row = 0; row < 129; row++)
    {
        updatedLokRokScaleFactor = Model_Target_B.Multiply_c[row];
        rtb_Add1_mry[row] = fmaxf(0.0F, -updatedLokRokScaleFactor);
        Model_Target_B.Multiply_c[row] = -updatedLokRokScaleFactor;
    }

    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        rtb_Add1_mry[delayLen] = qhmath_div_f(rtb_Add1_mry[delayLen],
            rtb_Rxks[delayLen] *
            Model_Target_B.sf_Coeffs1stStage_m.absRi[delayLen] + 2.22044605E-16F);
    }

    /*  Bound the stretch coefficients within [0,1] */
    /* '<S1336>:1:17' Lstrki = min(1.0, max(0.0, Lstrki)); */
    /* '<S1336>:1:18' Rstrki = min(1.0, max(0.0, Rstrki)); */
    for (row = 0; row < 129; row++)
    {
        updatedLokRokScaleFactor = fminf(1.0F, fmaxf(0.0F, rtb_Add1_lk[row]));
        rtb_Sumhighfrequencyenergy = fmaxf(0.0F, rtb_Add1_mry[row]);
        Model_Target_B.Multiply_c[row] = fminf(1.0F, rtb_Sumhighfrequencyenergy);
        rtb_Add1_lk[row] = rtb_Sumhighfrequencyenergy;
        Model_Target_B.Lin2[row] *= updatedLokRokScaleFactor;
    }

    /* MATLAB Function: '<S1342>/MATLAB Function' incorporates:
     *  Constant: '<S1321>/lsGain1'
     *  Constant: '<S1321>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lin2, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_fi,
        &Model_Target_DW.sf_MATLABFunction_fi);

    /* Product: '<S1340>/Multiply1' incorporates:
     *  S-Function (sdspmultiportsel): '<S1407>/Stereo Split'
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lin2[i] = Model_Target_B.sf_MATLABFunction_fi.y[i] *
            Model_Target_B.instCPS[i];
    }

    /* End of Product: '<S1340>/Multiply1' */

    /* Product: '<S1341>/Multiply' incorporates:
     *  MATLAB Function: '<S1323>/Normalize Stretch Coeffs'
     *  Math: '<S1331>/Math Function1'
     *
     * About '<S1331>/Math Function1':
     *  Operator: magnitude^2
     */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.Lstrk[delayLen] *= Model_Target_B.Multiply_c[delayLen];
    }

    /* End of Product: '<S1341>/Multiply' */

    /* MATLAB Function: '<S1344>/MATLAB Function' incorporates:
     *  Constant: '<S1321>/lsGain1'
     *  Constant: '<S1321>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lstrk, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_mm,
        &Model_Target_DW.sf_MATLABFunction_mm);

    /* Product: '<S1341>/Multiply1' incorporates:
     *  Product: '<S1366>/Divide'
     */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.Multiply_n[delayLen] *=
            Model_Target_B.sf_MATLABFunction_mm.y[delayLen];
    }

    /* End of Product: '<S1341>/Multiply1' */

    /* MATLAB Function: '<S1323>/Update Steering Coeffs' */
    Model_Target_UpdateSteeringCoeffs(Model_Target_B.Lin2,
        Model_Target_B.Multiply_n, Model_Target_B.Multiply1_e,
        Model_Target_B.Multiply1_m, Model_Target_B.Lxks, rtb_Rxks,
        &Model_Target_B.sf_UpdateSteeringCoeffs_b);

    /* MATLAB Function: '<S1314>/Apply coefficients' incorporates:
     *  Selector: '<S1310>/Selector'
     *  Selector: '<S1310>/Selector1'
     */
    /*  For full-rate Medusa Processing, since we do not generate the Left Surround */
    /*  and Right Surround signals, the residual is simply the leftover "excess" */
    /*  coefficient, after the far left/far right (Lo/Ro) signals have been extracted. */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/FullRate/Apply coefficients': '<S1315>:1' */
    /*  Left/Right only */
    /* '<S1315>:1:7' Lo = Lok .* L; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.MatrixConcatenate_mb[delayLen].re =
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Lok[delayLen] *
            Model_Target_B.y_i[delayLen].re;
        Model_Target_B.MatrixConcatenate_mb[delayLen].im =
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Lok[delayLen] *
            Model_Target_B.y_i[delayLen].im;
    }

    /* '<S1315>:1:8' Ro = Rok .* R; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.MatrixConcatenate_mb[delayLen + 129].re =
            Model_Target_B.y_i[delayLen + 129].re *
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Rok[delayLen];
        Model_Target_B.MatrixConcatenate_mb[delayLen + 129].im =
            Model_Target_B.y_i[delayLen + 129].im *
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Rok[delayLen];
    }

    /*  Left/Right surround residual */
    /* '<S1315>:1:11' Lsr = Lxk .* L; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.Lsr[delayLen].re =
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Lxk[delayLen] *
            Model_Target_B.y_i[delayLen].re;
        Model_Target_B.Lsr[delayLen].im =
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Lxk[delayLen] *
            Model_Target_B.y_i[delayLen].im;
    }

    /* '<S1315>:1:12' Rsr = Rxk .* R; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.Rsr[delayLen].re = Model_Target_B.y_i[delayLen + 129].re *
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Rxk[delayLen];
        Model_Target_B.Rsr[delayLen].im = Model_Target_B.y_i[delayLen + 129].im *
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Rxk[delayLen];
    }

    /* End of MATLAB Function: '<S1314>/Apply coefficients' */

    /* Product: '<S1356>/Divide' incorporates:
     *  Constant: '<S1356>/Constant'
     *  Constant: '<S1356>/Constant1'
     *  Product: '<S1367>/Divide'
     *  Sum: '<S1356>/Minus'
     */
    updatedLokRokScaleFactor_tmp = (1.0F -
        Model_Target_PreAmp0.MedusaFullRateFdpSpumFastPsdSmoothFactor) * 0.5F;

    /* Sum: '<S1357>/Matrix Sum' */
    rtb_Delay_og = -0.0F;
    for (i = 0; i < 129; i++)
    {
        /* Math: '<S1313>/Math Function' incorporates:
         *  Math: '<S1313>/Math Function1'
         *  Math: '<S1331>/Math Function'
         *  Math: '<S1331>/Math Function1'
         *  Selector: '<S1310>/Selector'
         *  Selector: '<S1310>/Selector1'
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1313>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1331>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1331>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_i_0 = &Model_Target_B.Lsr[i];

        /* Math: '<S1313>/Math Function'
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_B.MathFunction[i] = rtb_y_i_0->re * rtb_y_i_0->re +
            rtb_y_i_0->im * rtb_y_i_0->im;

        /* Sum: '<S1356>/Add1' incorporates:
         *  Delay: '<S1356>/Delay'
         *  Delay: '<S1356>/Delay1'
         *  Math: '<S1313>/Math Function'
         *  Product: '<S1356>/Divide'
         *  Product: '<S1356>/Multiply'
         *  Product: '<S1356>/Multiply1'
         *  Sum: '<S1356>/Add'
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_B.Lin2[i] = (Model_Target_B.MathFunction[i] +
            Model_Target_DW.Delay_DSTATE_i[i]) * updatedLokRokScaleFactor_tmp +
            Model_Target_DW.Delay1_DSTATE[i] *
            Model_Target_PreAmp0.MedusaFullRateFdpSpumFastPsdSmoothFactor;

        /* Sum: '<S1357>/Matrix Sum' incorporates:
         *  Math: '<S1313>/Math Function'
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_Delay_og += Model_Target_B.MathFunction[i];
    }

    /* Sum: '<S1360>/Sum2' incorporates:
     *  Constant: '<S1360>/Constant'
     *  Gain: '<S1360>/Gain'
     *  Math: '<S1360>/log10'
     *  Sum: '<S1360>/Sum1'
     *
     * About '<S1360>/log10':
     *  Operator: log10
     */
    updatedLokRokScaleFactor = qhmath_log10_f(rtb_Delay_og + 2.22044605E-16F) *
        10.0F;

    /* MATLAB Function: '<S1357>/Detect Impulse' incorporates:
     *  Delay: '<S1357>/Delay'
     *  Sum: '<S1357>/Add1'
     */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/Reverb Extractions/Left Reverb Extraction/Compute PSD/Impulse Detector/Detect Impulse': '<S1359>:1' */
    /* '<S1359>:1:5' if isempty(counter) */
    /* '<S1359>:1:6' if isempty(state) */
    /* '<S1359>:1:8' if (EnergyDifference > DetectImpulseThreshold) */
    if (updatedLokRokScaleFactor - Model_Target_DW.Delay_DSTATE_n > 0.75F)
    {
        /* '<S1359>:1:9' isImpulsive = 1; */
        rtb_isImpulsive_g = 1;

        /* '<S1359>:1:10' counter = 0; */
        Model_Target_DW.counter_b = 0.0;
    }
    else if ((Model_Target_DW.counter_b <
              Model_Target_MaxValueOfCounterForDetectingImpulse_n) &&
             (Model_Target_DW.state_l == 1.0))
    {
        /* '<S1359>:1:11' elseif (counter < MaxValueOfCounterForDetectingImpulse) && (state == 1) */
        /* '<S1359>:1:12' isImpulsive = 1; */
        rtb_isImpulsive_g = 1;

        /* '<S1359>:1:13' counter = counter + 1; */
        Model_Target_DW.counter_b++;
    }
    else
    {
        /* '<S1359>:1:14' else */
        /* '<S1359>:1:15' isImpulsive = 0; */
        rtb_isImpulsive_g = 0;
    }

    /* '<S1359>:1:17' state = isImpulsive; */
    Model_Target_DW.state_l = rtb_isImpulsive_g;

    /* End of MATLAB Function: '<S1357>/Detect Impulse' */

    /* Product: '<S1358>/Divide' incorporates:
     *  Constant: '<S1358>/Constant'
     *  Constant: '<S1358>/Constant1'
     *  Product: '<S1369>/Divide'
     *  Sum: '<S1358>/Minus'
     */
    minXp_tmp = (1.0F -
                 Model_Target_PreAmp0.MedusaFullRateFdpSpumSlowPsdSmoothFactor) *
        0.5F;

    /* Sum: '<S1358>/Add1' incorporates:
     *  Delay: '<S1358>/Delay'
     *  Delay: '<S1358>/Delay1'
     *  Math: '<S1313>/Math Function'
     *  Product: '<S1358>/Divide'
     *  Product: '<S1358>/Multiply'
     *  Product: '<S1358>/Multiply1'
     *  Sum: '<S1358>/Add'
     *
     * About '<S1313>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        rtb_Add1_lk[i] = (Model_Target_B.MathFunction[i] +
                          Model_Target_DW.Delay_DSTATE_l[i]) * minXp_tmp +
            Model_Target_DW.Delay1_DSTATE_a[i] *
            Model_Target_PreAmp0.MedusaFullRateFdpSpumSlowPsdSmoothFactor;
    }

    /* End of Sum: '<S1358>/Add1' */

    /* Delay: '<S1354>/Delay' incorporates:
     *  Sum: '<S1356>/Add1'
     */
    if (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec < 1.0F)
    {
        memcpy(&Model_Target_B.Multiply1_e[0], &Model_Target_B.Lin2[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec >
                2064.0F)
        {
            delayLen = 2064;
        }
        else
        {
            delayLen = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (i = 0; i < 129; i++)
        {
            if ((uint32_T)i < (uint32_T)delayLen)
            {
                Model_Target_B.Multiply1_e[i] =
                    Model_Target_DW.MedusaDRspumLPxxFast[(i - delayLen) + 2064];
            }
            else
            {
                Model_Target_B.Multiply1_e[i] = Model_Target_B.Lin2[i - delayLen];
            }
        }
    }

    /* End of Delay: '<S1354>/Delay' */

    /* Delay: '<S1354>/Delay1' incorporates:
     *  Sum: '<S1358>/Add1'
     */
    if (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec < 1.0F)
    {
        memcpy(&Model_Target_B.Multiply1_m[0], &rtb_Add1_lk[0], 129U * sizeof
               (real32_T));
    }
    else
    {
        if (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec >
                2064.0F)
        {
            delayLen = 2064;
        }
        else
        {
            delayLen = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (i = 0; i < 129; i++)
        {
            if ((uint32_T)i < (uint32_T)delayLen)
            {
                Model_Target_B.Multiply1_m[i] =
                    Model_Target_DW.MedusaDRspumLPxxSlow[(i - delayLen) + 2064];
            }
            else
            {
                Model_Target_B.Multiply1_m[i] = rtb_Add1_lk[i - delayLen];
            }
        }
    }

    /* End of Delay: '<S1354>/Delay1' */

    /* Buffer: '<S1207>/Buffer' */
    delayLen = 0;
    currentOffset = Model_Target_DW.Buffer_outBufPtrIdx + 128;
    for (row = 0; row < 2; row++)
    {
        memIdx = (row << 8) + Model_Target_DW.Buffer_outBufPtrIdx;
        memcpy(&Model_Target_B.Buffer[delayLen],
               &Model_Target_DW.Buffer_CircBuf[memIdx], sizeof(real32_T) << 7U);
        delayLen += 128;
    }

    if (Model_Target_DW.Buffer_outBufPtrIdx + 128 == 256)
    {
        currentOffset = 0;
    }

    Model_Target_DW.Buffer_outBufPtrIdx = currentOffset;

    /* End of Buffer: '<S1207>/Buffer' */

    /* Sum: '<S1406>/Sum high  frequency energy' */
    rtb_Sumhighfrequencyenergy = -0.0F;
    for (row = 0; row < 128; row++)
    {
        /* S-Function (sdspmultiportsel): '<S1407>/Stereo Split' incorporates:
         *  Buffer: '<S1207>/Buffer'
         */
        minXp = Model_Target_B.Buffer[row];
        slewedStepSize = Model_Target_B.Buffer[row + 128];

        /* Sum: '<S1407>/Add' incorporates:
         *  Math: '<S1407>/Magnitude Squared'
         *  Math: '<S1407>/Magnitude Squared1'
         *
         * About '<S1407>/Magnitude Squared':
         *  Operator: magnitude^2
         *
         * About '<S1407>/Magnitude Squared1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Add[row] = minXp * minXp + slewedStepSize *
            slewedStepSize;

        /* Sum: '<S1406>/Sum high  frequency energy' incorporates:
         *  Sum: '<S1407>/Add'
         */
        rtb_Sumhighfrequencyenergy += Model_Target_B.Add[row];
    }

    /* Sum: '<S1412>/Add1' incorporates:
     *  Constant: '<S1412>/Constant'
     *  Constant: '<S1412>/Constant1'
     *  Delay: '<S1412>/Delay'
     *  Delay: '<S1412>/Delay1'
     *  Product: '<S1412>/Divide'
     *  Product: '<S1412>/Multiply'
     *  Product: '<S1412>/Multiply1'
     *  Sum: '<S1412>/Add'
     *  Sum: '<S1412>/Minus'
     */
    minXp = (1.0F - Model_Target_PreAmp0.MedusaSPUMDecayEstPSDSmoothFactor) *
        0.5F * (rtb_Sumhighfrequencyenergy + Model_Target_DW.Delay_DSTATE_i3) +
        Model_Target_DW.Delay1_DSTATE_p *
        Model_Target_PreAmp0.MedusaSPUMDecayEstPSDSmoothFactor;

    /* MATLAB Function: '<S1406>/Estimate Decay' incorporates:
     *  BusCreator generated from: '<S1406>/Estimate Decay'
     *  Constant: '<S1416>/Constant'
     *  Gain: '<S1406>/Gain'
     *  Gain: '<S1416>/Gain'
     *  Math: '<S1416>/log10'
     *  Sum: '<S1416>/Sum1'
     *
     * About '<S1416>/log10':
     *  Operator: log10
     */
    /*  Estimate and output decay on linear scale  */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/SPUM Decay Estimate/Decay Estimate/Estimate Decay': '<S1409>:1' */
    /*  Buffer holding frame energies in dB */
    /*  Flag to indicate onset strike is on */
    /*  Flag to indicate onset strike is off */
    /*  No activity counter, 'gcounter' in AR model */
    /*  Previous decay slope in dB, 'decay_slope_in_db_per_frame' in bdsp */
    /*  Previous smoothed decay slope in dB */
    /*  Frame energy in dB to allow current onset thresholding, 'gate' in AR model */
    /*  Initialize parameters */
    /* '<S1409>:1:14' if isempty(onsetOn) */
    /* '<S1409>:1:15' if isempty(onsetOff) */
    /* '<S1409>:1:16' if isempty(onsetCounter) */
    /* '<S1409>:1:17' if isempty(noOnsetOnOffCounter) */
    /* '<S1409>:1:18' if isempty(prevDecay) */
    /* '<S1409>:1:19' if isempty(smoothedDecay) */
    /* '<S1409>:1:20' if isempty(thresholdForFrameEnergy) */
    /*  Update frame energies buffer */
    /*  latest energy is always the last frame */
    /*  TODO: implement with circular buffer */
    /* '<S1409>:1:27' frameEnergiesdB(1:end-1) = frameEnergiesdB(2:end); */
    for (delayLen = 0; delayLen < 7; delayLen++)
    {
        Model_Target_DW.frameEnergiesdB[delayLen] =
            Model_Target_DW.frameEnergiesdB[delayLen + 1];
    }

    /* '<S1409>:1:28' frameEnergiesdB(end) = frameEnergydB; */
    Model_Target_DW.frameEnergiesdB[7] = qhmath_log10_f(100.0F * minXp +
        2.22044605E-16F) * 10.0F;

    /*  persistent writeIndex; */
    /*  frameEnergiesdB(writeIndex) = frameEnergydB; */
    /*  writeIndex = mod(writeIndex+1,lengthFrameEnergiesBuffer); */
    /*  derivative = least_square_fit(frameEnergiesdB, writeIndex); */
    /*  Estimate derivative (slope) using first order least square fitting */
    /* '<S1409>:1:36' derivative = least_square_fit(frameEnergiesdB,... */
    /* '<S1409>:1:37'                 decayConst.numPointsForSlopeComputation,... */
    /* '<S1409>:1:38'                 decayConst.lengthFrameEnergiesBuffer); */
    /*  Estimate derivative or slope via first order least square fitting.  */
    /*  Implements following equation to compute k. */
    /*   */
    /*  x = [X_0, X_1, X_2, ..., X_(N-1)] = frame indicies */
    /*  y = [Y_0, Y_1, Y_2, ..., X_(N-1)] = frame energies */
    /*   */
    /*       sum(Xi * Yi) - (1/N) * sum(Xi) * sum(Yi) */
    /*  k = ------------------------------------------- , */
    /*       sum(Xi * Xi) - (1/N) * sum(Xi) * sum(Xi) */
    /*     where i = 0, 1, 2, ... , N-1. */
    /*  */
    /*  M = lengthFrameEnergiesBuffer = 8 ; */
    /*  N = numPointsForSlopeComputation = 5; */
    /* '<S1409>:1:130' y = in(M-N+1:M); */
    /* '<S1409>:1:131' x = (0:size(y,1)-1)'; */
    /* '<S1409>:1:132' d = (sum(x.*y) - sum(x)*sum(y)/N) / (sum(x.^2) - (sum(x))^2/N + single(eps)); */
    for (delayLen = 0; delayLen < 5; delayLen++)
    {
        y[delayLen] = Model_Target_DW.frameEnergiesdB[delayLen + 3] * (real32_T)
            delayLen;
    }

    rtb_Delay_og = qhmath_div_f(((((y[0] + y[1]) + y[2]) + y[3]) + y[4]) -
        qhmath_div_f(((((Model_Target_DW.frameEnergiesdB[3] +
                         Model_Target_DW.frameEnergiesdB[4]) +
                        Model_Target_DW.frameEnergiesdB[5]) +
                       Model_Target_DW.frameEnergiesdB[6]) +
                      Model_Target_DW.frameEnergiesdB[7]) * 10.0F, 5.0F), 10.0F);

    /*  x = 0:size(y,1); */
    /*  derivative = (sum(x.*y) - sum(x)*sum(y)/N) / (sum(x.^2) - (sum(x))^2/N + epsf); */
    /*  Increment no onset on/off counter by 1 */
    /* '<S1409>:1:43' noOnsetOnOffCounter = noOnsetOnOffCounter + 1; */
    Model_Target_DW.noOnsetOnOffCounter++;

    /*  Detect onset on */
    /*  if level jump (energy variation) > onset threshold AND  */
    /*  input level (current frame energy) > input threshold */
    /* '<S1409>:1:48' latestEnergy = frameEnergiesdB(end); */
    /* '<S1409>:1:49' oldestEnergy = frameEnergiesdB(1); */
    /* '<S1409>:1:50' onsetVal =  latestEnergy - oldestEnergy; */
    /* '<S1409>:1:51' if (onsetVal > decayEstTunable.onsetThreshold) && (latestEnergy > thresholdForFrameEnergy) */
    if ((Model_Target_DW.frameEnergiesdB[7] - Model_Target_DW.frameEnergiesdB[0]
         > Model_Target_PreAmp0.MedusaSPUMDecayEstOnsetThreshold) &&
            (Model_Target_DW.frameEnergiesdB[7] >
             Model_Target_DW.thresholdForFrameEnergy))
    {
        /* '<S1409>:1:52' onsetOn = 1; */
        Model_Target_DW.onsetOn = 1.0;

        /* '<S1409>:1:53' thresholdForFrameEnergy = latestEnergy - 3; */
        Model_Target_DW.thresholdForFrameEnergy =
            Model_Target_DW.frameEnergiesdB[7] - 3.0F;

        /*  threshold = current - 3dB */
        /* '<S1409>:1:54' onsetCounter = 0; */
        Model_Target_DW.onsetCounter = 0.0;
    }

    /*  Validate onset */
    /* '<S1409>:1:58' if onsetOn */
    if (Model_Target_DW.onsetOn != 0.0)
    {
        /* '<S1409>:1:59' onsetCounter = onsetCounter + 1; */
        Model_Target_DW.onsetCounter++;

        /* '<S1409>:1:60' if onsetCounter >  decayConst.onsetCounterLimit */
        if (Model_Target_DW.onsetCounter > 700.0)
        {
            /*  timeout and reset */
            /* '<S1409>:1:61' onsetOn = 0; */
            Model_Target_DW.onsetOn = 0.0;

            /* '<S1409>:1:62' onsetCounter = 0; */
            Model_Target_DW.onsetCounter = 0.0;
        }
    }

    /*  Detect onset off */
    /*  if energy variation < threshold AND input level < input threshold */
    /*  AND onsetOn detected AND onsetOff not yet detected */
    /* '<S1409>:1:69' if (derivative < decayConst.decaySlowest) && (onsetOn == 1) && (onsetOff == 0)... */
    /* '<S1409>:1:70'         && (latestEnergy < thresholdForFrameEnergy) */
    if ((rtb_Delay_og < -0.0693333298F) && (Model_Target_DW.onsetOn == 1.0) &&
            (Model_Target_DW.onsetOff == 0.0) &&
            (Model_Target_DW.frameEnergiesdB[7] <
             Model_Target_DW.thresholdForFrameEnergy))
    {
        /* '<S1409>:1:71' onsetOff = 1; */
        Model_Target_DW.onsetOff = 1.0;

        /* '<S1409>:1:72' thresholdForFrameEnergy = decayConst.minGateFrameEnergydB; */
        Model_Target_DW.thresholdForFrameEnergy = -25.0F;
    }

    /*  Update slope */
    /* '<S1409>:1:76' if (onsetOn == 1) && (onsetOff == 1) */
    if ((Model_Target_DW.onsetOn == 1.0) && (Model_Target_DW.onsetOff == 1.0))
    {
        /* '<S1409>:1:77' if (oldestEnergy > latestEnergy) && (oldestEnergy > decayEstTunable.noiseFloor) */
        if (Model_Target_DW.frameEnergiesdB[0] >
                Model_Target_DW.frameEnergiesdB[7])
        {
            if (Model_Target_DW.frameEnergiesdB[0] >
                    Model_Target_PreAmp0.MedusaSPUMDecayEstNoiseFloor)
            {
                /* '<S1409>:1:78' slope = derivative; */
                /*  take the slope as decay estimate */
                /* '<S1409>:1:79' noOnsetOnOffCounter = 0; */
                Model_Target_DW.noOnsetOnOffCounter = 0.0;

                /*  reset no activity counter */
                /* '<S1409>:1:80' onsetCounter = 0; */
                Model_Target_DW.onsetCounter = 0.0;

                /*  reset counter   */
            }
            else
            {
                /* '<S1409>:1:81' else */
                /* '<S1409>:1:82' slope = prevDecay; */
                rtb_Delay_og = Model_Target_DW.prevDecay;
            }
        }
        else
        {
            /* '<S1409>:1:81' else */
            /* '<S1409>:1:82' slope = prevDecay; */
            rtb_Delay_og = Model_Target_DW.prevDecay;
        }

        /* '<S1409>:1:84' prevDecay = slope; */
        Model_Target_DW.prevDecay = rtb_Delay_og;

        /* '<S1409>:1:85' onsetOn = 0; */
        Model_Target_DW.onsetOn = 0.0;

        /* '<S1409>:1:86' onsetOff = 0; */
        Model_Target_DW.onsetOff = 0.0;
    }
    else
    {
        /* '<S1409>:1:87' else */
        /* '<S1409>:1:88' slope = prevDecay; */
        rtb_Delay_og = Model_Target_DW.prevDecay;
    }

    /*  Validate slope */
    /*  if no onset detected for a predefined period, return to the default decay value */
    /* '<S1409>:1:93' if noOnsetOnOffCounter > decayConst.decayDefaultCounterLimit */
    if (Model_Target_DW.noOnsetOnOffCounter > 10385.0)
    {
        /* '<S1409>:1:94' slope = decayConst.decayDefaultSlope; */
        rtb_Delay_og = -0.173333332F;

        /* '<S1409>:1:95' noOnsetOnOffCounter = 0; */
        Model_Target_DW.noOnsetOnOffCounter = 0.0;
    }

    /*  Smooth slope  */
    /*  using first order averaging with different smoothing params (fast or  */
    /*  slow) depending on estimated slope */
    /* '<S1409>:1:101' if slope >= smoothedDecay */
    if (rtb_Delay_og >= Model_Target_DW.smoothedDecay)
    {
        /* '<S1409>:1:102' alpha = decayEstTunable.slowAttack; */
        maxXp = Model_Target_PreAmp0.MedusaSPUMDecayEstSlowAttack;
    }
    else
    {
        /* '<S1409>:1:103' else */
        /* '<S1409>:1:104' alpha = decayEstTunable.fastAttack; */
        maxXp = Model_Target_PreAmp0.MedusaSPUMDecayEstFastAttack;
    }

    /* '<S1409>:1:106' smoothedDecay = slope*alpha + (1-alpha)*smoothedDecay; */
    Model_Target_DW.smoothedDecay = (1.0F - maxXp) *
        Model_Target_DW.smoothedDecay + rtb_Delay_og * maxXp;

    /* '<S1409>:1:107' noOnsetOnOffCounter = noOnsetOnOffCounter + 1; */
    Model_Target_DW.noOnsetOnOffCounter++;

    /*  Clip the estimated smoothed decay slope (in db/frame) and convert it to  */
    /*  linear decay for smoothing next. */
    /* '<S1409>:1:111' decay = undb10(max(min(smoothedDecay, decayConst.decaySlowest), ... */
    /* '<S1409>:1:112'     decayConst.decayFastest) * decayEstTunable.directPathFramesFs); */
    /* '<S1409>:1:136' y = exp(x * log(10)/10); */
    rtb_Delay_og = qhmath_exp_f(qhmath_div_f(fmaxf(fminf
        (Model_Target_DW.smoothedDecay, -0.0693333298F), -0.346666664F) *
        Model_Target_PreAmp0.MedusaSPUMDecayEstDirectPathFramesFs * 2.30258512F,
        10.0F));

    /* End of MATLAB Function: '<S1406>/Estimate Decay' */

    /* MATLAB Function: '<S1406>/Smooth Decay' */
    /*  This is basically the same as Forward-backward Smooth block. */
    /*  However as the initial conditions depend on a TOP and build-time config, */
    /*  a Matlab implementation was done for simplification. */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/SPUM Decay Estimate/Decay Estimate/Smooth Decay': '<S1411>:1' */
    /* '<S1411>:1:8' if isempty(lastInput) */
    if (!Model_Target_DW.lastInput_not_empty)
    {
        /* '<S1411>:1:8' ; */
        /* '<S1411>:1:8' lastInput = single(undb10(decayConst.decayDefaultSlope * directPathFrames)); */
        /* '<S1411>:1:21' y = exp(x * log(10)/10); */
        Model_Target_DW.lastInput = qhmath_div_f(-0.173333332F *
            Model_Target_PreAmp0.MedusaSPUMDecayEstDirectPathFramesFs *
            2.30258512F, 10.0F);
        Model_Target_DW.lastInput = qhmath_exp_f(Model_Target_DW.lastInput);
        Model_Target_DW.lastInput_not_empty = true;
    }

    /* '<S1411>:1:9' if isempty(lastOutput) */
    if (!Model_Target_DW.lastOutput_not_empty)
    {
        /* '<S1411>:1:9' ; */
        /* '<S1411>:1:9' lastOutput = single(undb10(decayConst.decayDefaultSlope * directPathFrames)); */
        /* '<S1411>:1:21' y = exp(x * log(10)/10); */
        Model_Target_DW.lastOutput = qhmath_div_f(-0.173333332F *
            Model_Target_PreAmp0.MedusaSPUMDecayEstDirectPathFramesFs *
            2.30258512F, 10.0F);
        Model_Target_DW.lastOutput = qhmath_exp_f(Model_Target_DW.lastOutput);
        Model_Target_DW.lastOutput_not_empty = true;
    }

    /* '<S1411>:1:11' pole = alpha; */
    /* '<S1411>:1:12' gain = (1 - alpha)/2; */
    /* '<S1411>:1:14' Output = (Input + lastInput) * gain + lastOutput * pole; */
    maxXp = (rtb_Delay_og + Model_Target_DW.lastInput) * qhmath_div_f(1.0F -
        Model_Target_PreAmp0.MedusaSPUMDecayEstDecaySmoothFactor, 2.0F) +
        Model_Target_DW.lastOutput *
        Model_Target_PreAmp0.MedusaSPUMDecayEstDecaySmoothFactor;

    /* '<S1411>:1:15' lastInput = Input; */
    Model_Target_DW.lastInput = rtb_Delay_og;

    /* '<S1411>:1:16' lastOutput = Output; */
    Model_Target_DW.lastOutput = maxXp;

    /* End of MATLAB Function: '<S1406>/Smooth Decay' */

    /* MATLAB Function: '<S1406>/Slew Decay' incorporates:
     *  BusCreator generated from: '<S1406>/Slew Decay'
     */
    /*  Control how abruptly the decay can change from frame to frame. */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/SPUM Decay Estimate/Decay Estimate/Slew Decay': '<S1410>:1' */
    /* '<S1410>:1:3' epsf = single(eps); */
    /*  difference of current and past decay in dB */
    /* '<S1410>:1:8' if isempty(prevDelta) */
    /* '<S1410>:1:9' if isempty(prevStepSize) */
    /* '<S1410>:1:10' if isempty(prevSmoothedDecaydB) */
    if (!Model_Target_DW.prevSmoothedDecaydB_not_empty)
    {
        /*  Initial value is decay default in dB */
        /* '<S1410>:1:12' prevSmoothedDecaydB = single(decayConst.decayDefaultSlope * directPathFrames); */
        Model_Target_DW.prevSmoothedDecaydB = -0.173333332F *
            Model_Target_PreAmp0.MedusaSPUMDecayEstDirectPathFramesFs;
        Model_Target_DW.prevSmoothedDecaydB_not_empty = true;
    }

    /* '<S1410>:1:15' smoothedDecaydB = db10(smoothedDecayLinear + epsf); */
    /* '<S1410>:1:48' y = 10*log10(x); */
    /* '<S1410>:1:16' delta = smoothedDecaydB - prevSmoothedDecaydB; */
    rtb_Delay_og = qhmath_log10_f(maxXp + 2.22044605E-16F) * 10.0F -
        Model_Target_DW.prevSmoothedDecaydB;

    /* '<S1410>:1:17' if delta > 0 */
    if (rtb_Delay_og > 0.0F)
    {
        /*  Move up if difference is positive => increasing */
        /* '<S1410>:1:19' stepSize = min(decaySlewTunable.slewIncrement, delta); */
        maxXp = fminf(Model_Target_PreAmp0.MedusaSPUMDecayEstStepIncrement,
                      rtb_Delay_og);
    }
    else
    {
        /* '<S1410>:1:20' else */
        /*  Move down if difference is negative => decreasing */
        /* '<S1410>:1:22' stepSize = max(decaySlewTunable.slewDecrement, delta); */
        maxXp = fmaxf(Model_Target_PreAmp0.MedusaSPUMDecayEstStepDecrement,
                      rtb_Delay_og);
    }

    /*  If equal sign then still moving in previous direction => keep moving, */
    /*  else reach target and no slewing required */
    /* '<S1410>:1:27' if prevDelta * delta > 0 */
    if (Model_Target_DW.prevDelta * rtb_Delay_og > 0.0F)
    {
        /* '<S1410>:1:28' slewedStepSize = prevStepSize; */
        slewedStepSize = Model_Target_DW.prevStepSize;
    }
    else
    {
        /* '<S1410>:1:29' else */
        /* '<S1410>:1:30' slewedStepSize = single(0); */
        slewedStepSize = 0.0F;
    }

    /*  If the difference is within upper bound and slewed stepsize */
    /*  still respects instanteneous stepsize, we can trust slewed stepsize. */
    /* '<S1410>:1:35' if (abs(delta) <= decaySlewTunable.slewThreshold) && (abs(slewedStepSize) < abs(stepSize)) */
    if ((qhmath_abs_f(rtb_Delay_og) <=
            Model_Target_PreAmp0.MedusaSPUMDecayEstSlewThreshold) &&
            (qhmath_abs_f(slewedStepSize) < qhmath_abs_f(maxXp)))
    {
        /* '<S1410>:1:36' stepSize = slewedStepSize; */
        maxXp = slewedStepSize;
    }

    /*  Update states and output */
    /* '<S1410>:1:40' prevDelta = delta; */
    Model_Target_DW.prevDelta = rtb_Delay_og;

    /* '<S1410>:1:41' prevStepSize = stepSize; */
    Model_Target_DW.prevStepSize = maxXp;

    /* '<S1410>:1:42' prevSmoothedDecaydB = prevSmoothedDecaydB + stepSize; */
    Model_Target_DW.prevSmoothedDecaydB += maxXp;

    /* Product: '<S1207>/Multiply' incorporates:
     *  DataTypeConversion: '<S1207>/Cast To Single'
     *  MATLAB Function: '<S1406>/Slew Decay'
     */
    /* '<S1410>:1:43' slewedDecayLinear = undb10(prevSmoothedDecaydB); */
    /* '<S1410>:1:52' y = exp(x * log(10)/10); */
    Model_Target_B.Multiply = qhmath_exp_f(qhmath_div_f
        (Model_Target_DW.prevSmoothedDecaydB * 2.30258512F, 10.0F)) * (real32_T)
        Model_Target_B.Merge;

    /* Product: '<S1363>/Divide' incorporates:
     *  Constant: '<S1363>/Constant'
     *  Constant: '<S1363>/Constant1'
     *  Product: '<S1364>/Divide'
     *  Product: '<S1374>/Divide'
     *  Product: '<S1375>/Divide'
     *  Sum: '<S1363>/Minus'
     */
    maxXp = (1.0F - Model_Target_PreAmp0.MedusaFullRateFdpSpumLsSmoothFactor) *
        0.5F;

    /* Sum: '<S1368>/Matrix Sum' */
    rtb_Delay_og = -0.0F;
    for (i = 0; i < 129; i++)
    {
        real32_T rtb_Add1_i4;

        /* Switch: '<S1352>/Switch' incorporates:
         *  Constant: '<S1352>/Constant'
         *  Constant: '<S1352>/Constant1'
         *  MinMax: '<S1352>/Min'
         *  Product: '<S1352>/Divide'
         *  Product: '<S1352>/Multiply'
         *  Sum: '<S1352>/Add'
         *  Switch: '<S1354>/Switch'
         *  Switch: '<S1354>/Switch1'
         */
        if (Model_Target_PreAmp0.MedusaFullRateFdpSpumOverwrite != 0.0F)
        {
            slewedStepSize = 1.0F;
        }
        else
        {
            if (rtb_isImpulsive_g > 0)
            {
                /* Switch: '<S1354>/Switch1' incorporates:
                 *  Sum: '<S1356>/Add1'
                 */
                slewedStepSize = Model_Target_B.Lin2[i];

                /* Switch: '<S1354>/Switch' incorporates:
                 *  Delay: '<S1354>/Delay'
                 */
                rtb_R_re = Model_Target_B.Multiply1_e[i];
            }
            else
            {
                /* Switch: '<S1354>/Switch1' incorporates:
                 *  Sum: '<S1358>/Add1'
                 */
                slewedStepSize = rtb_Add1_lk[i];

                /* Switch: '<S1354>/Switch' incorporates:
                 *  Delay: '<S1354>/Delay1'
                 */
                rtb_R_re = Model_Target_B.Multiply1_m[i];
            }

            slewedStepSize = fminf(1.0F, qhmath_div_f(1.0F, slewedStepSize +
                                    2.22044605E-16F) * (rtb_R_re *
                                    Model_Target_B.Multiply));
        }

        /* End of Switch: '<S1352>/Switch' */

        /* Product: '<S1355>/Multiply' incorporates:
         *  Math: '<S1313>/Math Function'
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         */
        slewedStepSize *= Model_Target_B.MathFunction[i];

        /* Sum: '<S1363>/Add1' incorporates:
         *  Delay: '<S1363>/Delay'
         *  Delay: '<S1363>/Delay1'
         *  Product: '<S1363>/Divide'
         *  Product: '<S1363>/Multiply'
         *  Product: '<S1363>/Multiply1'
         *  Sum: '<S1363>/Add'
         */
        Model_Target_B.Multiply1_m[i] = (slewedStepSize +
            Model_Target_DW.Delay_DSTATE_m[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_o[i] *
            Model_Target_PreAmp0.MedusaFullRateFdpSpumLsSmoothFactor;

        /* Product: '<S1355>/Multiply' */
        Model_Target_B.Multiply1_e[i] = slewedStepSize;

        /* Sum: '<S1364>/Add1' incorporates:
         *  Delay: '<S1364>/Delay'
         *  Delay: '<S1364>/Delay1'
         *  Math: '<S1313>/Math Function'
         *  Product: '<S1364>/Multiply'
         *  Product: '<S1364>/Multiply1'
         *  Sum: '<S1364>/Add'
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_Add1_i4 = (Model_Target_B.MathFunction[i] +
                       Model_Target_DW.Delay_DSTATE_k[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_l[i] *
            Model_Target_PreAmp0.MedusaFullRateFdpSpumLsSmoothFactor;

        /* Product: '<S1355>/Multiply1' incorporates:
         *  Constant: '<S1355>/Constant'
         *  Product: '<S1355>/Divide'
         *  Sum: '<S1355>/Add'
         *  Sum: '<S1355>/Subtract'
         *  Sum: '<S1363>/Add1'
         */
        rtb_R_re_tmp = qhmath_div_f(Model_Target_B.Multiply1_m[i], rtb_Add1_i4 +
            2.22044605E-16F);
        slewedStepSize = Model_Target_B.Lsr[i].re;
        rtb_R_re = rtb_R_re_tmp * slewedStepSize;
        rtb_R_im_tmp = Model_Target_B.Lsr[i].im;
        rtb_R_re_tmp *= rtb_R_im_tmp;

        /* Sum: '<S1355>/Subtract' */
        Model_Target_B.MatrixConcatenate_mb[i + 258].re = slewedStepSize -
            rtb_R_re;
        Model_Target_B.MatrixConcatenate_mb[i + 258].im = rtb_R_im_tmp -
            rtb_R_re_tmp;

        /* SignalConversion generated from: '<S1308>/Matrix Concatenate' */
        Model_Target_B.MatrixConcatenate_mb[i + 387].re = rtb_R_re;
        Model_Target_B.MatrixConcatenate_mb[i + 387].im = rtb_R_re_tmp;

        /* Math: '<S1313>/Math Function1' incorporates:
         *  Math: '<S1313>/Math Function'
         *  Math: '<S1331>/Math Function'
         *  Math: '<S1331>/Math Function1'
         *  Selector: '<S1310>/Selector'
         *  Selector: '<S1310>/Selector1'
         *
         * About '<S1313>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1331>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1331>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_i_0 = &Model_Target_B.Rsr[i];
        Model_Target_B.instCPS[i] = rtb_y_i_0->re * rtb_y_i_0->re +
            rtb_y_i_0->im * rtb_y_i_0->im;

        /* Sum: '<S1364>/Add1' */
        rtb_Add1_mry[i] = rtb_Add1_i4;

        /* Sum: '<S1367>/Add' incorporates:
         *  Math: '<S1313>/Math Function1'
         *
         * About '<S1313>/Math Function1':
         *  Operator: magnitude^2
         */
        slewedStepSize = Model_Target_B.instCPS[i];

        /* Sum: '<S1367>/Add1' incorporates:
         *  Delay: '<S1367>/Delay'
         *  Delay: '<S1367>/Delay1'
         *  Product: '<S1367>/Multiply'
         *  Product: '<S1367>/Multiply1'
         *  Sum: '<S1367>/Add'
         */
        Model_Target_B.Multiply_c[i] = (slewedStepSize +
            Model_Target_DW.Delay_DSTATE_e[i]) * updatedLokRokScaleFactor_tmp +
            Model_Target_DW.Delay1_DSTATE_e[i] *
            Model_Target_PreAmp0.MedusaFullRateFdpSpumFastPsdSmoothFactor;

        /* Sum: '<S1368>/Matrix Sum' */
        rtb_Delay_og += slewedStepSize;
    }

    /* Sum: '<S1371>/Sum2' incorporates:
     *  Constant: '<S1371>/Constant'
     *  Gain: '<S1371>/Gain'
     *  Math: '<S1371>/log10'
     *  Sum: '<S1371>/Sum1'
     *
     * About '<S1371>/log10':
     *  Operator: log10
     */
    rtb_Delay_og = qhmath_log10_f(rtb_Delay_og + 2.22044605E-16F) * 10.0F;

    /* MATLAB Function: '<S1368>/Detect Impulse' incorporates:
     *  Delay: '<S1368>/Delay'
     *  Sum: '<S1368>/Add1'
     */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/Reverb Extractions/Right Reverb Extraction/Compute PSD/Impulse Detector/Detect Impulse': '<S1370>:1' */
    /* '<S1370>:1:5' if isempty(counter) */
    /* '<S1370>:1:6' if isempty(state) */
    /* '<S1370>:1:8' if (EnergyDifference > DetectImpulseThreshold) */
    if (rtb_Delay_og - Model_Target_DW.Delay_DSTATE_b > 0.75F)
    {
        /* '<S1370>:1:9' isImpulsive = 1; */
        rtb_isImpulsive_g = 1;

        /* '<S1370>:1:10' counter = 0; */
        Model_Target_DW.counter = 0.0;
    }
    else if ((Model_Target_DW.counter <
              Model_Target_MaxValueOfCounterForDetectingImpulse_n) &&
             (Model_Target_DW.state == 1.0))
    {
        /* '<S1370>:1:11' elseif (counter < MaxValueOfCounterForDetectingImpulse) && (state == 1) */
        /* '<S1370>:1:12' isImpulsive = 1; */
        rtb_isImpulsive_g = 1;

        /* '<S1370>:1:13' counter = counter + 1; */
        Model_Target_DW.counter++;
    }
    else
    {
        /* '<S1370>:1:14' else */
        /* '<S1370>:1:15' isImpulsive = 0; */
        rtb_isImpulsive_g = 0;
    }

    /* '<S1370>:1:17' state = isImpulsive; */
    Model_Target_DW.state = rtb_isImpulsive_g;

    /* End of MATLAB Function: '<S1368>/Detect Impulse' */

    /* Sum: '<S1369>/Add1' incorporates:
     *  Delay: '<S1369>/Delay'
     *  Delay: '<S1369>/Delay1'
     *  Math: '<S1313>/Math Function1'
     *  Product: '<S1369>/Multiply'
     *  Product: '<S1369>/Multiply1'
     *  Sum: '<S1369>/Add'
     *
     * About '<S1313>/Math Function1':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk[i] = (Model_Target_B.instCPS[i] +
            Model_Target_DW.Delay_DSTATE_eu[i]) * minXp_tmp +
            Model_Target_DW.Delay1_DSTATE_c[i] *
            Model_Target_PreAmp0.MedusaFullRateFdpSpumSlowPsdSmoothFactor;
    }

    /* End of Sum: '<S1369>/Add1' */

    /* Delay: '<S1365>/Delay' incorporates:
     *  Sum: '<S1367>/Add1'
     */
    if (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec < 1.0F)
    {
        memcpy(&Model_Target_B.Lxks[0], &Model_Target_B.Multiply_c[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec >
                2064.0F)
        {
            delayLen = 2064;
        }
        else
        {
            delayLen = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (i = 0; i < 129; i++)
        {
            if ((uint32_T)i < (uint32_T)delayLen)
            {
                Model_Target_B.Lxks[i] = Model_Target_DW.MedusaDRspumRPxxFast[(i
                    - delayLen) + 2064];
            }
            else
            {
                Model_Target_B.Lxks[i] = Model_Target_B.Multiply_c[i - delayLen];
            }
        }
    }

    /* End of Delay: '<S1365>/Delay' */

    /* Delay: '<S1365>/Delay1' incorporates:
     *  Sum: '<S1369>/Add1'
     */
    if (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec < 1.0F)
    {
        memcpy(&rtb_Rxks[0], &Model_Target_B.Lstrk[0], 129U * sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec >
                2064.0F)
        {
            delayLen = 2064;
        }
        else
        {
            delayLen = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp0.MedusaFullRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (i = 0; i < 129; i++)
        {
            if ((uint32_T)i < (uint32_T)delayLen)
            {
                rtb_Rxks[i] = Model_Target_DW.MedusaDRspumRPxxSlow[(i - delayLen)
                    + 2064];
            }
            else
            {
                rtb_Rxks[i] = Model_Target_B.Lstrk[i - delayLen];
            }
        }
    }

    /* End of Delay: '<S1365>/Delay1' */
    for (i = 0; i < 129; i++)
    {
        /* Switch: '<S1353>/Switch' incorporates:
         *  Constant: '<S1353>/Constant'
         *  Constant: '<S1353>/Constant1'
         *  MinMax: '<S1353>/Min'
         *  Product: '<S1353>/Divide'
         *  Product: '<S1353>/Multiply'
         *  Sum: '<S1353>/Add'
         *  Switch: '<S1365>/Switch'
         *  Switch: '<S1365>/Switch1'
         */
        if (Model_Target_PreAmp0.MedusaFullRateFdpSpumOverwrite != 0.0F)
        {
            slewedStepSize = 1.0F;
        }
        else
        {
            if (rtb_isImpulsive_g > 0)
            {
                /* Switch: '<S1365>/Switch1' incorporates:
                 *  Sum: '<S1367>/Add1'
                 */
                slewedStepSize = Model_Target_B.Multiply_c[i];

                /* Switch: '<S1365>/Switch' incorporates:
                 *  Delay: '<S1365>/Delay'
                 */
                rtb_R_re = Model_Target_B.Lxks[i];
            }
            else
            {
                /* Switch: '<S1365>/Switch1' incorporates:
                 *  Sum: '<S1369>/Add1'
                 */
                slewedStepSize = Model_Target_B.Lstrk[i];

                /* Switch: '<S1365>/Switch' incorporates:
                 *  Delay: '<S1365>/Delay1'
                 */
                rtb_R_re = rtb_Rxks[i];
            }

            slewedStepSize = fminf(1.0F, qhmath_div_f(1.0F, slewedStepSize +
                                    2.22044605E-16F) * (rtb_R_re *
                                    Model_Target_B.Multiply));
        }

        /* Product: '<S1366>/Multiply' incorporates:
         *  Math: '<S1313>/Math Function1'
         *  Product: '<S1366>/Divide'
         *
         * About '<S1313>/Math Function1':
         *  Operator: magnitude^2
         */
        slewedStepSize *= Model_Target_B.instCPS[i];

        /* Switch: '<S1353>/Switch' incorporates:
         *  Product: '<S1366>/Divide'
         */
        Model_Target_B.Multiply_n[i] = slewedStepSize;

        /* Sum: '<S1374>/Add1' incorporates:
         *  Delay: '<S1374>/Delay'
         *  Delay: '<S1374>/Delay1'
         *  Product: '<S1374>/Multiply'
         *  Product: '<S1374>/Multiply1'
         *  Sum: '<S1374>/Add'
         */
        Model_Target_B.Lxks[i] = (slewedStepSize +
            Model_Target_DW.Delay_DSTATE_np[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_b[i] *
            Model_Target_PreAmp0.MedusaFullRateFdpSpumLsSmoothFactor;

        /* Sum: '<S1375>/Add1' incorporates:
         *  Delay: '<S1375>/Delay'
         *  Delay: '<S1375>/Delay1'
         *  Math: '<S1313>/Math Function1'
         *  Product: '<S1375>/Multiply'
         *  Product: '<S1375>/Multiply1'
         *  Sum: '<S1375>/Add'
         *
         * About '<S1313>/Math Function1':
         *  Operator: magnitude^2
         */
        updatedLokRokScaleFactor_tmp = (Model_Target_B.instCPS[i] +
            Model_Target_DW.Delay_DSTATE_e3[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_f[i] *
            Model_Target_PreAmp0.MedusaFullRateFdpSpumLsSmoothFactor;

        /* Product: '<S1366>/Multiply1' incorporates:
         *  Constant: '<S1366>/Constant'
         *  Product: '<S1366>/Divide'
         *  Sum: '<S1366>/Add'
         *  Sum: '<S1366>/Subtract'
         *  Sum: '<S1374>/Add1'
         */
        rtb_R_re_tmp = qhmath_div_f(Model_Target_B.Lxks[i],
            updatedLokRokScaleFactor_tmp + 2.22044605E-16F);
        slewedStepSize = Model_Target_B.Rsr[i].re;
        rtb_R_re = rtb_R_re_tmp * slewedStepSize;
        rtb_R_im_tmp = Model_Target_B.Rsr[i].im;
        rtb_R_re_tmp *= rtb_R_im_tmp;

        /* Sum: '<S1366>/Subtract' */
        Model_Target_B.MatrixConcatenate_mb[i + 516].re = slewedStepSize -
            rtb_R_re;
        Model_Target_B.MatrixConcatenate_mb[i + 516].im = rtb_R_im_tmp -
            rtb_R_re_tmp;

        /* SignalConversion generated from: '<S1308>/Matrix Concatenate' */
        Model_Target_B.MatrixConcatenate_mb[i + 645].re = rtb_R_re;
        Model_Target_B.MatrixConcatenate_mb[i + 645].im = rtb_R_re_tmp;

        /* Sum: '<S1375>/Add1' */
        rtb_Rxks[i] = updatedLokRokScaleFactor_tmp;
    }

    /* MATLAB Function: '<S1378>/MATLAB Function' incorporates:
     *  Concatenate: '<S1308>/Matrix Concatenate'
     *  Constant: '<S1309>/Constant'
     */
    /* MATLAB Function 'RifftWola/RifftWola/Hexagon/MATLAB Function': '<S1380>:1' */
    /* '<S1380>:1:7' [~, numChannels] = size(u); */
    /* '<S1380>:1:8' outputSize = fftSize - numOverlap; */
    /*  Buffer to hold overlapped samples */
    /* '<S1380>:1:12' if isempty(outputOverlap) */
    /*  Buffer for Simulation  */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S1380>:1:20' y = coder.nullcopy(single(zeros(outputSize, numChannels))); */
    /*  Simulation */
    /* '<S1380>:1:23' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1380>:1:33' else */
    /* '<S1380>:1:34' y = rifft_process(   single(complex(u)), ... */
    /* '<S1380>:1:35'                         single(Twiddle1),... */
    /* '<S1380>:1:36'                         single(Twiddle2),...  */
    /* '<S1380>:1:37'                         single(RifftOutputTmp),... */
    /* '<S1380>:1:38'                         single(win),... */
    /* '<S1380>:1:39'                         outputOverlap,... */
    /* '<S1380>:1:40'                         int32(fftSize),... */
    /* '<S1380>:1:41'                         int32(numChannels),... */
    /* '<S1380>:1:42'                         int32(numOverlap)); */
    rifft_process(&Model_Target_B.y_e[0], &Model_Target_B.MatrixConcatenate_mb[0],
                  &MedusaFdpFullRateRifftRifftBufferTwiddle1[0],
                  &MedusaFdpFullRateRifftRifftBufferTwiddle2[0],
                  &MedusaFdpFullRateRifftRifftBufferRifftOutputTmp[0],
                  &Model_Target_ConstP.pooled80[0],
                  &Model_Target_DW.outputOverlap[0], 256, 6, 128);

    /* Buffer: '<S1205>/BufferOut' */
    currentOffset = 0;
    for (row = 0; row < 6; row++)
    {
        delayLen = 128;
        rtb_isImpulsive_g = row << 8;
        memIdx = rtb_isImpulsive_g + Model_Target_DW.BufferOut_inBufPtrIdx_a;
        if (Model_Target_DW.BufferOut_inBufPtrIdx_a > 128)
        {
            for (i = 0; i < 256 - Model_Target_DW.BufferOut_inBufPtrIdx_a; i++)
            {
                Model_Target_DW.BufferOut_CircBuf_j[memIdx + i] =
                    Model_Target_B.y_e[currentOffset + i];
            }

            currentOffset = (currentOffset -
                             Model_Target_DW.BufferOut_inBufPtrIdx_a) + 256;
            memIdx = rtb_isImpulsive_g;
            delayLen = Model_Target_DW.BufferOut_inBufPtrIdx_a - 128;
        }

        for (i = 0; i < delayLen; i++)
        {
            Model_Target_DW.BufferOut_CircBuf_j[memIdx + i] =
                Model_Target_B.y_e[currentOffset + i];
        }

        currentOffset += delayLen;
    }

    Model_Target_DW.BufferOut_inBufPtrIdx_a += 128;
    if (Model_Target_DW.BufferOut_inBufPtrIdx_a >= 256)
    {
        Model_Target_DW.BufferOut_inBufPtrIdx_a -= 256;
    }

    /* End of Buffer: '<S1205>/BufferOut' */
    /* Update for Delay: '<S1357>/Delay' */
    Model_Target_DW.Delay_DSTATE_n = updatedLokRokScaleFactor;

    /* Update for Delay: '<S1356>/Delay' incorporates:
     *  Math: '<S1313>/Math Function'
     *
     * About '<S1313>/Math Function':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_i[0], &Model_Target_B.MathFunction[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S1356>/Delay1' incorporates:
     *  Sum: '<S1356>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE[0], &Model_Target_B.Lin2[0], 129U *
           sizeof(real32_T));

    /* Update for Delay: '<S1358>/Delay' incorporates:
     *  Math: '<S1313>/Math Function'
     *
     * About '<S1313>/Math Function':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_l[0], &Model_Target_B.MathFunction[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S1358>/Delay1' incorporates:
     *  Sum: '<S1358>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_a[0], &rtb_Add1_lk[0], 129U * sizeof
           (real32_T));

    /* Update for Delay: '<S1354>/Delay' incorporates:
     *  Sum: '<S1356>/Add1'
     */
    for (i = 0; i < 1935; i++)
    {
        Model_Target_DW.MedusaDRspumLPxxFast[i] =
            Model_Target_DW.MedusaDRspumLPxxFast[i + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumLPxxFast[1935], &Model_Target_B.Lin2[0],
           129U * sizeof(real32_T));

    /* End of Update for Delay: '<S1354>/Delay' */

    /* Update for Delay: '<S1354>/Delay1' */
    for (i = 0; i < 1935; i++)
    {
        Model_Target_DW.MedusaDRspumLPxxSlow[i] =
            Model_Target_DW.MedusaDRspumLPxxSlow[i + 129];
    }

    /* Update for Delay: '<S1412>/Delay' */
    Model_Target_DW.Delay_DSTATE_i3 = rtb_Sumhighfrequencyenergy;

    /* Update for Delay: '<S1412>/Delay1' */
    Model_Target_DW.Delay1_DSTATE_p = minXp;

    /* Update for Delay: '<S1368>/Delay' */
    Model_Target_DW.Delay_DSTATE_b = rtb_Delay_og;
    for (i = 0; i < 129; i++)
    {
        /* Update for Delay: '<S1367>/Delay' incorporates:
         *  Math: '<S1313>/Math Function1'
         *
         * About '<S1313>/Math Function1':
         *  Operator: magnitude^2
         */
        slewedStepSize = Model_Target_B.instCPS[i];

        /* Update for Delay: '<S1354>/Delay1' incorporates:
         *  Sum: '<S1358>/Add1'
         */
        Model_Target_DW.MedusaDRspumLPxxSlow[i + 1935] = rtb_Add1_lk[i];

        /* Update for Delay: '<S1363>/Delay' incorporates:
         *  Product: '<S1355>/Multiply'
         */
        Model_Target_DW.Delay_DSTATE_m[i] = Model_Target_B.Multiply1_e[i];

        /* Update for Delay: '<S1363>/Delay1' incorporates:
         *  Sum: '<S1363>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_o[i] = Model_Target_B.Multiply1_m[i];

        /* Update for Delay: '<S1364>/Delay' incorporates:
         *  Math: '<S1313>/Math Function'
         *
         * About '<S1313>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_DW.Delay_DSTATE_k[i] = Model_Target_B.MathFunction[i];

        /* Update for Delay: '<S1364>/Delay1' incorporates:
         *  Sum: '<S1364>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_l[i] = rtb_Add1_mry[i];

        /* Update for Delay: '<S1367>/Delay' */
        Model_Target_DW.Delay_DSTATE_e[i] = slewedStepSize;

        /* Update for Delay: '<S1367>/Delay1' incorporates:
         *  Sum: '<S1367>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_e[i] = Model_Target_B.Multiply_c[i];

        /* Update for Delay: '<S1369>/Delay' */
        Model_Target_DW.Delay_DSTATE_eu[i] = slewedStepSize;

        /* Update for Delay: '<S1369>/Delay1' incorporates:
         *  Sum: '<S1369>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_c[i] = Model_Target_B.Lstrk[i];
    }

    /* Update for Delay: '<S1365>/Delay' incorporates:
     *  Sum: '<S1367>/Add1'
     */
    for (i = 0; i < 1935; i++)
    {
        Model_Target_DW.MedusaDRspumRPxxFast[i] =
            Model_Target_DW.MedusaDRspumRPxxFast[i + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumRPxxFast[1935],
           &Model_Target_B.Multiply_c[0], 129U * sizeof(real32_T));

    /* End of Update for Delay: '<S1365>/Delay' */

    /* Update for Delay: '<S1365>/Delay1' incorporates:
     *  Sum: '<S1369>/Add1'
     */
    for (i = 0; i < 1935; i++)
    {
        Model_Target_DW.MedusaDRspumRPxxSlow[i] =
            Model_Target_DW.MedusaDRspumRPxxSlow[i + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumRPxxSlow[1935], &Model_Target_B.Lstrk[0],
           129U * sizeof(real32_T));

    /* End of Update for Delay: '<S1365>/Delay1' */

    /* Update for Delay: '<S1374>/Delay' incorporates:
     *  Product: '<S1366>/Multiply'
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_np[0], &Model_Target_B.Multiply_n[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S1374>/Delay1' incorporates:
     *  Sum: '<S1374>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_b[0], &Model_Target_B.Lxks[0], 129U *
           sizeof(real32_T));

    /* Update for Delay: '<S1375>/Delay' incorporates:
     *  Math: '<S1313>/Math Function1'
     *
     * About '<S1313>/Math Function1':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_e3[0], &Model_Target_B.instCPS[0], 129U
           * sizeof(real32_T));

    /* Update for Delay: '<S1375>/Delay1' incorporates:
     *  Sum: '<S1375>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_f[0], &rtb_Rxks[0], 129U * sizeof
           (real32_T));
}

/* Output and update for atomic system: '<S1137>/Medusa5H1 Part 2' */
void Model_Target_Medusa5H1Part2TID5(void)
{
    int32_T MedusaFdpDeciRateRfftRfftInput_tmp;
    int32_T i;
    int32_T memIdx;
    int32_T rtb_isImpulsive_c;
    real32_T rtb_Add1_a[129];
    real32_T rtb_MathFunction1_e[129];
    real32_T rtb_Rxks[129];
    real32_T Lx_im;
    real32_T maxXp;
    real32_T minXp;
    real32_T minXp_tmp;
    real32_T rtb_Add1_b;
    real32_T rtb_R_f_im_tmp;
    real32_T rtb_R_f_re_tmp;
    real32_T rtb_R_f_re_tmp_0;
    real32_T rtb_R_re;
    real32_T updatedLokRokScaleFactor;
    static const real32_T b[128] =
    {
        0.0F, 0.0122715384F, 0.024541229F, 0.0368072242F, 0.0490676761F,
        0.061320737F, 0.0735645667F, 0.0857973099F, 0.0980171412F, 0.110222206F,
        0.122410677F, 0.134580702F, 0.146730468F, 0.15885815F, 0.170961887F,
        0.183039889F, 0.195090324F, 0.207111374F, 0.219101235F, 0.231058106F,
        0.242980182F, 0.254865646F, 0.266712755F, 0.27851969F, 0.290284663F,
        0.302005947F, 0.313681751F, 0.32531029F, 0.336889863F, 0.348418683F,
        0.359895051F, 0.371317208F, 0.382683426F, 0.393992037F, 0.405241311F,
        0.416429549F, 0.427555084F, 0.438616246F, 0.449611336F, 0.460538715F,
        0.471396744F, 0.482183784F, 0.492898196F, 0.50353837F, 0.514102757F,
        0.524589658F, 0.534997642F, 0.545325F, 0.555570245F, 0.565731823F,
        0.575808167F, 0.585797846F, 0.59569931F, 0.605511069F, 0.615231574F,
        0.624859512F, 0.634393275F, 0.643831551F, 0.653172851F, 0.662415802F,
        0.671559F, 0.680601F, 0.689540565F, 0.698376238F, 0.707106769F,
        0.715730846F, 0.724247098F, 0.732654274F, 0.740951121F, 0.749136388F,
        0.757208824F, 0.765167236F, 0.773010433F, 0.780737221F, 0.78834641F,
        0.795836926F, 0.803207517F, 0.81045717F, 0.817584813F, 0.824589312F,
        0.831469595F, 0.838224709F, 0.84485358F, 0.851355195F, 0.857728601F,
        0.863972843F, 0.870086968F, 0.876070082F, 0.881921291F, 0.887639642F,
        0.893224299F, 0.898674488F, 0.903989315F, 0.909168F, 0.914209783F,
        0.919113874F, 0.923879504F, 0.928506076F, 0.932992816F, 0.937339F,
        0.941544056F, 0.945607305F, 0.949528158F, 0.953306F, 0.956940353F,
        0.960430503F, 0.963776052F, 0.966976464F, 0.970031261F, 0.972939968F,
        0.975702107F, 0.97831738F, 0.980785251F, 0.983105481F, 0.985277653F,
        0.987301409F, 0.989176512F, 0.990902662F, 0.992479563F, 0.993907F,
        0.99518472F, 0.996312618F, 0.997290432F, 0.998118103F, 0.99879545F,
        0.999322355F, 0.999698818F, 0.999924719F
    };

    static const real32_T c[128] =
    {
        1.0F, 0.999924719F, 0.999698818F, 0.999322355F, 0.99879545F,
        0.998118103F, 0.997290432F, 0.996312618F, 0.99518472F, 0.993907F,
        0.992479563F, 0.990902662F, 0.989176512F, 0.987301409F, 0.985277653F,
        0.983105481F, 0.980785251F, 0.97831738F, 0.975702107F, 0.972939968F,
        0.970031261F, 0.966976464F, 0.963776052F, 0.960430503F, 0.956940353F,
        0.953306F, 0.949528158F, 0.945607305F, 0.941544056F, 0.937339F,
        0.932992816F, 0.928506076F, 0.923879504F, 0.919113874F, 0.914209783F,
        0.909168F, 0.903989315F, 0.898674488F, 0.893224299F, 0.887639642F,
        0.881921291F, 0.876070082F, 0.870086968F, 0.863972843F, 0.857728601F,
        0.851355195F, 0.84485358F, 0.838224709F, 0.831469595F, 0.824589312F,
        0.817584813F, 0.81045717F, 0.803207517F, 0.795836926F, 0.78834641F,
        0.780737221F, 0.773010433F, 0.765167236F, 0.757208824F, 0.749136388F,
        0.740951121F, 0.732654274F, 0.724247098F, 0.715730846F, 0.707106769F,
        0.698376238F, 0.689540565F, 0.680601F, 0.671559F, 0.662415802F,
        0.653172851F, 0.643831551F, 0.634393275F, 0.624859512F, 0.615231574F,
        0.605511069F, 0.59569931F, 0.585797846F, 0.575808167F, 0.565731823F,
        0.555570245F, 0.545325F, 0.534997642F, 0.524589658F, 0.514102757F,
        0.50353837F, 0.492898196F, 0.482183784F, 0.471396744F, 0.460538715F,
        0.449611336F, 0.438616246F, 0.427555084F, 0.416429549F, 0.405241311F,
        0.393992037F, 0.382683426F, 0.371317208F, 0.359895051F, 0.348418683F,
        0.336889863F, 0.32531029F, 0.313681751F, 0.302005947F, 0.290284663F,
        0.27851969F, 0.266712755F, 0.254865646F, 0.242980182F, 0.231058106F,
        0.219101235F, 0.207111374F, 0.195090324F, 0.183039889F, 0.170961887F,
        0.15885815F, 0.146730468F, 0.134580702F, 0.122410677F, 0.110222206F,
        0.0980171412F, 0.0857973099F, 0.0735645667F, 0.061320737F, 0.0490676761F,
        0.0368072242F, 0.024541229F, 0.0122715384F
    };

    creal32_T *rtb_y_o_0;

    /* Buffer: '<S1204>/BufferIn' */
    rtb_isImpulsive_c = 0;
    for (i = 0; i < 2; i++)
    {
        memIdx = (i << 8) + Model_Target_DW.BufferIn_outBufPtrIdx;
        memcpy(&Model_Target_B.BufferIn_f[rtb_isImpulsive_c],
               &Model_Target_DW.BufferIn_CircBuf[memIdx], sizeof(real32_T) << 7U);
        rtb_isImpulsive_c += 128;
        MedusaFdpDeciRateRfftRfftInput_tmp =
            Model_Target_DW.BufferIn_outBufPtrIdx + 128;
    }

    if (MedusaFdpDeciRateRfftRfftInput_tmp == 256)
    {
        MedusaFdpDeciRateRfftRfftInput_tmp = 0;
    }

    Model_Target_DW.BufferIn_outBufPtrIdx = MedusaFdpDeciRateRfftRfftInput_tmp;

    /* End of Buffer: '<S1204>/BufferIn' */

    /* MATLAB Function: '<S1214>/Windowing' incorporates:
     *  Buffer: '<S1204>/BufferIn'
     */
    /*  Get sizes */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/ShortTimeFourierTransform/Windowing': '<S1300>:1' */
    /* '<S1300>:1:4' [~, NumChannels] = size(AudioIn); */
    /* '<S1300>:1:5' HopSize = FftSize - Overlap; */
    /* '<S1300>:1:8' if isempty(InputOverlap) */
    /* '<S1300>:1:12' AudioOut = [InputOverlap.*Window(1:Overlap); AudioIn.*Window((HopSize + 1):end)]; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 2; rtb_isImpulsive_c++)
    {
        for (i = 0; i < 128; i++)
        {
            MedusaFdpDeciRateRfftRfftInput_tmp = (rtb_isImpulsive_c << 7) + i;
            memIdx = (rtb_isImpulsive_c << 8) + i;
            MedusaFdpDeciRateRfftRfftInput[memIdx] =
                Model_Target_DW.InputOverlap_d[MedusaFdpDeciRateRfftRfftInput_tmp]
                * b[i];
            MedusaFdpDeciRateRfftRfftInput[memIdx + 128] =
                Model_Target_B.BufferIn_f[MedusaFdpDeciRateRfftRfftInput_tmp] *
                c[i];
        }
    }

    /*  Update overlapping samples */
    /* '<S1300>:1:15' InputOverlap = AudioIn; */
    memcpy(&Model_Target_DW.InputOverlap_d[0], &Model_Target_B.BufferIn_f[0],
           sizeof(real32_T) << 8U);

    /* End of MATLAB Function: '<S1214>/Windowing' */

    /* MATLAB Function: '<S1302>/MATLAB Function1' */
    /*  Computes the Real FFT of a Multi-Channel Signal.  */
    /*  During Code Generation, hexagon rfft crl function is used. */
    /*  Inputs: */
    /*      u - purely real signal.  */
    /*          size = [fftSize, numChannels] */
    /*      fftSize - size of each input channel. Also the size of FFT */
    /*  Outputs: */
    /*      y - fftSize/2 + 1 unique FFT coefficients of each channel of u. */
    /*          size = [fftSize/2 + 1, numChannels] */
    /*  ------------------------------------------------------------------------- */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function1': '<S1305>:1' */
    /* '<S1305>:1:17' numChannels = size(u, 2); */
    /* '<S1305>:1:18' spectrumSize = (fftSize/2) + 1; */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S1305>:1:21' y = coder.nullcopy(complex(single(zeros(spectrumSize, numChannels)))); */
    /*  Simulation */
    /* '<S1305>:1:24' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1305>:1:27' else */
    /* '<S1305>:1:28' y = rfft_process(single(u), Twiddle1, Twiddle2, RfftOutputTmp, int32(fftSize), int32(numChannels)); */
    rfft_process(&Model_Target_B.y_o_c[0], &MedusaFdpDeciRateRfftRfftInput[0],
                 &MedusaFdpDeciRateRfftRfftBufferTwiddle1[0],
                 &MedusaFdpDeciRateRfftRfftBufferTwiddle2[0],
                 &MedusaFdpDeciRateRfftRfftBufferRfftOutputTmp[0], 256, 2);

    /* Math: '<S1247>/Math Function'
     *
     * About '<S1247>/Math Function':
     *  Operator: magnitude^2
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        /* Selector: '<S1214>/Selector' incorporates:
         *  Math: '<S1217>/Math Function'
         *  Math: '<S1217>/Math Function1'
         *  Math: '<S1247>/Math Function1'
         *  Selector: '<S1214>/Selector1'
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1217>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1247>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_o_0 = &Model_Target_B.y_o_c[rtb_isImpulsive_c];
        Model_Target_B.Lin2_a[rtb_isImpulsive_c] = rtb_y_o_0->re * rtb_y_o_0->re
            + rtb_y_o_0->im * rtb_y_o_0->im;
    }

    /* MATLAB Function: '<S1220>/Coeffs 1st Stage' incorporates:
     *  Selector: '<S1214>/Selector'
     *  Selector: '<S1214>/Selector1'
     */
    Model_Target_Coeffs1stStage(&Model_Target_B.y_o_c[0], &Model_Target_B.y_o_c
        [129], &Model_Target_B.sf_Coeffs1stStage);

    /* MATLAB Function: '<S1223>/MATLAB Function' incorporates:
     *  Math: '<S1247>/Math Function'
     *  Product: '<S1262>/Multiply'
     *
     * About '<S1247>/Math Function':
     *  Operator: magnitude^2
     */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Instantaneous Stretch Coeffs /MATLAB Function': '<S1229>:1' */
    /* '<S1229>:1:6' coder.inline('always'); */
    /* '<S1229>:1:7' epsf = single(eps); */
    /*  Step 1: Compute the estimated stretch coefficients or worst-case estimate */
    /*  based on maximum allowable stretching Xpmax */
    /* '<S1229>:1:11' Lstrk = min(Lxk, LokRokMaxScaleFactor * Lok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] =
            Model_Target_PreAmp0.MedusaDeciRateFdpCoeffsLokRokMaxScaleFactor *
            Model_Target_B.sf_Coeffs1stStage.Lok[i];
    }

    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = fminf
            (Model_Target_B.sf_Coeffs1stStage.Lxk[i],
             Model_Target_B.Multiply_a[i]);
    }

    /* '<S1229>:1:12' Rstrk = min(Rxk, LokRokMaxScaleFactor * Rok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] =
            Model_Target_PreAmp0.MedusaDeciRateFdpCoeffsLokRokMaxScaleFactor *
            Model_Target_B.sf_Coeffs1stStage.Rok[i];
    }

    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk_k[i] = fminf(Model_Target_B.sf_Coeffs1stStage.Rxk[i],
            Model_Target_B.Multiply_a[i]);
    }

    /*  Step 2: Compute Excessive Stretch Detector (ESD) - used to update Xp */
    /*  */
    /*                    sum_over_FFT_bins( Lstrki * |Lin|) + sum_over_FFT_bins( Rstrki * |Rin|)   */
    /*  ESD = abs( db20 ( ----------------------------------------------------------------------- ) ) */
    /*                                      sum_over_FFT_bins( Lxki * |Lin| ) */
    /*  */
    /*  since Lxki * |Lin| = min (|Lin|,|Rin|) (per bin), we store the minima  */
    /*  beforehand and use it here */
    /*  Note the matrix shorthand for sum_over_FFT_bins(Lstrki * Lin) is Lstrk' * p.absLi */
    /*  A small positive value is added to the numerator, to avoid db20(0) */
    /* '<S1229>:1:25' ESDdB = db20( (epsf + Lstrk(:)' * absLi(:) + Rstrk(:)' * absRi(:)) ... */
    /* '<S1229>:1:26'             / (epsf + sum(minAbsLiRi)) ); */
    updatedLokRokScaleFactor = Model_Target_B.sf_Coeffs1stStage.minAbsLiRi[0];
    for (i = 0; i < 128; i++)
    {
        updatedLokRokScaleFactor +=
            Model_Target_B.sf_Coeffs1stStage.minAbsLiRi[i + 1];
    }

    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    minXp = 0.0F;
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        minXp += Model_Target_B.Multiply_bg[rtb_isImpulsive_c] *
            Model_Target_B.sf_Coeffs1stStage.absLi[rtb_isImpulsive_c];
    }

    maxXp = 0.0F;
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        maxXp += Model_Target_B.Lstrk_k[rtb_isImpulsive_c] *
            Model_Target_B.sf_Coeffs1stStage.absRi[rtb_isImpulsive_c];
    }

    updatedLokRokScaleFactor = qhmath_log_f(qhmath_abs_f(qhmath_div_f((minXp +
        2.22044605E-16F) + maxXp, updatedLokRokScaleFactor + 2.22044605E-16F))) *
        8.68588924F;

    /*  "Turn off" stretching by setting minXp and maxXp to zero,  */
    /*  if CAE_enable is zero. */
    /* '<S1229>:1:30' if (CAE_enable == 0) */
    if (Model_Target_B.Constant3 == 0)
    {
        /* '<S1229>:1:31' minXp = single(0.0); */
        minXp = 0.0F;

        /* '<S1229>:1:32' maxXp = single(0.0); */
        maxXp = 0.0F;
    }
    else
    {
        /* '<S1229>:1:33' else */
        /* '<S1229>:1:34' minXp = Xpmin; */
        minXp = Model_Target_PreAmp0.MedusaDeciRateFdpCoeffsXpMin;

        /* '<S1229>:1:35' maxXp = Xpmax; */
        maxXp = Model_Target_PreAmp0.MedusaDeciRateFdpCoeffsXpMax;
    }

    /*  Calculate new stretch factor, Xp, based on ESD value. */
    /*  The following curve is applied: */
    /*         Xp */
    /*         ^ */
    /*         | */
    /*   maxXp +----------. */
    /*         |          .\ */
    /*         |          . \ */
    /*         |          .  \ */
    /*         |          .   \ */
    /*         |          .    \ */
    /*         |          .     \ */
    /*   minXp +          .      --------------- minXp */
    /*         |          .      . */
    /*         +----------+------+-------------> ESD (dB) */
    /*        0           |      | */
    /*                    |     ESD_upper_bound_in_dB - thresh2 */
    /*                    | */
    /*                   ESD_lower_bound_in_dB - thresh1 */
    /* '<S1229>:1:58' if (ESDdB < ESDLowerBound) */
    if (updatedLokRokScaleFactor <
            Model_Target_PreAmp0.MedusaDeciRateFdpCoeffsESDLowerbounddB)
    {
        /*  Stretching is lower than the lower threshold, use largest allowable Xp. */
        /* '<S1229>:1:60' Xp = maxXp; */
        minXp = maxXp;
    }
    else if (updatedLokRokScaleFactor <=
             Model_Target_PreAmp0.MedusaDeciRateFdpCoeffsESDUpperbounddB)
    {
        /* '<S1229>:1:64' else */
        /*  Stretching in between, compute Xp as a linear interpolation between  */
        /*  max and min based on the two thresholds */
        /* '<S1229>:1:67' Xp = minXp + (maxXp - minXp) * ESDStepSize * (ESDUpperBound - ESDdB); */
        minXp += (maxXp - minXp) *
            Model_Target_PreAmp0.MedusaDeciRateFdpCoeffsESDStepSize *
            (Model_Target_PreAmp0.MedusaDeciRateFdpCoeffsESDUpperbounddB -
             updatedLokRokScaleFactor);
    }
    else
    {
        /* '<S1229>:1:61' elseif (ESDdB > ESDUpperBound) */
        /*  Stretching is higher than the upper threshold, use smallest allowable Xp. */
        /* '<S1229>:1:63' Xp = minXp; */
    }

    /*  Step 3: Compute updated instantaneous stretch coefficients */
    /* '<S1229>:1:71' updatedLokRokScaleFactor = 0.5 * (Xp/(1-Xp+epsf)); */
    updatedLokRokScaleFactor = qhmath_div_f(minXp, (1.0F - minXp) +
        2.22044605E-16F) * 0.5F;

    /*  Calculate instanstaneous Center Selectivity coefficients based on SPS */
    /* '<S1229>:1:74' instCPS = 1 - SPS; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS_k[i] = 1.0F -
            Model_Target_B.sf_Coeffs1stStage.SPS[i];
    }

    /* '<S1229>:1:75' Lck = instCPS .* Lxk; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk_k[i] = Model_Target_B.instCPS_k[i] *
            Model_Target_B.sf_Coeffs1stStage.Lxk[i];
    }

    /* '<S1229>:1:76' Rck = instCPS .* Rxk; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.instCPS_k[rtb_isImpulsive_c] *=
            Model_Target_B.sf_Coeffs1stStage.Rxk[rtb_isImpulsive_c];
    }

    /*  Use the updated value of Xp to calculate stretch coefficients */
    /* '<S1229>:1:79' Lstrk = min(Lck, updatedLokRokScaleFactor * Lok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] = updatedLokRokScaleFactor *
            Model_Target_B.sf_Coeffs1stStage.Lok[i];
    }

    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk_k[i] = fminf(Model_Target_B.Lstrk_k[i],
            Model_Target_B.Multiply_a[i]);
    }

    /* '<S1229>:1:80' Rstrk = min(Rck, updatedLokRokScaleFactor * Rok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] = updatedLokRokScaleFactor *
            Model_Target_B.sf_Coeffs1stStage.Rok[i];
    }

    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = fminf(Model_Target_B.instCPS_k[i],
            Model_Target_B.Multiply_a[i]);
        Model_Target_B.Lstrk_k[i] *= Model_Target_B.Lin2_a[i];
    }

    /* MATLAB Function: '<S1264>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain1'
     *  Constant: '<S1226>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lstrk_k, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_kd,
        &Model_Target_DW.sf_MATLABFunction_kd);

    /* MATLAB Function: '<S1248>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain1'
     *  Constant: '<S1226>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lin2_a, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_jh,
        &Model_Target_DW.sf_MATLABFunction_jh);

    /* Math: '<S1247>/Math Function2' incorporates:
     *  Constant: '<S1247>/Constant1'
     *  Sum: '<S1247>/Add'
     *
     * About '<S1247>/Math Function2':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS_k[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_jh.y[i] + 2.22044605E-16F);
    }

    /* End of Math: '<S1247>/Math Function2' */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        /* Math: '<S1247>/Math Function1' incorporates:
         *  Math: '<S1217>/Math Function'
         *  Math: '<S1217>/Math Function1'
         *  Math: '<S1247>/Math Function'
         *  Selector: '<S1214>/Selector'
         *  Selector: '<S1214>/Selector1'
         *
         * About '<S1247>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1217>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1247>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_y_o_0 = &Model_Target_B.y_o_c[rtb_isImpulsive_c + 129];
        maxXp = rtb_y_o_0->re * rtb_y_o_0->re + rtb_y_o_0->im * rtb_y_o_0->im;

        /* Product: '<S1263>/Multiply' incorporates:
         *  MATLAB Function: '<S1223>/MATLAB Function'
         *  Math: '<S1247>/Math Function1'
         *
         * About '<S1247>/Math Function1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Multiply_a[rtb_isImpulsive_c] = maxXp *
            Model_Target_B.Multiply_bg[rtb_isImpulsive_c];

        /* Math: '<S1247>/Math Function1'
         *
         * About '<S1247>/Math Function1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Lstrk_k[rtb_isImpulsive_c] = maxXp;
    }

    /* MATLAB Function: '<S1266>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain1'
     *  Constant: '<S1226>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Multiply_a, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_gm,
        &Model_Target_DW.sf_MATLABFunction_gm);

    /* MATLAB Function: '<S1249>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain1'
     *  Constant: '<S1226>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lstrk_k, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_a,
        &Model_Target_DW.sf_MATLABFunction_a);

    /* Math: '<S1247>/Math Function3' incorporates:
     *  Constant: '<S1247>/Constant2'
     *  Product: '<S1282>/Divide'
     *  Sum: '<S1247>/Add1'
     *
     * About '<S1247>/Math Function3':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_a.y[i] + 2.22044605E-16F);
    }

    /* End of Math: '<S1247>/Math Function3' */

    /* Product: '<S1230>/Multiply' incorporates:
     *  Math: '<S1247>/Math Function'
     *
     * About '<S1247>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = Model_Target_B.Lin2_a[i] *
            Model_Target_B.sf_Coeffs1stStage.Lok[i];
    }

    /* End of Product: '<S1230>/Multiply' */

    /* MATLAB Function: '<S1232>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain1'
     *  Constant: '<S1226>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Multiply_bg, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_nq,
        &Model_Target_DW.sf_MATLABFunction_nq);

    /* Product: '<S1230>/Multiply1' incorporates:
     *  Math: '<S1247>/Math Function2'
     *
     * About '<S1247>/Math Function2':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply1_o[i] = Model_Target_B.sf_MATLABFunction_nq.y[i]
            * Model_Target_B.instCPS_k[i];
    }

    /* End of Product: '<S1230>/Multiply1' */

    /* Product: '<S1231>/Multiply' incorporates:
     *  Math: '<S1247>/Math Function1'
     *
     * About '<S1247>/Math Function1':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = Model_Target_B.Lstrk_k[i] *
            Model_Target_B.sf_Coeffs1stStage.Rok[i];
    }

    /* End of Product: '<S1231>/Multiply' */

    /* MATLAB Function: '<S1234>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain1'
     *  Constant: '<S1226>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Multiply_bg, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_ek,
        &Model_Target_DW.sf_MATLABFunction_ek);

    /* Product: '<S1231>/Multiply1' incorporates:
     *  Product: '<S1282>/Divide'
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply1_a[i] = Model_Target_B.sf_MATLABFunction_ek.y[i]
            * Model_Target_B.Multiply_a[i];
    }

    /* End of Product: '<S1231>/Multiply1' */

    /* MATLAB Function: '<S1220>/Coeffs 2nd Stage' incorporates:
     *  Product: '<S1230>/Multiply1'
     *  Product: '<S1231>/Multiply1'
     */
    /*  Update mono coeffs after smoothing far left/right coeffs */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Coeffs 2nd Stage': '<S1222>:1' */
    /*  Left only/right only coefficients */
    /* '<S1222>:1:5' Lxks = 1 - Loks; */
    /* '<S1222>:1:6' Rxks = 1 - Roks; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lxks_j[i] = 1.0F - Model_Target_B.Multiply1_o[i];
        rtb_Rxks[i] = 1.0F - Model_Target_B.Multiply1_a[i];
    }

    /* End of MATLAB Function: '<S1220>/Coeffs 2nd Stage' */

    /* MATLAB Function: '<S1228>/Normalize Stretch Coeffs' incorporates:
     *  Math: '<S1247>/Math Function'
     *  Math: '<S1247>/Math Function2'
     *  Product: '<S1256>/Multiply'
     *  Product: '<S1262>/Multiply1'
     *  Product: '<S1263>/Multiply1'
     *  Product: '<S1282>/Divide'
     *
     * About '<S1247>/Math Function':
     *  Operator: magnitude^2
     *
     * About '<S1247>/Math Function2':
     *  Operator: reciprocal
     */
    /*  Normalize stretch coefficients against mono portion  */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Updated Stretch Coeffs and Steering Coeffs/Normalize Stretch Coeffs': '<S1252>:1' */
    /*  Take only difference of L&R strecth coeffs as the total stretch  */
    /* '<S1252>:1:6' netStretch = (Lstrks .* absLi) - (Rstrks.* absRi); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = Model_Target_B.sf_MATLABFunction_kd.y[i]
            * Model_Target_B.instCPS_k[i] *
            Model_Target_B.sf_Coeffs1stStage.absLi[i] -
            Model_Target_B.sf_MATLABFunction_gm.y[i] *
            Model_Target_B.Multiply_a[i] *
            Model_Target_B.sf_Coeffs1stStage.absRi[i];
    }

    /*  Normalize by the smoothed total shared level  */
    /* '<S1252>:1:9' epsf = single(eps); */
    /* '<S1252>:1:10' LxSmth = (Lxks .* absLi) + epsf; */
    /* '<S1252>:1:11' RxSmth = (Rxks .* absRi) + epsf; */
    /* '<S1252>:1:13' Lstrki = max(0.0, netStretch) ./ LxSmth; */
    for (i = 0; i < 129; i++)
    {
        rtb_Add1_a[i] = fmaxf(0.0F, Model_Target_B.Multiply_bg[i]);
    }

    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        rtb_Add1_a[rtb_isImpulsive_c] = qhmath_div_f
            (rtb_Add1_a[rtb_isImpulsive_c],
             Model_Target_B.Lxks_j[rtb_isImpulsive_c] *
             Model_Target_B.sf_Coeffs1stStage.absLi[rtb_isImpulsive_c] +
             2.22044605E-16F);
    }

    /* '<S1252>:1:14' Rstrki = max(0.0, (-netStretch)) ./ RxSmth; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        updatedLokRokScaleFactor = Model_Target_B.Multiply_bg[rtb_isImpulsive_c];
        rtb_MathFunction1_e[rtb_isImpulsive_c] = fmaxf(0.0F,
            -updatedLokRokScaleFactor);
        Model_Target_B.Multiply_bg[rtb_isImpulsive_c] =
            -updatedLokRokScaleFactor;
    }

    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        rtb_MathFunction1_e[rtb_isImpulsive_c] = qhmath_div_f
            (rtb_MathFunction1_e[rtb_isImpulsive_c], rtb_Rxks[rtb_isImpulsive_c]
             * Model_Target_B.sf_Coeffs1stStage.absRi[rtb_isImpulsive_c] +
             2.22044605E-16F);
    }

    /*  Bound the stretch coefficients within [0,1] */
    /* '<S1252>:1:17' Lstrki = min(1.0, max(0.0, Lstrki)); */
    /* '<S1252>:1:18' Rstrki = min(1.0, max(0.0, Rstrki)); */
    for (i = 0; i < 129; i++)
    {
        updatedLokRokScaleFactor = fminf(1.0F, fmaxf(0.0F, rtb_Add1_a[i]));
        rtb_Add1_b = fmaxf(0.0F, rtb_MathFunction1_e[i]);
        Model_Target_B.Multiply_bg[i] = fminf(1.0F, rtb_Add1_b);
        rtb_Add1_a[i] = rtb_Add1_b;
        Model_Target_B.Lin2_a[i] *= updatedLokRokScaleFactor;
    }

    /* MATLAB Function: '<S1258>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain1'
     *  Constant: '<S1226>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lin2_a, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_k,
        &Model_Target_DW.sf_MATLABFunction_k);

    /* Product: '<S1256>/Multiply1' incorporates:
     *  Math: '<S1247>/Math Function2'
     *
     * About '<S1247>/Math Function2':
     *  Operator: reciprocal
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.instCPS_k[rtb_isImpulsive_c] *=
            Model_Target_B.sf_MATLABFunction_k.y[rtb_isImpulsive_c];
    }

    /* End of Product: '<S1256>/Multiply1' */

    /* Product: '<S1257>/Multiply' incorporates:
     *  MATLAB Function: '<S1228>/Normalize Stretch Coeffs'
     *  Math: '<S1247>/Math Function1'
     *
     * About '<S1247>/Math Function1':
     *  Operator: magnitude^2
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Lstrk_k[rtb_isImpulsive_c] *=
            Model_Target_B.Multiply_bg[rtb_isImpulsive_c];
    }

    /* End of Product: '<S1257>/Multiply' */

    /* MATLAB Function: '<S1260>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain1'
     *  Constant: '<S1226>/lsPole1'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lstrk_k, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_bt,
        &Model_Target_DW.sf_MATLABFunction_bt);

    /* Product: '<S1257>/Multiply1' incorporates:
     *  Product: '<S1282>/Divide'
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Multiply_a[rtb_isImpulsive_c] *=
            Model_Target_B.sf_MATLABFunction_bt.y[rtb_isImpulsive_c];
    }

    /* End of Product: '<S1257>/Multiply1' */

    /* MATLAB Function: '<S1228>/Update Steering Coeffs' */
    Model_Target_UpdateSteeringCoeffs(Model_Target_B.instCPS_k,
        Model_Target_B.Multiply_a, Model_Target_B.Multiply1_o,
        Model_Target_B.Multiply1_a, Model_Target_B.Lxks_j, rtb_Rxks,
        &Model_Target_B.sf_UpdateSteeringCoeffs);

    /* Product: '<S1236>/|Lx|^2' incorporates:
     *  Math: '<S1225>/Math Function'
     *  Math: '<S1236>/Math Function'
     *
     * About '<S1225>/Math Function':
     *  Operator: magnitude^2
     *
     * About '<S1236>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        /* Math: '<S1236>/Math Function'
         *
         * About '<S1236>/Math Function':
         *  Operator: magnitude^2
         */
        updatedLokRokScaleFactor = Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[i];

        /* Math: '<S1225>/Math Function'
         *
         * About '<S1225>/Math Function':
         *  Operator: magnitude^2
         */
        minXp = Model_Target_B.sf_Coeffs1stStage.absLi[i];
        Model_Target_B.Lin2_a[i] = updatedLokRokScaleFactor *
            updatedLokRokScaleFactor * (minXp * minXp);
    }

    /* End of Product: '<S1236>/|Lx|^2' */

    /* MATLAB Function: '<S1239>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain2'
     *  Constant: '<S1226>/lsPole2'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lin2_a, 0.324919701F,
        0.33754015F, &Model_Target_B.sf_MATLABFunction_eo,
        &Model_Target_DW.sf_MATLABFunction_eo);

    /* MATLAB Function: '<S1225>/MATLAB Function' incorporates:
     *  Product: '<S1236>/SPS*|Lx|^2'
     *  Product: '<S1236>/|Lx|^2'
     *  Selector: '<S1214>/Selector'
     *  Selector: '<S1214>/Selector1'
     */
    /*  New SPS is calculated and smoothed using Lx/Rx. This change ensures no */
    /*  surround content generated when there is no phase difference between L/R */
    /*  regardless of the magnitude difference. */
    /*  The old SPS was calculated using Lin/Rin, and smoothed using Lx/Rx. */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Smooth 2nd Stage/MATLAB Function': '<S1237>:1' */
    /* '<S1237>:1:7' Lx = Lxks .* Lin; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Lx[rtb_isImpulsive_c].re =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[rtb_isImpulsive_c] *
            Model_Target_B.y_o_c[rtb_isImpulsive_c].re;
        Model_Target_B.Lx[rtb_isImpulsive_c].im =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[rtb_isImpulsive_c] *
            Model_Target_B.y_o_c[rtb_isImpulsive_c].im;
    }

    /* '<S1237>:1:8' Rx = Rxks .* Rin; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Rx[rtb_isImpulsive_c].re =
            Model_Target_B.y_o_c[rtb_isImpulsive_c + 129].re *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[rtb_isImpulsive_c];
        Model_Target_B.Rx[rtb_isImpulsive_c].im =
            Model_Target_B.y_o_c[rtb_isImpulsive_c + 129].im *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[rtb_isImpulsive_c];
    }

    /*  Surround Phase Selectivity */
    /*  SPS = |Lx - Rx|/(|Lx| + |Rx|) */
    /* '<S1237>:1:12' SPS = abs(Lx - Rx) ./ (abs(Lx) + abs(Rx) + single(eps)); */
    for (i = 0; i < 129; i++)
    {
        updatedLokRokScaleFactor = Model_Target_B.Rx[i].re;
        minXp = Model_Target_B.Rx[i].im;
        maxXp = Model_Target_B.Lx[i].re;
        Lx_im = Model_Target_B.Lx[i].im;
        updatedLokRokScaleFactor = qhmath_div_f(qhmath_hypot_f(maxXp -
            updatedLokRokScaleFactor, Lx_im - minXp), (qhmath_hypot_f(maxXp,
            Lx_im) + qhmath_hypot_f(updatedLokRokScaleFactor, minXp)) +
            2.22044605E-16F);
        Model_Target_B.Lstrk_k[i] = updatedLokRokScaleFactor;
        Model_Target_B.Lin2_a[i] *= updatedLokRokScaleFactor;
    }

    /* End of MATLAB Function: '<S1225>/MATLAB Function' */

    /* MATLAB Function: '<S1240>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain2'
     *  Constant: '<S1226>/lsPole2'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lin2_a, 0.324919701F,
        0.33754015F, &Model_Target_B.sf_MATLABFunction_d,
        &Model_Target_DW.sf_MATLABFunction_d);

    /* Product: '<S1225>/Multiply' incorporates:
     *  Constant: '<S1236>/Constant1'
     *  Math: '<S1236>/Math Function1'
     *  Product: '<S1236>/Multiply'
     *  Sum: '<S1236>/Add'
     *
     * About '<S1236>/Math Function1':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_eo.y[i] + 2.22044605E-16F) *
            Model_Target_B.sf_MATLABFunction_d.y[i] *
            Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[i];
    }

    /* End of Product: '<S1225>/Multiply' */

    /* Product: '<S1238>/|Rx|^2' incorporates:
     *  Math: '<S1225>/Math Function1'
     *  Math: '<S1238>/Math Function'
     *
     * About '<S1225>/Math Function1':
     *  Operator: magnitude^2
     *
     * About '<S1238>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        /* Math: '<S1238>/Math Function'
         *
         * About '<S1238>/Math Function':
         *  Operator: magnitude^2
         */
        updatedLokRokScaleFactor = Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[i];

        /* Math: '<S1225>/Math Function1'
         *
         * About '<S1225>/Math Function1':
         *  Operator: magnitude^2
         */
        minXp = Model_Target_B.sf_Coeffs1stStage.absRi[i];
        Model_Target_B.Lin2_a[i] = updatedLokRokScaleFactor *
            updatedLokRokScaleFactor * (minXp * minXp);
    }

    /* End of Product: '<S1238>/|Rx|^2' */

    /* MATLAB Function: '<S1244>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain2'
     *  Constant: '<S1226>/lsPole2'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lin2_a, 0.324919701F,
        0.33754015F, &Model_Target_B.sf_MATLABFunction_ea,
        &Model_Target_DW.sf_MATLABFunction_ea);

    /* Product: '<S1238>/SPS*|Rx|^2' incorporates:
     *  Product: '<S1238>/|Rx|^2'
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Lin2_a[rtb_isImpulsive_c] *=
            Model_Target_B.Lstrk_k[rtb_isImpulsive_c];
    }

    /* End of Product: '<S1238>/SPS*|Rx|^2' */

    /* MATLAB Function: '<S1243>/MATLAB Function' incorporates:
     *  Constant: '<S1226>/lsGain2'
     *  Constant: '<S1226>/lsPole2'
     */
    Model_Target_MATLABFunction_nq(Model_Target_B.Lin2_a, 0.324919701F,
        0.33754015F, &Model_Target_B.sf_MATLABFunction_fs4,
        &Model_Target_DW.sf_MATLABFunction_fs4);

    /* Product: '<S1225>/Multiply1' incorporates:
     *  Constant: '<S1238>/Constant1'
     *  Math: '<S1238>/Math Function1'
     *  Product: '<S1238>/Multiply'
     *  Sum: '<S1238>/Add'
     *
     * About '<S1238>/Math Function1':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk_k[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_ea.y[i] + 2.22044605E-16F) *
            Model_Target_B.sf_MATLABFunction_fs4.y[i] *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[i];
    }

    /* End of Product: '<S1225>/Multiply1' */

    /* MATLAB Function: '<S1218>/Apply coefficients' incorporates:
     *  Product: '<S1225>/Multiply'
     *  Product: '<S1225>/Multiply1'
     *  Selector: '<S1214>/Selector'
     *  Selector: '<S1214>/Selector1'
     */
    /*  Left/Right only */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Apply coefficients': '<S1219>:1' */
    /* '<S1219>:1:4' Lo = Lok.*L; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c].re =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lok[rtb_isImpulsive_c] *
            Model_Target_B.y_o_c[rtb_isImpulsive_c].re;
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c].im =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lok[rtb_isImpulsive_c] *
            Model_Target_B.y_o_c[rtb_isImpulsive_c].im;
    }

    /* '<S1219>:1:5' Ro = Rok.*R; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 129].re =
            Model_Target_B.y_o_c[rtb_isImpulsive_c + 129].re *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rok[rtb_isImpulsive_c];
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 129].im =
            Model_Target_B.y_o_c[rtb_isImpulsive_c + 129].im *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rok[rtb_isImpulsive_c];
    }

    /*  Left/Right surround */
    /* '<S1219>:1:8' Ls = Lsk.*L; */
    /* '<S1219>:1:9' Rs = Rsk.*R; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        updatedLokRokScaleFactor = Model_Target_B.Lstrk_k[rtb_isImpulsive_c];
        rtb_Add1_b = Model_Target_B.Multiply_a[rtb_isImpulsive_c];
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 258].re =
            rtb_Add1_b * Model_Target_B.y_o_c[rtb_isImpulsive_c].re;
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 258].im =
            rtb_Add1_b * Model_Target_B.y_o_c[rtb_isImpulsive_c].im;
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 387].re =
            Model_Target_B.y_o_c[rtb_isImpulsive_c + 129].re *
            updatedLokRokScaleFactor;
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 387].im =
            Model_Target_B.y_o_c[rtb_isImpulsive_c + 129].im *
            updatedLokRokScaleFactor;
    }

    /*  Left/Right surround residual */
    /* '<S1219>:1:12' Lsr = (Lxk - Lsk) .*L ; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        rtb_Add1_b =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[rtb_isImpulsive_c] -
            Model_Target_B.Multiply_a[rtb_isImpulsive_c];
        Model_Target_B.Lx[rtb_isImpulsive_c].re = rtb_Add1_b *
            Model_Target_B.y_o_c[rtb_isImpulsive_c].re;
        Model_Target_B.Lx[rtb_isImpulsive_c].im = rtb_Add1_b *
            Model_Target_B.y_o_c[rtb_isImpulsive_c].im;
    }

    /* '<S1219>:1:13' Rsr = (Rxk - Rsk) .*R; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        rtb_Add1_b =
            Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[rtb_isImpulsive_c] -
            Model_Target_B.Lstrk_k[rtb_isImpulsive_c];
        Model_Target_B.Rx[rtb_isImpulsive_c].re =
            Model_Target_B.y_o_c[rtb_isImpulsive_c + 129].re * rtb_Add1_b;
        Model_Target_B.Rx[rtb_isImpulsive_c].im =
            Model_Target_B.y_o_c[rtb_isImpulsive_c + 129].im * rtb_Add1_b;
    }

    /* End of MATLAB Function: '<S1218>/Apply coefficients' */

    /* Product: '<S1272>/Divide' incorporates:
     *  Constant: '<S1272>/Constant'
     *  Constant: '<S1272>/Constant1'
     *  Product: '<S1283>/Divide'
     *  Sum: '<S1272>/Minus'
     */
    Lx_im = (1.0F -
             Model_Target_PreAmp0.MedusaDeciRateFdpSpumFastPsdSmoothFactor) *
        0.5F;

    /* Sum: '<S1273>/Matrix Sum' */
    minXp = -0.0F;
    for (i = 0; i < 129; i++)
    {
        /* Math: '<S1217>/Math Function' incorporates:
         *  Math: '<S1217>/Math Function1'
         *  Math: '<S1247>/Math Function'
         *  Math: '<S1247>/Math Function1'
         *  Selector: '<S1214>/Selector'
         *  Selector: '<S1214>/Selector1'
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1217>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1247>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1247>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_o_0 = &Model_Target_B.Lx[i];

        /* Math: '<S1217>/Math Function'
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_B.MathFunction_l[i] = rtb_y_o_0->re * rtb_y_o_0->re +
            rtb_y_o_0->im * rtb_y_o_0->im;

        /* Sum: '<S1272>/Add1' incorporates:
         *  Delay: '<S1272>/Delay'
         *  Delay: '<S1272>/Delay1'
         *  Math: '<S1217>/Math Function'
         *  Product: '<S1272>/Divide'
         *  Product: '<S1272>/Multiply'
         *  Product: '<S1272>/Multiply1'
         *  Sum: '<S1272>/Add'
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_B.Lstrk_k[i] = (Model_Target_B.MathFunction_l[i] +
            Model_Target_DW.Delay_DSTATE_mg[i]) * Lx_im +
            Model_Target_DW.Delay1_DSTATE_g[i] *
            Model_Target_PreAmp0.MedusaDeciRateFdpSpumFastPsdSmoothFactor;

        /* Sum: '<S1273>/Matrix Sum' incorporates:
         *  Math: '<S1217>/Math Function'
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         */
        minXp += Model_Target_B.MathFunction_l[i];
    }

    /* Sum: '<S1276>/Sum2' incorporates:
     *  Constant: '<S1276>/Constant'
     *  Gain: '<S1276>/Gain'
     *  Math: '<S1276>/log10'
     *  Sum: '<S1276>/Sum1'
     *
     * About '<S1276>/log10':
     *  Operator: log10
     */
    updatedLokRokScaleFactor = qhmath_log10_f(minXp + 2.22044605E-16F) * 10.0F;

    /* MATLAB Function: '<S1273>/Detect Impulse' incorporates:
     *  Delay: '<S1273>/Delay'
     *  Sum: '<S1273>/Add1'
     */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/Reverb Extractions/Left Reverb Extraction/Compute PSD/Impulse Detector/Detect Impulse': '<S1275>:1' */
    /* '<S1275>:1:5' if isempty(counter) */
    /* '<S1275>:1:6' if isempty(state) */
    /* '<S1275>:1:8' if (EnergyDifference > DetectImpulseThreshold) */
    if (updatedLokRokScaleFactor - Model_Target_DW.Delay_DSTATE_nr > 6.0F)
    {
        /* '<S1275>:1:9' isImpulsive = 1; */
        rtb_isImpulsive_c = 1;

        /* '<S1275>:1:10' counter = 0; */
        Model_Target_DW.counter_p = 0.0;
    }
    else if ((Model_Target_DW.counter_p <
              Model_Target_MaxValueOfCounterForDetectingImpulse) &&
             (Model_Target_DW.state_e == 1.0))
    {
        /* '<S1275>:1:11' elseif (counter < MaxValueOfCounterForDetectingImpulse) && (state == 1) */
        /* '<S1275>:1:12' isImpulsive = 1; */
        rtb_isImpulsive_c = 1;

        /* '<S1275>:1:13' counter = counter + 1; */
        Model_Target_DW.counter_p++;
    }
    else
    {
        /* '<S1275>:1:14' else */
        /* '<S1275>:1:15' isImpulsive = 0; */
        rtb_isImpulsive_c = 0;
    }

    /* '<S1275>:1:17' state = isImpulsive; */
    Model_Target_DW.state_e = rtb_isImpulsive_c;

    /* End of MATLAB Function: '<S1273>/Detect Impulse' */

    /* Product: '<S1274>/Divide' incorporates:
     *  Constant: '<S1274>/Constant'
     *  Constant: '<S1274>/Constant1'
     *  Product: '<S1285>/Divide'
     *  Sum: '<S1274>/Minus'
     */
    minXp_tmp = (1.0F -
                 Model_Target_PreAmp0.MedusaDeciRateFdpSpumSlowPsdSmoothFactor) *
        0.5F;

    /* Sum: '<S1274>/Add1' incorporates:
     *  Delay: '<S1274>/Delay'
     *  Delay: '<S1274>/Delay1'
     *  Math: '<S1217>/Math Function'
     *  Product: '<S1274>/Divide'
     *  Product: '<S1274>/Multiply'
     *  Product: '<S1274>/Multiply1'
     *  Sum: '<S1274>/Add'
     *
     * About '<S1217>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lin2_a[i] = (Model_Target_B.MathFunction_l[i] +
            Model_Target_DW.Delay_DSTATE_lq[i]) * minXp_tmp +
            Model_Target_DW.Delay1_DSTATE_ab[i] *
            Model_Target_PreAmp0.MedusaDeciRateFdpSpumSlowPsdSmoothFactor;
    }

    /* End of Sum: '<S1274>/Add1' */

    /* Delay: '<S1270>/Delay' incorporates:
     *  Sum: '<S1272>/Add1'
     */
    if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec < 1.0F)
    {
        memcpy(&Model_Target_B.Multiply1_o[0], &Model_Target_B.Lstrk_k[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec >
                645.0F)
        {
            i = 645;
        }
        else
        {
            i = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < 129;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            if ((uint32_T)MedusaFdpDeciRateRfftRfftInput_tmp < (uint32_T)i)
            {
                Model_Target_B.Multiply1_o[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_DW.MedusaDRspumLPxxFast_d
                    [(MedusaFdpDeciRateRfftRfftInput_tmp - i) + 645];
            }
            else
            {
                Model_Target_B.Multiply1_o[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.Lstrk_k[MedusaFdpDeciRateRfftRfftInput_tmp -
                    i];
            }
        }
    }

    /* End of Delay: '<S1270>/Delay' */

    /* Delay: '<S1270>/Delay1' incorporates:
     *  Sum: '<S1274>/Add1'
     */
    if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec < 1.0F)
    {
        memcpy(&Model_Target_B.Multiply1_a[0], &Model_Target_B.Lin2_a[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec >
                645.0F)
        {
            i = 645;
        }
        else
        {
            i = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < 129;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            if ((uint32_T)MedusaFdpDeciRateRfftRfftInput_tmp < (uint32_T)i)
            {
                Model_Target_B.Multiply1_a[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_DW.MedusaDRspumLPxxSlow_i
                    [(MedusaFdpDeciRateRfftRfftInput_tmp - i) + 645];
            }
            else
            {
                Model_Target_B.Multiply1_a[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.Lin2_a[MedusaFdpDeciRateRfftRfftInput_tmp - i];
            }
        }
    }

    /* End of Delay: '<S1270>/Delay1' */

    /* Product: '<S1279>/Divide' incorporates:
     *  Constant: '<S1279>/Constant'
     *  Constant: '<S1279>/Constant1'
     *  Product: '<S1280>/Divide'
     *  Product: '<S1290>/Divide'
     *  Product: '<S1291>/Divide'
     *  Sum: '<S1279>/Minus'
     */
    maxXp = (1.0F - Model_Target_PreAmp0.MedusaDeciRateFdpSpumLsSmoothFactor) *
        0.5F;

    /* Sum: '<S1284>/Matrix Sum' */
    minXp = -0.0F;
    for (i = 0; i < 129; i++)
    {
        /* Switch: '<S1268>/Switch' incorporates:
         *  Constant: '<S1268>/Constant'
         *  Constant: '<S1268>/Constant1'
         *  MinMax: '<S1268>/Min'
         *  Product: '<S1268>/Divide'
         *  Product: '<S1268>/Multiply'
         *  Sum: '<S1268>/Add'
         *  Switch: '<S1270>/Switch'
         *  Switch: '<S1270>/Switch1'
         */
        if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumOverwrite != 0.0F)
        {
            rtb_Add1_b = 1.0F;
        }
        else
        {
            if (rtb_isImpulsive_c > 0)
            {
                /* Switch: '<S1270>/Switch1' incorporates:
                 *  Sum: '<S1272>/Add1'
                 */
                rtb_Add1_b = Model_Target_B.Lstrk_k[i];

                /* Switch: '<S1270>/Switch' incorporates:
                 *  Delay: '<S1270>/Delay'
                 */
                rtb_R_f_re_tmp_0 = Model_Target_B.Multiply1_o[i];
            }
            else
            {
                /* Switch: '<S1270>/Switch1' incorporates:
                 *  Sum: '<S1274>/Add1'
                 */
                rtb_Add1_b = Model_Target_B.Lin2_a[i];

                /* Switch: '<S1270>/Switch' incorporates:
                 *  Delay: '<S1270>/Delay1'
                 */
                rtb_R_f_re_tmp_0 = Model_Target_B.Multiply1_a[i];
            }

            rtb_Add1_b = fminf(1.0F, qhmath_div_f(1.0F, rtb_Add1_b +
                                2.22044605E-16F) * (rtb_R_f_re_tmp_0 *
                                Model_Target_B.Multiply));
        }

        /* End of Switch: '<S1268>/Switch' */

        /* Product: '<S1271>/Multiply' incorporates:
         *  Math: '<S1217>/Math Function'
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_Add1_b *= Model_Target_B.MathFunction_l[i];

        /* Sum: '<S1279>/Add1' incorporates:
         *  Delay: '<S1279>/Delay'
         *  Delay: '<S1279>/Delay1'
         *  Product: '<S1279>/Divide'
         *  Product: '<S1279>/Multiply'
         *  Product: '<S1279>/Multiply1'
         *  Sum: '<S1279>/Add'
         */
        Model_Target_B.Multiply1_a[i] = (rtb_Add1_b +
            Model_Target_DW.Delay_DSTATE_h[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_e2[i] *
            Model_Target_PreAmp0.MedusaDeciRateFdpSpumLsSmoothFactor;

        /* Product: '<S1271>/Multiply' */
        Model_Target_B.Multiply1_o[i] = rtb_Add1_b;

        /* Sum: '<S1280>/Add1' incorporates:
         *  Delay: '<S1280>/Delay'
         *  Delay: '<S1280>/Delay1'
         *  Math: '<S1217>/Math Function'
         *  Product: '<S1280>/Multiply'
         *  Product: '<S1280>/Multiply1'
         *  Sum: '<S1280>/Add'
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_Add1_b = (Model_Target_B.MathFunction_l[i] +
                      Model_Target_DW.Delay_DSTATE_ek[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_o4[i] *
            Model_Target_PreAmp0.MedusaDeciRateFdpSpumLsSmoothFactor;

        /* Product: '<S1271>/Multiply1' incorporates:
         *  Constant: '<S1271>/Constant'
         *  Product: '<S1271>/Divide'
         *  Sum: '<S1271>/Add'
         *  Sum: '<S1271>/Subtract'
         *  Sum: '<S1279>/Add1'
         */
        rtb_R_f_re_tmp = qhmath_div_f(Model_Target_B.Multiply1_a[i], rtb_Add1_b
            + 2.22044605E-16F);
        rtb_R_f_re_tmp_0 = Model_Target_B.Lx[i].re;
        rtb_R_re = rtb_R_f_re_tmp * rtb_R_f_re_tmp_0;
        rtb_R_f_im_tmp = Model_Target_B.Lx[i].im;
        rtb_R_f_re_tmp *= rtb_R_f_im_tmp;

        /* Sum: '<S1271>/Subtract' */
        Model_Target_B.MatrixConcatenate_p[i + 516].re = rtb_R_f_re_tmp_0 -
            rtb_R_re;
        Model_Target_B.MatrixConcatenate_p[i + 516].im = rtb_R_f_im_tmp -
            rtb_R_f_re_tmp;

        /* SignalConversion generated from: '<S1212>/Matrix Concatenate' */
        Model_Target_B.MatrixConcatenate_p[i + 645].re = rtb_R_re;
        Model_Target_B.MatrixConcatenate_p[i + 645].im = rtb_R_f_re_tmp;

        /* Math: '<S1217>/Math Function1' incorporates:
         *  Math: '<S1217>/Math Function'
         *  Math: '<S1247>/Math Function'
         *  Math: '<S1247>/Math Function1'
         *  Selector: '<S1214>/Selector'
         *  Selector: '<S1214>/Selector1'
         *
         * About '<S1217>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1247>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S1247>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_o_0 = &Model_Target_B.Rx[i];
        rtb_MathFunction1_e[i] = rtb_y_o_0->re * rtb_y_o_0->re + rtb_y_o_0->im *
            rtb_y_o_0->im;

        /* Sum: '<S1280>/Add1' */
        rtb_Add1_a[i] = rtb_Add1_b;

        /* Sum: '<S1283>/Add' incorporates:
         *  Math: '<S1217>/Math Function1'
         *
         * About '<S1217>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_Add1_b = rtb_MathFunction1_e[i];

        /* Sum: '<S1283>/Add1' incorporates:
         *  Delay: '<S1283>/Delay'
         *  Delay: '<S1283>/Delay1'
         *  Product: '<S1283>/Multiply'
         *  Product: '<S1283>/Multiply1'
         *  Sum: '<S1283>/Add'
         */
        Model_Target_B.Multiply_bg[i] = (rtb_Add1_b +
            Model_Target_DW.Delay_DSTATE_cg[i]) * Lx_im +
            Model_Target_DW.Delay1_DSTATE_k[i] *
            Model_Target_PreAmp0.MedusaDeciRateFdpSpumFastPsdSmoothFactor;

        /* Sum: '<S1284>/Matrix Sum' */
        minXp += rtb_Add1_b;
    }

    /* Sum: '<S1287>/Sum2' incorporates:
     *  Constant: '<S1287>/Constant'
     *  Gain: '<S1287>/Gain'
     *  Math: '<S1287>/log10'
     *  Sum: '<S1287>/Sum1'
     *
     * About '<S1287>/log10':
     *  Operator: log10
     */
    minXp = qhmath_log10_f(minXp + 2.22044605E-16F) * 10.0F;

    /* MATLAB Function: '<S1284>/Detect Impulse' incorporates:
     *  Delay: '<S1284>/Delay'
     *  Sum: '<S1284>/Add1'
     */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/Reverb Extractions/Right Reverb Extraction/Compute PSD/Impulse Detector/Detect Impulse': '<S1286>:1' */
    /* '<S1286>:1:5' if isempty(counter) */
    /* '<S1286>:1:6' if isempty(state) */
    /* '<S1286>:1:8' if (EnergyDifference > DetectImpulseThreshold) */
    if (minXp - Model_Target_DW.Delay_DSTATE_a > 6.0F)
    {
        /* '<S1286>:1:9' isImpulsive = 1; */
        rtb_isImpulsive_c = 1;

        /* '<S1286>:1:10' counter = 0; */
        Model_Target_DW.counter_n = 0.0;
    }
    else if ((Model_Target_DW.counter_n <
              Model_Target_MaxValueOfCounterForDetectingImpulse) &&
             (Model_Target_DW.state_o == 1.0))
    {
        /* '<S1286>:1:11' elseif (counter < MaxValueOfCounterForDetectingImpulse) && (state == 1) */
        /* '<S1286>:1:12' isImpulsive = 1; */
        rtb_isImpulsive_c = 1;

        /* '<S1286>:1:13' counter = counter + 1; */
        Model_Target_DW.counter_n++;
    }
    else
    {
        /* '<S1286>:1:14' else */
        /* '<S1286>:1:15' isImpulsive = 0; */
        rtb_isImpulsive_c = 0;
    }

    /* '<S1286>:1:17' state = isImpulsive; */
    Model_Target_DW.state_o = rtb_isImpulsive_c;

    /* End of MATLAB Function: '<S1284>/Detect Impulse' */

    /* Sum: '<S1285>/Add1' incorporates:
     *  Delay: '<S1285>/Delay'
     *  Delay: '<S1285>/Delay1'
     *  Math: '<S1217>/Math Function1'
     *  Product: '<S1285>/Multiply'
     *  Product: '<S1285>/Multiply1'
     *  Sum: '<S1285>/Add'
     *
     * About '<S1217>/Math Function1':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS_k[i] = (rtb_MathFunction1_e[i] +
            Model_Target_DW.Delay_DSTATE_ks[i]) * minXp_tmp +
            Model_Target_DW.Delay1_DSTATE_ep[i] *
            Model_Target_PreAmp0.MedusaDeciRateFdpSpumSlowPsdSmoothFactor;
    }

    /* End of Sum: '<S1285>/Add1' */

    /* Delay: '<S1281>/Delay' incorporates:
     *  Sum: '<S1283>/Add1'
     */
    if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec < 1.0F)
    {
        memcpy(&Model_Target_B.Lxks_j[0], &Model_Target_B.Multiply_bg[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec >
                645.0F)
        {
            i = 645;
        }
        else
        {
            i = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < 129;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            if ((uint32_T)MedusaFdpDeciRateRfftRfftInput_tmp < (uint32_T)i)
            {
                Model_Target_B.Lxks_j[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_DW.MedusaDRspumRPxxFast_e
                    [(MedusaFdpDeciRateRfftRfftInput_tmp - i) + 645];
            }
            else
            {
                Model_Target_B.Lxks_j[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.Multiply_bg[MedusaFdpDeciRateRfftRfftInput_tmp
                    - i];
            }
        }
    }

    /* End of Delay: '<S1281>/Delay' */

    /* Delay: '<S1281>/Delay1' incorporates:
     *  Sum: '<S1285>/Add1'
     */
    if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec < 1.0F)
    {
        memcpy(&rtb_Rxks[0], &Model_Target_B.instCPS_k[0], 129U * sizeof
               (real32_T));
    }
    else
    {
        if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec >
                645.0F)
        {
            i = 645;
        }
        else
        {
            i = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp0.MedusaDeciRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < 129;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            if ((uint32_T)MedusaFdpDeciRateRfftRfftInput_tmp < (uint32_T)i)
            {
                rtb_Rxks[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_DW.MedusaDRspumRPxxSlow_i
                    [(MedusaFdpDeciRateRfftRfftInput_tmp - i) + 645];
            }
            else
            {
                rtb_Rxks[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.instCPS_k[MedusaFdpDeciRateRfftRfftInput_tmp
                    - i];
            }
        }
    }

    /* End of Delay: '<S1281>/Delay1' */
    for (i = 0; i < 129; i++)
    {
        /* Switch: '<S1269>/Switch' incorporates:
         *  Constant: '<S1269>/Constant'
         *  Constant: '<S1269>/Constant1'
         *  MinMax: '<S1269>/Min'
         *  Product: '<S1269>/Divide'
         *  Product: '<S1269>/Multiply'
         *  Sum: '<S1269>/Add'
         *  Switch: '<S1281>/Switch'
         *  Switch: '<S1281>/Switch1'
         */
        if (Model_Target_PreAmp0.MedusaDeciRateFdpSpumOverwrite != 0.0F)
        {
            rtb_Add1_b = 1.0F;
        }
        else
        {
            if (rtb_isImpulsive_c > 0)
            {
                /* Switch: '<S1281>/Switch1' incorporates:
                 *  Sum: '<S1283>/Add1'
                 */
                rtb_Add1_b = Model_Target_B.Multiply_bg[i];

                /* Switch: '<S1281>/Switch' incorporates:
                 *  Delay: '<S1281>/Delay'
                 */
                rtb_R_f_re_tmp_0 = Model_Target_B.Lxks_j[i];
            }
            else
            {
                /* Switch: '<S1281>/Switch1' incorporates:
                 *  Sum: '<S1285>/Add1'
                 */
                rtb_Add1_b = Model_Target_B.instCPS_k[i];

                /* Switch: '<S1281>/Switch' incorporates:
                 *  Delay: '<S1281>/Delay1'
                 */
                rtb_R_f_re_tmp_0 = rtb_Rxks[i];
            }

            rtb_Add1_b = fminf(1.0F, qhmath_div_f(1.0F, rtb_Add1_b +
                                2.22044605E-16F) * (rtb_R_f_re_tmp_0 *
                                Model_Target_B.Multiply));
        }

        /* Product: '<S1282>/Multiply' incorporates:
         *  Math: '<S1217>/Math Function1'
         *  Product: '<S1282>/Divide'
         *
         * About '<S1217>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_Add1_b *= rtb_MathFunction1_e[i];

        /* Switch: '<S1269>/Switch' incorporates:
         *  Product: '<S1282>/Divide'
         */
        Model_Target_B.Multiply_a[i] = rtb_Add1_b;

        /* Sum: '<S1290>/Add1' incorporates:
         *  Delay: '<S1290>/Delay'
         *  Delay: '<S1290>/Delay1'
         *  Product: '<S1290>/Multiply'
         *  Product: '<S1290>/Multiply1'
         *  Sum: '<S1290>/Add'
         */
        Model_Target_B.Lxks_j[i] = (rtb_Add1_b +
            Model_Target_DW.Delay_DSTATE_ai[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_i[i] *
            Model_Target_PreAmp0.MedusaDeciRateFdpSpumLsSmoothFactor;

        /* Sum: '<S1291>/Add1' incorporates:
         *  Delay: '<S1291>/Delay'
         *  Delay: '<S1291>/Delay1'
         *  Math: '<S1217>/Math Function1'
         *  Product: '<S1291>/Multiply'
         *  Product: '<S1291>/Multiply1'
         *  Sum: '<S1291>/Add'
         *
         * About '<S1217>/Math Function1':
         *  Operator: magnitude^2
         */
        Lx_im = (rtb_MathFunction1_e[i] + Model_Target_DW.Delay_DSTATE_at[i]) *
            maxXp + Model_Target_DW.Delay1_DSTATE_aa[i] *
            Model_Target_PreAmp0.MedusaDeciRateFdpSpumLsSmoothFactor;

        /* Product: '<S1282>/Multiply1' incorporates:
         *  Constant: '<S1282>/Constant'
         *  Product: '<S1282>/Divide'
         *  Sum: '<S1282>/Add'
         *  Sum: '<S1282>/Subtract'
         *  Sum: '<S1290>/Add1'
         */
        rtb_R_f_re_tmp = qhmath_div_f(Model_Target_B.Lxks_j[i], Lx_im +
            2.22044605E-16F);
        rtb_R_f_re_tmp_0 = Model_Target_B.Rx[i].re;
        rtb_R_re = rtb_R_f_re_tmp * rtb_R_f_re_tmp_0;
        rtb_R_f_im_tmp = Model_Target_B.Rx[i].im;
        rtb_R_f_re_tmp *= rtb_R_f_im_tmp;

        /* Sum: '<S1282>/Subtract' */
        Model_Target_B.MatrixConcatenate_p[i + 774].re = rtb_R_f_re_tmp_0 -
            rtb_R_re;
        Model_Target_B.MatrixConcatenate_p[i + 774].im = rtb_R_f_im_tmp -
            rtb_R_f_re_tmp;

        /* SignalConversion generated from: '<S1212>/Matrix Concatenate' */
        Model_Target_B.MatrixConcatenate_p[i + 903].re = rtb_R_re;
        Model_Target_B.MatrixConcatenate_p[i + 903].im = rtb_R_f_re_tmp;

        /* Sum: '<S1291>/Add1' */
        rtb_Rxks[i] = Lx_im;
    }

    /* MATLAB Function: '<S1294>/MATLAB Function' incorporates:
     *  Concatenate: '<S1212>/Matrix Concatenate'
     *  Constant: '<S1213>/Constant'
     */
    /* MATLAB Function 'RifftWola/RifftWola/Hexagon/MATLAB Function': '<S1296>:1' */
    /* '<S1296>:1:7' [~, numChannels] = size(u); */
    /* '<S1296>:1:8' outputSize = fftSize - numOverlap; */
    /*  Buffer to hold overlapped samples */
    /* '<S1296>:1:12' if isempty(outputOverlap) */
    /*  Buffer for Simulation  */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S1296>:1:20' y = coder.nullcopy(single(zeros(outputSize, numChannels))); */
    /*  Simulation */
    /* '<S1296>:1:23' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1296>:1:33' else */
    /* '<S1296>:1:34' y = rifft_process(   single(complex(u)), ... */
    /* '<S1296>:1:35'                         single(Twiddle1),... */
    /* '<S1296>:1:36'                         single(Twiddle2),...  */
    /* '<S1296>:1:37'                         single(RifftOutputTmp),... */
    /* '<S1296>:1:38'                         single(win),... */
    /* '<S1296>:1:39'                         outputOverlap,... */
    /* '<S1296>:1:40'                         int32(fftSize),... */
    /* '<S1296>:1:41'                         int32(numChannels),... */
    /* '<S1296>:1:42'                         int32(numOverlap)); */
    rifft_process(&Model_Target_B.y_pz[0], &Model_Target_B.MatrixConcatenate_p[0],
                  &MedusaFdpDeciRateRifftRifftBufferTwiddle1[0],
                  &MedusaFdpDeciRateRifftRifftBufferTwiddle2[0],
                  &MedusaFdpDeciRateRifftRifftBufferRifftOutputTmp[0],
                  &Model_Target_ConstP.pooled80[0],
                  &Model_Target_DW.outputOverlap_j[0], 256, 8, 128);

    /* Buffer: '<S1204>/BufferOut' */
    rtb_isImpulsive_c = 0;
    for (i = 0; i < 8; i++)
    {
        int32_T tmp;
        int32_T tmp_0;
        memIdx = 128;
        tmp_0 = i << 8;
        tmp = tmp_0 + Model_Target_DW.BufferOut_inBufPtrIdx;
        if (Model_Target_DW.BufferOut_inBufPtrIdx > 128)
        {
            for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                    MedusaFdpDeciRateRfftRfftInput_tmp < 256 -
                    Model_Target_DW.BufferOut_inBufPtrIdx;
                    MedusaFdpDeciRateRfftRfftInput_tmp++)
            {
                Model_Target_DW.BufferOut_CircBuf[tmp +
                    MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.y_pz[rtb_isImpulsive_c +
                    MedusaFdpDeciRateRfftRfftInput_tmp];
            }

            rtb_isImpulsive_c = (rtb_isImpulsive_c -
                                 Model_Target_DW.BufferOut_inBufPtrIdx) + 256;
            tmp = tmp_0;
            memIdx = Model_Target_DW.BufferOut_inBufPtrIdx - 128;
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < memIdx;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            Model_Target_DW.BufferOut_CircBuf[tmp +
                MedusaFdpDeciRateRfftRfftInput_tmp] =
                Model_Target_B.y_pz[rtb_isImpulsive_c +
                MedusaFdpDeciRateRfftRfftInput_tmp];
        }

        rtb_isImpulsive_c += memIdx;
    }

    Model_Target_DW.BufferOut_inBufPtrIdx += 128;
    if (Model_Target_DW.BufferOut_inBufPtrIdx >= 256)
    {
        Model_Target_DW.BufferOut_inBufPtrIdx -= 256;
    }

    /* End of Buffer: '<S1204>/BufferOut' */
    /* Update for Delay: '<S1273>/Delay' */
    Model_Target_DW.Delay_DSTATE_nr = updatedLokRokScaleFactor;

    /* Update for Delay: '<S1272>/Delay' incorporates:
     *  Math: '<S1217>/Math Function'
     *
     * About '<S1217>/Math Function':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_mg[0], &Model_Target_B.MathFunction_l[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S1272>/Delay1' incorporates:
     *  Sum: '<S1272>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_g[0], &Model_Target_B.Lstrk_k[0], 129U
           * sizeof(real32_T));

    /* Update for Delay: '<S1274>/Delay' incorporates:
     *  Math: '<S1217>/Math Function'
     *
     * About '<S1217>/Math Function':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_lq[0], &Model_Target_B.MathFunction_l[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S1274>/Delay1' incorporates:
     *  Sum: '<S1274>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_ab[0], &Model_Target_B.Lin2_a[0], 129U
           * sizeof(real32_T));

    /* Update for Delay: '<S1270>/Delay' incorporates:
     *  Sum: '<S1272>/Add1'
     */
    for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
            MedusaFdpDeciRateRfftRfftInput_tmp < 516;
            MedusaFdpDeciRateRfftRfftInput_tmp++)
    {
        Model_Target_DW.MedusaDRspumLPxxFast_d[MedusaFdpDeciRateRfftRfftInput_tmp]
            =
            Model_Target_DW.MedusaDRspumLPxxFast_d[MedusaFdpDeciRateRfftRfftInput_tmp
            + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumLPxxFast_d[516],
           &Model_Target_B.Lstrk_k[0], 129U * sizeof(real32_T));

    /* End of Update for Delay: '<S1270>/Delay' */

    /* Update for Delay: '<S1270>/Delay1' */
    for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
            MedusaFdpDeciRateRfftRfftInput_tmp < 516;
            MedusaFdpDeciRateRfftRfftInput_tmp++)
    {
        Model_Target_DW.MedusaDRspumLPxxSlow_i[MedusaFdpDeciRateRfftRfftInput_tmp]
            =
            Model_Target_DW.MedusaDRspumLPxxSlow_i[MedusaFdpDeciRateRfftRfftInput_tmp
            + 129];
    }

    /* Update for Delay: '<S1284>/Delay' */
    Model_Target_DW.Delay_DSTATE_a = minXp;
    for (i = 0; i < 129; i++)
    {
        /* Update for Delay: '<S1283>/Delay' incorporates:
         *  Math: '<S1217>/Math Function1'
         *
         * About '<S1217>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_Add1_b = rtb_MathFunction1_e[i];

        /* Update for Delay: '<S1270>/Delay1' incorporates:
         *  Sum: '<S1274>/Add1'
         */
        Model_Target_DW.MedusaDRspumLPxxSlow_i[i + 516] =
            Model_Target_B.Lin2_a[i];

        /* Update for Delay: '<S1279>/Delay' incorporates:
         *  Product: '<S1271>/Multiply'
         */
        Model_Target_DW.Delay_DSTATE_h[i] = Model_Target_B.Multiply1_o[i];

        /* Update for Delay: '<S1279>/Delay1' incorporates:
         *  Sum: '<S1279>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_e2[i] = Model_Target_B.Multiply1_a[i];

        /* Update for Delay: '<S1280>/Delay' incorporates:
         *  Math: '<S1217>/Math Function'
         *
         * About '<S1217>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_DW.Delay_DSTATE_ek[i] = Model_Target_B.MathFunction_l[i];

        /* Update for Delay: '<S1280>/Delay1' incorporates:
         *  Sum: '<S1280>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_o4[i] = rtb_Add1_a[i];

        /* Update for Delay: '<S1283>/Delay' */
        Model_Target_DW.Delay_DSTATE_cg[i] = rtb_Add1_b;

        /* Update for Delay: '<S1283>/Delay1' incorporates:
         *  Sum: '<S1283>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_k[i] = Model_Target_B.Multiply_bg[i];

        /* Update for Delay: '<S1285>/Delay' */
        Model_Target_DW.Delay_DSTATE_ks[i] = rtb_Add1_b;

        /* Update for Delay: '<S1285>/Delay1' incorporates:
         *  Sum: '<S1285>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_ep[i] = Model_Target_B.instCPS_k[i];
    }

    /* Update for Delay: '<S1281>/Delay' incorporates:
     *  Sum: '<S1283>/Add1'
     */
    for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
            MedusaFdpDeciRateRfftRfftInput_tmp < 516;
            MedusaFdpDeciRateRfftRfftInput_tmp++)
    {
        Model_Target_DW.MedusaDRspumRPxxFast_e[MedusaFdpDeciRateRfftRfftInput_tmp]
            =
            Model_Target_DW.MedusaDRspumRPxxFast_e[MedusaFdpDeciRateRfftRfftInput_tmp
            + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumRPxxFast_e[516],
           &Model_Target_B.Multiply_bg[0], 129U * sizeof(real32_T));

    /* End of Update for Delay: '<S1281>/Delay' */

    /* Update for Delay: '<S1281>/Delay1' incorporates:
     *  Sum: '<S1285>/Add1'
     */
    for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
            MedusaFdpDeciRateRfftRfftInput_tmp < 516;
            MedusaFdpDeciRateRfftRfftInput_tmp++)
    {
        Model_Target_DW.MedusaDRspumRPxxSlow_i[MedusaFdpDeciRateRfftRfftInput_tmp]
            =
            Model_Target_DW.MedusaDRspumRPxxSlow_i[MedusaFdpDeciRateRfftRfftInput_tmp
            + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumRPxxSlow_i[516],
           &Model_Target_B.instCPS_k[0], 129U * sizeof(real32_T));

    /* End of Update for Delay: '<S1281>/Delay1' */

    /* Update for Delay: '<S1290>/Delay' incorporates:
     *  Product: '<S1282>/Multiply'
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_ai[0], &Model_Target_B.Multiply_a[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S1290>/Delay1' incorporates:
     *  Sum: '<S1290>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_i[0], &Model_Target_B.Lxks_j[0], 129U *
           sizeof(real32_T));

    /* Update for Delay: '<S1291>/Delay' incorporates:
     *  Math: '<S1217>/Math Function1'
     *
     * About '<S1217>/Math Function1':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_at[0], &rtb_MathFunction1_e[0], 129U *
           sizeof(real32_T));

    /* Update for Delay: '<S1291>/Delay1' incorporates:
     *  Sum: '<S1291>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_aa[0], &rtb_Rxks[0], 129U * sizeof
           (real32_T));
}

/*
 * Output and update for action system:
 *    '<S1493>/Fading Forward'
 *    '<S1481>/Fading Forward'
 *    '<S1505>/Fading Forward'
 *    '<S1584>/Fading Forward'
 *    '<S1572>/Fading Forward'
 *    '<S1596>/Fading Forward'
 */
void Model_Target_FadingForward(real32_T rtu_backFadeGain, real32_T
    rtu_forwardDownmixThreshold, real32_T rtu_forwardDownmixMax, real32_T
    *rty_downmix)
{
    /* Product: '<S1498>/Multiply' incorporates:
     *  Constant: '<S1498>/Constant'
     *  Constant: '<S1498>/EPS'
     *  MinMax: '<S1498>/Max'
     *  MinMax: '<S1498>/Min'
     *  Product: '<S1498>/Divide'
     *  Sum: '<S1498>/Subtract'
     */
    *rty_downmix = (1.0F - qhmath_div_f(fminf(rtu_backFadeGain,
                      rtu_forwardDownmixThreshold), fmaxf
                     (rtu_forwardDownmixThreshold, 1.1920929E-7F))) *
        rtu_forwardDownmixMax;
}

/*
 * Output and update for action system:
 *    '<S1493>/Fading Backward'
 *    '<S1481>/Fading Backward'
 *    '<S1505>/Fading Backward'
 *    '<S1584>/Fading Backward'
 *    '<S1572>/Fading Backward'
 *    '<S1596>/Fading Backward'
 */
void Model_Target_FadingBackward(real32_T rtu_frontFadeGain, real32_T
    rtu_backwardDownmixThreshold, real32_T rtu_backwardDownmixMax, real32_T
    *rty_downmix)
{
    /* Product: '<S1497>/Multiply' incorporates:
     *  Constant: '<S1497>/Constant'
     *  Constant: '<S1497>/EPS'
     *  MinMax: '<S1497>/Max'
     *  MinMax: '<S1497>/Min'
     *  Product: '<S1497>/Divide'
     *  Sum: '<S1497>/Subtract'
     */
    *rty_downmix = (1.0F - qhmath_div_f(fminf(rtu_frontFadeGain,
                      rtu_backwardDownmixThreshold), fmaxf
                     (rtu_backwardDownmixThreshold, 1.1920929E-7F))) *
        rtu_backwardDownmixMax;
}

/* Output and update for atomic system: '<S1483>/process' */
void Model_Target_process(const boolean_T *rtd_FRM_Freeze_CS, real32_T
    rtd_FRM_currentGain_CS[12], int32_T rtd_FRM_frameCount_CS[12], const
    real32_T rtd_FRM_rampCoeff_CS[12], const real32_T rtd_FRM_targetGain_CS[12])
{
    int32_T i;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/process': '<S1490>:1' */
    /* '<S1490>:1:10' for i = 1:numel(FRM_currentGain_CS) */
    for (i = 0; i < 12; i++)
    {
        /* '<S1490>:1:11' if (FRM_Freeze_CS(1) == false) */
        if (!*rtd_FRM_Freeze_CS)
        {
            /* '<S1490>:1:12' if (FRM_frameCount_CS(i) == 0) */
            if (rtd_FRM_frameCount_CS[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1490>:1:14' FRM_currentGain_CS(i) = FRM_targetGain_CS(i); */
                rtd_FRM_currentGain_CS[i] = rtd_FRM_targetGain_CS[i];
            }
            else
            {
                /* '<S1490>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1490>:1:17' FRM_currentGain_CS(i) = FRM_currentGain_CS(i)*FRM_rampCoeff_CS(i); */
                rtd_FRM_currentGain_CS[i] *= rtd_FRM_rampCoeff_CS[i];

                /* '<S1490>:1:18' FRM_frameCount_CS(i) = FRM_frameCount_CS(i) - 1; */
                rtd_FRM_frameCount_CS[i]--;
            }
        }
    }
}

/* Output and update for atomic system: '<S1495>/process' */
void Model_Target_process_o(const boolean_T *rtd_FRM_Freeze_Left, real32_T
    rtd_FRM_currentGain_Left[30], int32_T rtd_FRM_frameCount_Left[30], const
    real32_T rtd_FRM_rampCoeff_Left[30], const real32_T rtd_FRM_targetGain_Left
    [30])
{
    int32_T i;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Ramper/process': '<S1502>:1' */
    /* '<S1502>:1:10' for i = 1:numel(FRM_currentGain_Left) */
    for (i = 0; i < 30; i++)
    {
        /* '<S1502>:1:11' if (FRM_Freeze_Left(1) == false) */
        if (!*rtd_FRM_Freeze_Left)
        {
            /* '<S1502>:1:12' if (FRM_frameCount_Left(i) == 0) */
            if (rtd_FRM_frameCount_Left[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1502>:1:14' FRM_currentGain_Left(i) = FRM_targetGain_Left(i); */
                rtd_FRM_currentGain_Left[i] = rtd_FRM_targetGain_Left[i];
            }
            else
            {
                /* '<S1502>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1502>:1:17' FRM_currentGain_Left(i) = FRM_currentGain_Left(i)*FRM_rampCoeff_Left(i); */
                rtd_FRM_currentGain_Left[i] *= rtd_FRM_rampCoeff_Left[i];

                /* '<S1502>:1:18' FRM_frameCount_Left(i) = FRM_frameCount_Left(i) - 1; */
                rtd_FRM_frameCount_Left[i]--;
            }
        }
    }
}

/* Output and update for atomic system: '<S1507>/process' */
void Model_Target_process_i(const boolean_T *rtd_FRM_Freeze_Right, real32_T
    rtd_FRM_currentGain_Right[30], int32_T rtd_FRM_frameCount_Right[30], const
    real32_T rtd_FRM_rampCoeff_Right[30], const real32_T
    rtd_FRM_targetGain_Right[30])
{
    int32_T i;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Ramper/process': '<S1514>:1' */
    /* '<S1514>:1:10' for i = 1:numel(FRM_currentGain_Right) */
    for (i = 0; i < 30; i++)
    {
        /* '<S1514>:1:11' if (FRM_Freeze_Right(1) == false) */
        if (!*rtd_FRM_Freeze_Right)
        {
            /* '<S1514>:1:12' if (FRM_frameCount_Right(i) == 0) */
            if (rtd_FRM_frameCount_Right[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1514>:1:14' FRM_currentGain_Right(i) = FRM_targetGain_Right(i); */
                rtd_FRM_currentGain_Right[i] = rtd_FRM_targetGain_Right[i];
            }
            else
            {
                /* '<S1514>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1514>:1:17' FRM_currentGain_Right(i) = FRM_currentGain_Right(i)*FRM_rampCoeff_Right(i); */
                rtd_FRM_currentGain_Right[i] *= rtd_FRM_rampCoeff_Right[i];

                /* '<S1514>:1:18' FRM_frameCount_Right(i) = FRM_frameCount_Right(i) - 1; */
                rtd_FRM_frameCount_Right[i]--;
            }
        }
    }
}

/* Output and update for function-call system: '<S1495>/control' */
void Model_Target_control_m(const real32_T rtu_target_gains_linear[30], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_FRM_Freeze_Left,
    real32_T rtd_FRM_currentGain_Left[30], int32_T rtd_FRM_frameCount_Left[30],
    real32_T rtd_FRM_rampCoeff_Left[30], real32_T rtd_FRM_targetGain_Left[30])
{
    int32_T k;
    real32_T currentgain[30];
    real32_T diff[30];

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Ramper/control': '<S1501>:1' */
    /* '<S1501>:1:10' dim_rgain = size(FRM_currentGain_Left); */
    /* '<S1501>:1:11' rgain_SILENT_GAIN_mat = (MedusaFRMConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1501>:1:15' FRM_Freeze_Left(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1501>:1:24' currentgain = max(FRM_currentGain_Left, rgain_SILENT_GAIN_mat); */
    /* '<S1501>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1501>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 30; k++)
    {
        currentgain[k] = fmaxf(rtd_FRM_currentGain_Left[k], 1.1920929E-7F);
        rtd_FRM_rampCoeff_Left[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1501>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1501>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1501>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1501>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1501>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 30; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_FRM_rampCoeff_Left[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1501>:1:43' quantum_ms = 1000 * (MedusaFRMConfig.frame_size) / (MedusaFRMConfig.sample_rate_in_hertz); */
    /* '<S1501>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1501>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1501>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1501>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1501>:1:63' FRM_frameCount_Left  = int32(numFrames); */
    /* '<S1501>:1:64' FRM_rampCoeff_Left   = single(RampCoef); */
    /* '<S1501>:1:65' FRM_targetGain_Left  = target_gains_linear; */
    /* '<S1501>:1:66' FRM_currentGain_Left = currentgain; */
    for (k = 0; k < 30; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_FRM_rampCoeff_Left[k] = qhmath_div_f(rtd_FRM_rampCoeff_Left[k],
            currentgain_0);
        rtd_FRM_rampCoeff_Left[k] = qhmath_log_f(rtd_FRM_rampCoeff_Left[k]);
        rtd_FRM_rampCoeff_Left[k] = qhmath_div_f(rtd_FRM_rampCoeff_Left[k],
            numFrames);
        rtd_FRM_rampCoeff_Left[k] = qhmath_exp_f(rtd_FRM_rampCoeff_Left[k]);
        rtd_FRM_frameCount_Left[k] = (int32_T)roundf(numFrames);
        rtd_FRM_targetGain_Left[k] = rtu_target_gains_linear[k];
        rtd_FRM_currentGain_Left[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1501>:1:69' FRM_Freeze_Left(1) = false; */
    *rtd_FRM_Freeze_Left = false;
}

/* Output and update for function-call system: '<S1483>/control' */
void Model_Target_control_e(const real32_T rtu_target_gains_linear[12], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_FRM_Freeze_CS, real32_T
    rtd_FRM_currentGain_CS[12], int32_T rtd_FRM_frameCount_CS[12], real32_T
    rtd_FRM_rampCoeff_CS[12], real32_T rtd_FRM_targetGain_CS[12])
{
    int32_T k;
    real32_T currentgain[12];
    real32_T diff[12];

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/control': '<S1489>:1' */
    /* '<S1489>:1:10' dim_rgain = size(FRM_currentGain_CS); */
    /* '<S1489>:1:11' rgain_SILENT_GAIN_mat = (MedusaFRMConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1489>:1:15' FRM_Freeze_CS(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1489>:1:24' currentgain = max(FRM_currentGain_CS, rgain_SILENT_GAIN_mat); */
    /* '<S1489>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1489>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 12; k++)
    {
        currentgain[k] = fmaxf(rtd_FRM_currentGain_CS[k], 1.1920929E-7F);
        rtd_FRM_rampCoeff_CS[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1489>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1489>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1489>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1489>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1489>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 12; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_FRM_rampCoeff_CS[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1489>:1:43' quantum_ms = 1000 * (MedusaFRMConfig.frame_size) / (MedusaFRMConfig.sample_rate_in_hertz); */
    /* '<S1489>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1489>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1489>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1489>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1489>:1:63' FRM_frameCount_CS  = int32(numFrames); */
    /* '<S1489>:1:64' FRM_rampCoeff_CS   = single(RampCoef); */
    /* '<S1489>:1:65' FRM_targetGain_CS  = target_gains_linear; */
    /* '<S1489>:1:66' FRM_currentGain_CS = currentgain; */
    for (k = 0; k < 12; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_FRM_rampCoeff_CS[k] = qhmath_div_f(rtd_FRM_rampCoeff_CS[k],
            currentgain_0);
        rtd_FRM_rampCoeff_CS[k] = qhmath_log_f(rtd_FRM_rampCoeff_CS[k]);
        rtd_FRM_rampCoeff_CS[k] = qhmath_div_f(rtd_FRM_rampCoeff_CS[k],
            numFrames);
        rtd_FRM_rampCoeff_CS[k] = qhmath_exp_f(rtd_FRM_rampCoeff_CS[k]);
        rtd_FRM_frameCount_CS[k] = (int32_T)roundf(numFrames);
        rtd_FRM_targetGain_CS[k] = rtu_target_gains_linear[k];
        rtd_FRM_currentGain_CS[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1489>:1:69' FRM_Freeze_CS(1) = false; */
    *rtd_FRM_Freeze_CS = false;
}

/* Output and update for function-call system: '<S1507>/control' */
void Model_Target_control_a(const real32_T rtu_target_gains_linear[30], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_FRM_Freeze_Right,
    real32_T rtd_FRM_currentGain_Right[30], int32_T rtd_FRM_frameCount_Right[30],
    real32_T rtd_FRM_rampCoeff_Right[30], real32_T rtd_FRM_targetGain_Right[30])
{
    int32_T k;
    real32_T currentgain[30];
    real32_T diff[30];

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Ramper/control': '<S1513>:1' */
    /* '<S1513>:1:10' dim_rgain = size(FRM_currentGain_Right); */
    /* '<S1513>:1:11' rgain_SILENT_GAIN_mat = (MedusaFRMConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1513>:1:15' FRM_Freeze_Right(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1513>:1:24' currentgain = max(FRM_currentGain_Right, rgain_SILENT_GAIN_mat); */
    /* '<S1513>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1513>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 30; k++)
    {
        currentgain[k] = fmaxf(rtd_FRM_currentGain_Right[k], 1.1920929E-7F);
        rtd_FRM_rampCoeff_Right[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1513>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1513>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1513>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1513>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1513>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 30; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_FRM_rampCoeff_Right[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1513>:1:43' quantum_ms = 1000 * (MedusaFRMConfig.frame_size) / (MedusaFRMConfig.sample_rate_in_hertz); */
    /* '<S1513>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1513>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1513>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1513>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1513>:1:63' FRM_frameCount_Right  = int32(numFrames); */
    /* '<S1513>:1:64' FRM_rampCoeff_Right   = single(RampCoef); */
    /* '<S1513>:1:65' FRM_targetGain_Right  = target_gains_linear; */
    /* '<S1513>:1:66' FRM_currentGain_Right = currentgain; */
    for (k = 0; k < 30; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_FRM_rampCoeff_Right[k] = qhmath_div_f(rtd_FRM_rampCoeff_Right[k],
            currentgain_0);
        rtd_FRM_rampCoeff_Right[k] = qhmath_log_f(rtd_FRM_rampCoeff_Right[k]);
        rtd_FRM_rampCoeff_Right[k] = qhmath_div_f(rtd_FRM_rampCoeff_Right[k],
            numFrames);
        rtd_FRM_rampCoeff_Right[k] = qhmath_exp_f(rtd_FRM_rampCoeff_Right[k]);
        rtd_FRM_frameCount_Right[k] = (int32_T)roundf(numFrames);
        rtd_FRM_targetGain_Right[k] = rtu_target_gains_linear[k];
        rtd_FRM_currentGain_Right[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1513>:1:69' FRM_Freeze_Right(1) = false; */
    *rtd_FRM_Freeze_Right = false;
}

/*
 * Output and update for function-call system:
 *    '<S1553>/Reset'
 *    '<S1561>/Reset'
 */
void Model_Target_Reset_m(real32_T rtd_states_b[10])
{
    int32_T i;

    /*  Reset the states DSM to zeros */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/Reset': '<S1555>:1' */
    /* '<S1555>:1:6' states(:) = 0; */
    for (i = 0; i < 10; i++)
    {
        rtd_states_b[i] = 0.0F;
    }
}

/*
 * Output and update for atomic system:
 *    '<S1553>/PoolIirProcess'
 *    '<S1561>/PoolIirProcess'
 */
void Model_Target_PoolIirProcess_i(const real32_T rtu_x[8], uint32_T
    rtu_numStages, const real32_T rtu_coeffs[21], real32_T rtd_states_b[10],
    B_PoolIirProcess_Model_Target_f_T *localB)
{
    real_T stateIdx;
    int32_T i;
    real32_T a2;
    real32_T gain;
    real32_T q;
    real32_T w1;
    real32_T w2;
    real32_T xx;
    real32_T yy;
    uint32_T st;

    /*  Extract configuration information from inputs */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/PoolIirProcess': '<S1554>:1' */
    /* '<S1554>:1:5' [frame_size, num_channels] = size(x); */
    /*  Initialize variables */
    /*  Typecast the variables */
    /* '<S1554>:1:11' frame_size = uint32(frame_size); */
    /* '<S1554>:1:12' num_channels = uint32(num_channels); */
    /* Compute the filter coefficients */
    /* '<S1554>:1:15' y = pooliir(x, frame_size, num_channels, numStages, coeffs, states); */
    /*  We have to use a different state buffer than the one passed in.  Matlab */
    /*  value objects are passed by value, not by reference, so the saving of */
    /*  states here does not work.  The state buffer is still necessary to pass */
    /*  allocate in the calling function and pass here in order to trigger CRL. */
    /*  This double buffering is annoying, however only happens during */
    /*  simulation, not code generation. */
    /*  num_states = (length(coeffs) - numChannels) / 2; */
    /*  persistent states; */
    /*  if isempty(states) */
    /*      states = single(zeros(1, num_states)); */
    /*  end */
    /* 'pooliir:15' stateIdx = 1; */
    /* 'pooliir:16' coeffIdx = 1; */
    /* 'pooliir:18' frameMinus1  = frameSize-1; */
    /*  number of samples minus one */
    /* 'pooliir:19' y     = coder.nullcopy(x); */
    /*  output matrix */
    /*  OUTER LOOP over all channels                  */
    /* 'pooliir:22' for cha = 1:numChannels */
    /*  FIRST STAGE */
    /*  prologue: get coefficients, states and input vector  */
    /*  and perform some computations */
    /* 'pooliir:28' w1 = states(stateIdx); */
    /* 'pooliir:28' stateIdx = stateIdx+1; */
    /* 'pooliir:29' gain = coeffs(coeffIdx); */
    gain = rtu_coeffs[0];

    /* 'pooliir:29' coeffIdx = coeffIdx+1; */
    /* 'pooliir:30' w2 = states(stateIdx); */
    w2 = rtd_states_b[1];

    /* 'pooliir:30' stateIdx = stateIdx-1; */
    /* 'pooliir:31' a2   = coeffs(coeffIdx); */
    a2 = rtu_coeffs[1];

    /* 'pooliir:31' coeffIdx = coeffIdx+1; */
    /* 'pooliir:32' xx  = x(1,cha); */
    /* 'pooliir:32' a1   = coeffs(coeffIdx); */
    /* 'pooliir:32' coeffIdx = coeffIdx+1; */
    /* 'pooliir:33' xx  = xx*gain; */
    xx = rtu_x[0] * rtu_coeffs[0];

    /* 'pooliir:33' b2   = coeffs(coeffIdx); */
    /* 'pooliir:33' coeffIdx = coeffIdx+1; */
    /* 'pooliir:34' yy  = w1+xx; */
    yy = rtd_states_b[0] + xx;

    /* 'pooliir:34' b1   = coeffs(coeffIdx); */
    /* 'pooliir:34' coeffIdx = coeffIdx+1; */
    /* 'pooliir:35' w1  = b1*xx; */
    w1 = rtu_coeffs[4] * xx;

    /*  main loop: 5 ops/sample */
    /* 'pooliir:38' i = 1; */
    /* 'pooliir:39' while i <= frameMinus1 */
    for (i = 0; i < 7; i++)
    {
        /* 'pooliir:40' r  = a1*yy; */
        /* 'pooliir:40' w1 = w1+w2; */
        w1 += w2;

        /* 'pooliir:40' y(i,cha) = yy; */
        localB->y[i] = yy;

        /* 'pooliir:41' q  = b2*xx; */
        q = rtu_coeffs[3] * xx;

        /* 'pooliir:41' w1 = w1-r; */
        /* 'pooliir:41' xx = x(i+1,cha); */
        /* 'pooliir:42' xx = xx*gain; */
        xx = rtu_x[i + 1] * gain;

        /* 'pooliir:43' w2 = a2*yy; */
        w2 = a2 * yy;

        /* 'pooliir:43' yy = w1+xx; */
        yy = (w1 - rtu_coeffs[2] * yy) + xx;

        /* 'pooliir:44' w1 = b1*xx; */
        w1 = rtu_coeffs[4] * xx;

        /* 'pooliir:44' w2 = q-w2; */
        w2 = q - w2;

        /* 'pooliir:44' i = i + 1; */
    }

    /*  epilogue: drain pipe and write states */
    /* 'pooliir:48' r  = a1*yy; */
    /* 'pooliir:48' w1 = w1+w2; */
    /* 'pooliir:48' y(frameMinus1+1,cha) = yy; */
    localB->y[7] = yy;

    /* 'pooliir:49' q  = b2*xx; */
    /* 'pooliir:49' w1 = w1-r; */
    rtd_states_b[0] = (w1 + w2) - rtu_coeffs[2] * yy;

    /* 'pooliir:50' w2 = a2*yy; */
    /* 'pooliir:50' states(stateIdx) = w1; */
    /* 'pooliir:50' stateIdx = stateIdx+1; */
    /* 'pooliir:51' w2 = q-w2; */
    rtd_states_b[1] = rtu_coeffs[3] * xx - rtu_coeffs[1] * yy;

    /* 'pooliir:51' states(stateIdx) = w2; */
    /* 'pooliir:51' stateIdx = stateIdx+1; */
    stateIdx = 3.0;

    /*  NOTE: asm implementation needs to exit here if it's only */
    /*  one stage, NOTE: all subsequent stages work in-place */
    /* 'pooliir:55' for st = 2:numStages(cha) */
    for (st = 2U; st <= rtu_numStages; st++)
    {
        real_T a2_tmp;
        real_T stateIdx_0;
        real32_T w1_tmp;

        /*  prologue: get coefficients, states and input vector,  */
        /*  and perform some computations */
        /* 'pooliir:58' w1 = states(stateIdx); */
        w1 = rtd_states_b[(int32_T)stateIdx - 1];

        /* 'pooliir:58' stateIdx = stateIdx+1; */
        stateIdx_0 = stateIdx + 1.0;

        /* 'pooliir:59' a2 = coeffs(coeffIdx); */
        a2_tmp = ((real_T)st - 2.0) * 4.0 + 6.0;
        a2 = rtu_coeffs[(int32_T)a2_tmp - 1];

        /* 'pooliir:59' coeffIdx = coeffIdx+1; */
        /* 'pooliir:60' w2 = states(stateIdx); */
        w2 = rtd_states_b[(int32_T)(stateIdx + 1.0) - 1];

        /* 'pooliir:60' stateIdx = stateIdx-1; */
        stateIdx = (stateIdx + 1.0) - 1.0;

        /* 'pooliir:61' a1 = coeffs(coeffIdx); */
        gain = rtu_coeffs[(int32_T)(a2_tmp + 1.0) - 1];

        /* 'pooliir:61' coeffIdx = coeffIdx+1; */
        /* 'pooliir:62' xx = y(1,cha); */
        xx = localB->y[0];

        /* 'pooliir:62' b2 = coeffs(coeffIdx); */
        /* 'pooliir:62' coeffIdx = coeffIdx+1; */
        /* 'pooliir:63' yy = w1+xx; */
        yy = w1 + localB->y[0];

        /* 'pooliir:63' b1 = coeffs(coeffIdx); */
        /* 'pooliir:63' coeffIdx = coeffIdx+1; */
        /* 'pooliir:64' w1 = b1*xx; */
        w1_tmp = rtu_coeffs[(int32_T)(((a2_tmp + 1.0) + 1.0) + 1.0) - 1];
        w1 = w1_tmp * localB->y[0];

        /*  main loop: 4 ops/sample */
        /* 'pooliir:67' i = 1; */
        /* 'pooliir:68' while i <= frameMinus1 */
        for (i = 0; i < 7; i++)
        {
            /* 'pooliir:69' r  = a1*yy; */
            /* 'pooliir:69' w1 = w1+w2; */
            w1 += w2;

            /* 'pooliir:69' y(i,cha) = yy; */
            localB->y[i] = yy;

            /* 'pooliir:70' q  = b2*xx; */
            q = rtu_coeffs[(int32_T)((a2_tmp + 1.0) + 1.0) - 1] * xx;

            /* 'pooliir:70' w1 = w1-r ; */
            /* 'pooliir:70' xx = y(i+1,cha); */
            xx = localB->y[i + 1];

            /* 'pooliir:71' w2 = a2*yy; */
            w2 = a2 * yy;

            /* 'pooliir:71' yy = w1+xx; */
            yy = (w1 - gain * yy) + xx;

            /* 'pooliir:72' w1 = b1*xx; */
            w1 = w1_tmp * xx;

            /* 'pooliir:72' w2 = q-w2; */
            w2 = q - w2;

            /* 'pooliir:72' i = i + 1; */
        }

        /*  epilogue: drain pipe and write states */
        /* 'pooliir:76' r  = a1*yy; */
        /* 'pooliir:76' w1 = w1+w2; */
        /* 'pooliir:76' y(frameMinus1+1,cha) = yy; */
        localB->y[7] = yy;

        /* 'pooliir:77' q  = b2*xx; */
        /* 'pooliir:77' w1 = w1-r; */
        rtd_states_b[(int32_T)(stateIdx_0 - 1.0) - 1] = (w1 + w2) - gain * yy;

        /* 'pooliir:78' w2 = a2*yy; */
        /* 'pooliir:78' states(stateIdx) = w1; */
        /* 'pooliir:78' stateIdx = stateIdx+1; */
        /* 'pooliir:79' w2 = q-w2; */
        rtd_states_b[(int32_T)(stateIdx + 1.0) - 1] = rtu_coeffs[(int32_T)
            ((a2_tmp + 1.0) + 1.0) - 1] * xx - a2 * yy;

        /* 'pooliir:79' states(stateIdx) = w2; */
        /* 'pooliir:79' stateIdx = stateIdx+1; */
        stateIdx = (stateIdx + 1.0) + 1.0;
    }
}

/* Output and update for atomic system: '<S1574>/process' */
void Model_Target_process_p(const boolean_T *rtd_Premix_Freeze_CS, real32_T
    rtd_Premix_currentGain_CS[20], int32_T rtd_Premix_frameCount_CS[20], const
    real32_T rtd_Premix_rampCoeff_CS[20], const real32_T
    rtd_Premix_targetGain_CS[20])
{
    int32_T i;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/process': '<S1581>:1' */
    /* '<S1581>:1:10' for i = 1:numel(Premix_currentGain_CS) */
    for (i = 0; i < 20; i++)
    {
        /* '<S1581>:1:11' if (Premix_Freeze_CS(1) == false) */
        if (!*rtd_Premix_Freeze_CS)
        {
            /* '<S1581>:1:12' if (Premix_frameCount_CS(i) == 0) */
            if (rtd_Premix_frameCount_CS[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1581>:1:14' Premix_currentGain_CS(i) = Premix_targetGain_CS(i); */
                rtd_Premix_currentGain_CS[i] = rtd_Premix_targetGain_CS[i];
            }
            else
            {
                /* '<S1581>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1581>:1:17' Premix_currentGain_CS(i) = Premix_currentGain_CS(i)*Premix_rampCoeff_CS(i); */
                rtd_Premix_currentGain_CS[i] *= rtd_Premix_rampCoeff_CS[i];

                /* '<S1581>:1:18' Premix_frameCount_CS(i) = Premix_frameCount_CS(i) - 1; */
                rtd_Premix_frameCount_CS[i]--;
            }
        }
    }
}

/* Output and update for atomic system: '<S1586>/process' */
void Model_Target_process_in(const boolean_T *rtd_Premix_Freeze_Left, real32_T
    rtd_Premix_currentGain_Left[77], int32_T rtd_Premix_frameCount_Left[77],
    const real32_T rtd_Premix_rampCoeff_Left[77], const real32_T
    rtd_Premix_targetGain_Left[77])
{
    int32_T i;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Ramper/process': '<S1593>:1' */
    /* '<S1593>:1:10' for i = 1:numel(Premix_currentGain_Left) */
    for (i = 0; i < 77; i++)
    {
        /* '<S1593>:1:11' if (Premix_Freeze_Left(1) == false) */
        if (!*rtd_Premix_Freeze_Left)
        {
            /* '<S1593>:1:12' if (Premix_frameCount_Left(i) == 0) */
            if (rtd_Premix_frameCount_Left[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1593>:1:14' Premix_currentGain_Left(i) = Premix_targetGain_Left(i); */
                rtd_Premix_currentGain_Left[i] = rtd_Premix_targetGain_Left[i];
            }
            else
            {
                /* '<S1593>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1593>:1:17' Premix_currentGain_Left(i) = Premix_currentGain_Left(i)*Premix_rampCoeff_Left(i); */
                rtd_Premix_currentGain_Left[i] *= rtd_Premix_rampCoeff_Left[i];

                /* '<S1593>:1:18' Premix_frameCount_Left(i) = Premix_frameCount_Left(i) - 1; */
                rtd_Premix_frameCount_Left[i]--;
            }
        }
    }
}

/* Output and update for atomic system: '<S1598>/process' */
void Model_Target_process_f(const boolean_T *rtd_Premix_Freeze_Right, real32_T
    rtd_Premix_currentGain_Right[77], int32_T rtd_Premix_frameCount_Right[77],
    const real32_T rtd_Premix_rampCoeff_Right[77], const real32_T
    rtd_Premix_targetGain_Right[77])
{
    int32_T i;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Ramper/process': '<S1605>:1' */
    /* '<S1605>:1:10' for i = 1:numel(Premix_currentGain_Right) */
    for (i = 0; i < 77; i++)
    {
        /* '<S1605>:1:11' if (Premix_Freeze_Right(1) == false) */
        if (!*rtd_Premix_Freeze_Right)
        {
            /* '<S1605>:1:12' if (Premix_frameCount_Right(i) == 0) */
            if (rtd_Premix_frameCount_Right[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1605>:1:14' Premix_currentGain_Right(i) = Premix_targetGain_Right(i); */
                rtd_Premix_currentGain_Right[i] = rtd_Premix_targetGain_Right[i];
            }
            else
            {
                /* '<S1605>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1605>:1:17' Premix_currentGain_Right(i) = Premix_currentGain_Right(i)*Premix_rampCoeff_Right(i); */
                rtd_Premix_currentGain_Right[i] *= rtd_Premix_rampCoeff_Right[i];

                /* '<S1605>:1:18' Premix_frameCount_Right(i) = Premix_frameCount_Right(i) - 1; */
                rtd_Premix_frameCount_Right[i]--;
            }
        }
    }
}

/* Output and update for function-call system: '<S1586>/control' */
void Model_Target_control_p(const real32_T rtu_target_gains_linear[77], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_Premix_Freeze_Left,
    real32_T rtd_Premix_currentGain_Left[77], int32_T
    rtd_Premix_frameCount_Left[77], real32_T rtd_Premix_rampCoeff_Left[77],
    real32_T rtd_Premix_targetGain_Left[77])
{
    int32_T k;
    real32_T currentgain[77];
    real32_T diff[77];

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Ramper/control': '<S1592>:1' */
    /* '<S1592>:1:10' dim_rgain = size(Premix_currentGain_Left); */
    /* '<S1592>:1:11' rgain_SILENT_GAIN_mat = (MedusaPremixConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1592>:1:15' Premix_Freeze_Left(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1592>:1:24' currentgain = max(Premix_currentGain_Left, rgain_SILENT_GAIN_mat); */
    /* '<S1592>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1592>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 77; k++)
    {
        currentgain[k] = fmaxf(rtd_Premix_currentGain_Left[k], 1.1920929E-7F);
        rtd_Premix_rampCoeff_Left[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1592>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1592>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1592>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1592>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1592>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 77; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_Premix_rampCoeff_Left[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1592>:1:43' quantum_ms = 1000 * (MedusaPremixConfig.frame_size) / (MedusaPremixConfig.sample_rate_in_hertz); */
    /* '<S1592>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1592>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1592>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1592>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1592>:1:63' Premix_frameCount_Left  = int32(numFrames); */
    /* '<S1592>:1:64' Premix_rampCoeff_Left   = single(RampCoef); */
    /* '<S1592>:1:65' Premix_targetGain_Left  = target_gains_linear; */
    /* '<S1592>:1:66' Premix_currentGain_Left = currentgain; */
    for (k = 0; k < 77; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_Premix_rampCoeff_Left[k] = qhmath_div_f(rtd_Premix_rampCoeff_Left[k],
            currentgain_0);
        rtd_Premix_rampCoeff_Left[k] = qhmath_log_f(rtd_Premix_rampCoeff_Left[k]);
        rtd_Premix_rampCoeff_Left[k] = qhmath_div_f(rtd_Premix_rampCoeff_Left[k],
            numFrames);
        rtd_Premix_rampCoeff_Left[k] = qhmath_exp_f(rtd_Premix_rampCoeff_Left[k]);
        rtd_Premix_frameCount_Left[k] = (int32_T)roundf(numFrames);
        rtd_Premix_targetGain_Left[k] = rtu_target_gains_linear[k];
        rtd_Premix_currentGain_Left[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1592>:1:69' Premix_Freeze_Left(1) = false; */
    *rtd_Premix_Freeze_Left = false;
}

/* Output and update for function-call system: '<S1574>/control' */
void Model_Target_control_l(const real32_T rtu_target_gains_linear[20], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_Premix_Freeze_CS,
    real32_T rtd_Premix_currentGain_CS[20], int32_T rtd_Premix_frameCount_CS[20],
    real32_T rtd_Premix_rampCoeff_CS[20], real32_T rtd_Premix_targetGain_CS[20])
{
    int32_T k;
    real32_T currentgain[20];
    real32_T diff[20];

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/control': '<S1580>:1' */
    /* '<S1580>:1:10' dim_rgain = size(Premix_currentGain_CS); */
    /* '<S1580>:1:11' rgain_SILENT_GAIN_mat = (MedusaPremixConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1580>:1:15' Premix_Freeze_CS(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1580>:1:24' currentgain = max(Premix_currentGain_CS, rgain_SILENT_GAIN_mat); */
    /* '<S1580>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1580>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 20; k++)
    {
        currentgain[k] = fmaxf(rtd_Premix_currentGain_CS[k], 1.1920929E-7F);
        rtd_Premix_rampCoeff_CS[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1580>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1580>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1580>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1580>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1580>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 20; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_Premix_rampCoeff_CS[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1580>:1:43' quantum_ms = 1000 * (MedusaPremixConfig.frame_size) / (MedusaPremixConfig.sample_rate_in_hertz); */
    /* '<S1580>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1580>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1580>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1580>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1580>:1:63' Premix_frameCount_CS  = int32(numFrames); */
    /* '<S1580>:1:64' Premix_rampCoeff_CS   = single(RampCoef); */
    /* '<S1580>:1:65' Premix_targetGain_CS  = target_gains_linear; */
    /* '<S1580>:1:66' Premix_currentGain_CS = currentgain; */
    for (k = 0; k < 20; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_Premix_rampCoeff_CS[k] = qhmath_div_f(rtd_Premix_rampCoeff_CS[k],
            currentgain_0);
        rtd_Premix_rampCoeff_CS[k] = qhmath_log_f(rtd_Premix_rampCoeff_CS[k]);
        rtd_Premix_rampCoeff_CS[k] = qhmath_div_f(rtd_Premix_rampCoeff_CS[k],
            numFrames);
        rtd_Premix_rampCoeff_CS[k] = qhmath_exp_f(rtd_Premix_rampCoeff_CS[k]);
        rtd_Premix_frameCount_CS[k] = (int32_T)roundf(numFrames);
        rtd_Premix_targetGain_CS[k] = rtu_target_gains_linear[k];
        rtd_Premix_currentGain_CS[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1580>:1:69' Premix_Freeze_CS(1) = false; */
    *rtd_Premix_Freeze_CS = false;
}

/* Output and update for function-call system: '<S1598>/control' */
void Model_Target_control_c(const real32_T rtu_target_gains_linear[77], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_Premix_Freeze_Right,
    real32_T rtd_Premix_currentGain_Right[77], int32_T
    rtd_Premix_frameCount_Right[77], real32_T rtd_Premix_rampCoeff_Right[77],
    real32_T rtd_Premix_targetGain_Right[77])
{
    int32_T k;
    real32_T currentgain[77];
    real32_T diff[77];

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Ramper/control': '<S1604>:1' */
    /* '<S1604>:1:10' dim_rgain = size(Premix_currentGain_Right); */
    /* '<S1604>:1:11' rgain_SILENT_GAIN_mat = (MedusaPremixConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1604>:1:15' Premix_Freeze_Right(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1604>:1:24' currentgain = max(Premix_currentGain_Right, rgain_SILENT_GAIN_mat); */
    /* '<S1604>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1604>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 77; k++)
    {
        currentgain[k] = fmaxf(rtd_Premix_currentGain_Right[k], 1.1920929E-7F);
        rtd_Premix_rampCoeff_Right[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1604>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1604>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1604>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1604>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1604>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 77; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_Premix_rampCoeff_Right[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1604>:1:43' quantum_ms = 1000 * (MedusaPremixConfig.frame_size) / (MedusaPremixConfig.sample_rate_in_hertz); */
    /* '<S1604>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1604>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1604>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1604>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1604>:1:63' Premix_frameCount_Right  = int32(numFrames); */
    /* '<S1604>:1:64' Premix_rampCoeff_Right   = single(RampCoef); */
    /* '<S1604>:1:65' Premix_targetGain_Right  = target_gains_linear; */
    /* '<S1604>:1:66' Premix_currentGain_Right = currentgain; */
    for (k = 0; k < 77; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_Premix_rampCoeff_Right[k] = qhmath_div_f
            (rtd_Premix_rampCoeff_Right[k], currentgain_0);
        rtd_Premix_rampCoeff_Right[k] = qhmath_log_f
            (rtd_Premix_rampCoeff_Right[k]);
        rtd_Premix_rampCoeff_Right[k] = qhmath_div_f
            (rtd_Premix_rampCoeff_Right[k], numFrames);
        rtd_Premix_rampCoeff_Right[k] = qhmath_exp_f
            (rtd_Premix_rampCoeff_Right[k]);
        rtd_Premix_frameCount_Right[k] = (int32_T)roundf(numFrames);
        rtd_Premix_targetGain_Right[k] = rtu_target_gains_linear[k];
        rtd_Premix_currentGain_Right[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1604>:1:69' Premix_Freeze_Right(1) = false; */
    *rtd_Premix_Freeze_Right = false;
}

/* Output and update for function-call system: '<S1587>/Target Gain Computation' */
void Model_Target_TargetGainComputation(const real32_T rtu_minGain_Left[77],
    const real32_T rtu_detentGain_Left[77], const real32_T rtu_maxGain_Left[77],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_Left[77])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Surround Level Control/Target Gain Computation': '<S1595>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1595>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1595>:1:20' targetGain = MedusaPremixGainComputation(minGain_Left, detentGain_Left, maxGain_Left, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_SLCGain_Left[0], &rtu_minGain_Left[0], 77U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_SLCGain_Left[0], &rtu_detentGain_Left[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_SLCGain_Left[0], &rtu_maxGain_Left[0], 77U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 77; i++)
                {
                    rtd_Premix_SLCGain_Left[i] = (rtu_maxGain_Left[i] -
                        rtu_minGain_Left[i]) * position + rtu_minGain_Left[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 77; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_Left[i],
                        1.1920929E-7F));
                    rtd_Premix_SLCGain_Left[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Left[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1595>:1:22' Premix_SLCGain_Left = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1575>/Target Gain Computation' */
void Model_Target_TargetGainComputation_b(const real32_T rtu_minGain_CS[20],
    const real32_T rtu_detentGain_CS[20], const real32_T rtu_maxGain_CS[20],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_CS[20])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Surround Level Control/Target Gain Computation': '<S1583>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1583>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1583>:1:20' targetGain = MedusaPremixGainComputation(minGain_CS, detentGain_CS, maxGain_CS, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_SLCGain_CS[0], &rtu_minGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_SLCGain_CS[0], &rtu_detentGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_SLCGain_CS[0], &rtu_maxGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 20; i++)
                {
                    rtd_Premix_SLCGain_CS[i] = (rtu_maxGain_CS[i] -
                        rtu_minGain_CS[i]) * position + rtu_minGain_CS[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 20; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_CS[i],
                        1.1920929E-7F));
                    rtd_Premix_SLCGain_CS[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_CS[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1583>:1:22' Premix_SLCGain_CS = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1599>/Target Gain Computation' */
void Model_Target_TargetGainComputation_e(const real32_T rtu_minGain_Right[77],
    const real32_T rtu_detentGain_Right[77], const real32_T rtu_maxGain_Right[77],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_Right[77])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Surround Level Control/Target Gain Computation': '<S1607>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1607>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1607>:1:20' targetGain = MedusaPremixGainComputation(minGain_Right, detentGain_Right, maxGain_Right, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_SLCGain_Right[0], &rtu_minGain_Right[0], 77U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_SLCGain_Right[0], &rtu_detentGain_Right[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_SLCGain_Right[0], &rtu_maxGain_Right[0], 77U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 77; i++)
                {
                    rtd_Premix_SLCGain_Right[i] = (rtu_maxGain_Right[i] -
                        rtu_minGain_Right[i]) * position + rtu_minGain_Right[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 77; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf
                        (rtu_minGain_Right[i], 1.1920929E-7F));
                    rtd_Premix_SLCGain_Right[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Right[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1607>:1:22' Premix_SLCGain_Right = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1496>/Target Gain Computation' */
void Model_Target_TargetGainComputation_ex(const real32_T rtu_minGain_Left[30],
    const real32_T rtu_detentGain_Left[30], const real32_T rtu_maxGain_Left[30],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_Left[30])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Surround Level Control/Target Gain Computation': '<S1504>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1504>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1504>:1:20' targetGain = MedusaPremixGainComputation(minGain_Left, detentGain_Left, maxGain_Left, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_FRM_SLCGain_Left[0], &rtu_minGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_FRM_SLCGain_Left[0], &rtu_detentGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_FRM_SLCGain_Left[0], &rtu_maxGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 30; i++)
                {
                    rtd_FRM_SLCGain_Left[i] = (rtu_maxGain_Left[i] -
                        rtu_minGain_Left[i]) * position + rtu_minGain_Left[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 30; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_Left[i],
                        1.1920929E-7F));
                    rtd_FRM_SLCGain_Left[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_Left[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1504>:1:22' FRM_SLCGain_Left = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1484>/Target Gain Computation' */
void Model_Target_TargetGainComputation_l(const real32_T rtu_minGain_CS[12],
    const real32_T rtu_detentGain_CS[12], const real32_T rtu_maxGain_CS[12],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_CS[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Surround Level Control/Target Gain Computation': '<S1492>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1492>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1492>:1:20' targetGain = MedusaPremixGainComputation(minGain_CS, detentGain_CS, maxGain_CS, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_SLCGain_CS[i] = rtu_minGain_CS[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_SLCGain_CS[i] = rtu_detentGain_CS[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_SLCGain_CS[i] = rtu_maxGain_CS[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_FRM_SLCGain_CS[i] = (rtu_maxGain_CS[i] -
                        rtu_minGain_CS[i]) * position + rtu_minGain_CS[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_CS[i],
                        1.1920929E-7F));
                    rtd_FRM_SLCGain_CS[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_CS[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1492>:1:22' FRM_SLCGain_CS = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1508>/Target Gain Computation' */
void Model_Target_TargetGainComputation_j(const real32_T rtu_minGain_Right[30],
    const real32_T rtu_detentGain_Right[30], const real32_T rtu_maxGain_Right[30],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_Right[30])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Surround Level Control/Target Gain Computation': '<S1516>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1516>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1516>:1:20' targetGain = MedusaPremixGainComputation(minGain_Right, detentGain_Right, maxGain_Right, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_FRM_SLCGain_Right[0], &rtu_minGain_Right[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_FRM_SLCGain_Right[0], &rtu_detentGain_Right[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_FRM_SLCGain_Right[0], &rtu_maxGain_Right[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 30; i++)
                {
                    rtd_FRM_SLCGain_Right[i] = (rtu_maxGain_Right[i] -
                        rtu_minGain_Right[i]) * position + rtu_minGain_Right[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 30; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf
                        (rtu_minGain_Right[i], 1.1920929E-7F));
                    rtd_FRM_SLCGain_Right[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_Right[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1516>:1:22' FRM_SLCGain_Right = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1657>/Target Gain Computation' */
void Model_Target_TargetGainComputation_k(const real32_T rtu_minGain[12], const
    real32_T rtu_detentGain[12], const real32_T rtu_maxGain[12], real32_T
    rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_VLSDrv_SLCGain[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Surround Level Control/Target Gain Computation': '<S1663>:1' */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1663>:1:7' targetGain = MedusaPremixGainComputation(minGain, detentGain, maxGain, interpolation_method, surr_level, configStruct); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_SLCGain[i] = rtu_minGain[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_SLCGain[i] = rtu_detentGain[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_SLCGain[i] = rtu_maxGain[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_VLSDrv_SLCGain[i] = (rtu_maxGain[i] - rtu_minGain[i]) *
                        position + rtu_minGain[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain[i],
                        1.1920929E-7F));
                    rtd_VLSDrv_SLCGain[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1663>:1:9' VLSDrv_SLCGain = targetGain; */
}

/* Output and update for function-call system: '<S1682>/Target Gain Computation' */
void Model_Target_TargetGainComputation_g(const real32_T rtu_minGain[12], const
    real32_T rtu_detentGain[12], const real32_T rtu_maxGain[12], real32_T
    rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_VLSPax_SLCGain[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Surround Level Control/Target Gain Computation': '<S1688>:1' */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1688>:1:7' targetGain = MedusaPremixGainComputation(minGain, detentGain, maxGain, interpolation_method, surr_level, configStruct); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_SLCGain[i] = rtu_minGain[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_SLCGain[i] = rtu_detentGain[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_SLCGain[i] = rtu_maxGain[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_VLSPax_SLCGain[i] = (rtu_maxGain[i] - rtu_minGain[i]) *
                        position + rtu_minGain[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain[i],
                        1.1920929E-7F));
                    rtd_VLSPax_SLCGain[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1688>:1:9' VLSPax_SLCGain = targetGain; */
}

/* Output and update for function-call system: '<S1626>/REQ' */
void HandleReqPreAmpMedusaSurroundLevelControlIndex(void)
{
    /* MATLAB Function: '<S1587>/Target Gain Computation' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1633>:1' */
    /* '<S1633>:1:3' go(); */
    Model_Target_TargetGainComputation
        (&(Model_Target_PreAmp0.MedusaPremixMinLevel_Left[0]),
         &(Model_Target_PreAmp0.MedusaPremixDetentLevel_Left[0]),
         &(Model_Target_PreAmp0.MedusaPremixMaxLevel_Left[0]),
         Model_Target_PreAmp0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Left);

    /* MATLAB Function: '<S1575>/Target Gain Computation' */
    Model_Target_TargetGainComputation_b
        (&(Model_Target_PreAmp0.MedusaPremixMinLevel_CS[0]),
         &(Model_Target_PreAmp0.MedusaPremixDetentLevel_CS[0]),
         &(Model_Target_PreAmp0.MedusaPremixMaxLevel_CS[0]),
         Model_Target_PreAmp0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_CS);

    /* MATLAB Function: '<S1599>/Target Gain Computation' */
    Model_Target_TargetGainComputation_e
        (&(Model_Target_PreAmp0.MedusaPremixMinLevel_Right[0]),
         &(Model_Target_PreAmp0.MedusaPremixDetentLevel_Right[0]),
         &(Model_Target_PreAmp0.MedusaPremixMaxLevel_Right[0]),
         Model_Target_PreAmp0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Right);

    /* MATLAB Function: '<S1496>/Target Gain Computation' */
    Model_Target_TargetGainComputation_ex
        (&(Model_Target_PreAmp0.MedusaFullRateMixerMinLevel_Left[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerDetentLevel_Left[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerMaxLevel_Left[0]),
         Model_Target_PreAmp0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Left);

    /* MATLAB Function: '<S1484>/Target Gain Computation' */
    Model_Target_TargetGainComputation_l
        (&(Model_Target_PreAmp0.MedusaFullRateMixerMinLevel_CS[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerDetentLevel_CS[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerMaxLevel_CS[0]),
         Model_Target_PreAmp0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_CS);

    /* MATLAB Function: '<S1508>/Target Gain Computation' */
    Model_Target_TargetGainComputation_j
        (&(Model_Target_PreAmp0.MedusaFullRateMixerMinLevel_Right[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerDetentLevel_Right[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerMaxLevel_Right[0]),
         Model_Target_PreAmp0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Right);

    /* MATLAB Function: '<S1657>/Target Gain Computation' */
    Model_Target_TargetGainComputation_k
        (&(Model_Target_PreAmp0.MedusaVLSDrvGainsMinLevel[0]),
         &(Model_Target_PreAmp0.MedusaVLSDrvGainsDetentLevel[0]),
         &(Model_Target_PreAmp0.MedusaVLSDrvGainsMaxLevel[0]),
         Model_Target_PreAmp0.MedusaVLSDrvGainsInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_SLCGain);

    /* MATLAB Function: '<S1682>/Target Gain Computation' */
    Model_Target_TargetGainComputation_g
        (&(Model_Target_PreAmp0.MedusaVLSPaxGainsMinLevel[0]),
         &(Model_Target_PreAmp0.MedusaVLSPaxGainsDetentLevel[0]),
         &(Model_Target_PreAmp0.MedusaVLSPaxGainsMaxLevel[0]),
         Model_Target_PreAmp0.MedusaVLSPaxGainsInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.VLSPax_SLCGain);

    /* MATLAB Function: '<S1624>/MATLAB Function' */
    /* MATLAB Function 'Surround Level Control Generic/Detect SLC REQ/MATLAB Function': '<S1628>:1' */
    /*  Increment the trigger count everytime the SLC is triggered. The changes */
    /*  in this count are tracked to update a boolean indicator of whether the */
    /*  SLC trigger. */
    /* '<S1628>:1:9' TriggerCount = TriggerCount+1; */
    Model_Target_Medusa5H1Part3_DW.TriggerCount++;
}

/* Output and update for function-call system: '<S1587>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL(const real32_T rtu_minGain_Left[77],
    const real32_T rtu_detentGain_Left[77], const real32_T rtu_maxGain_Left[77],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_Left[77], real32_T rtd_Premix_currentGain_Left[77],
    int32_T rtd_Premix_frameCount_Left[77], real32_T rtd_Premix_targetGain_Left
    [77])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Surround Level Control/Initialization and RMDL': '<S1594>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1594>:1:9' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1594>:1:23' gain = MedusaPremixGainComputation(minGain_Left, detentGain_Left, maxGain_Left, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_currentGain_Left[0], &rtu_minGain_Left[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_currentGain_Left[0], &rtu_detentGain_Left[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_currentGain_Left[0], &rtu_maxGain_Left[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 77; i++)
                {
                    rtd_Premix_currentGain_Left[i] = (rtu_maxGain_Left[i] -
                        rtu_minGain_Left[i]) * position + rtu_minGain_Left[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 77; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_Left[i],
                        1.1920929E-7F));
                    rtd_Premix_currentGain_Left[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Left[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1594>:1:27' Premix_currentGain_Left = gain; */
    /* '<S1594>:1:28' Premix_targetGain_Left = gain; */
    /* '<S1594>:1:29' Premix_SLCGain_Left = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1594>:1:32' Premix_frameCount_Left = zeros(size(Premix_currentGain_Left), 'int32'); */
    for (i = 0; i < 77; i++)
    {
        rtd_Premix_targetGain_Left[i] = rtd_Premix_currentGain_Left[i];
        rtd_Premix_SLCGain_Left[i] = rtd_Premix_currentGain_Left[i];
        rtd_Premix_frameCount_Left[i] = 0;
    }
}

/* Output and update for function-call system: '<S1575>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_f(const real32_T rtu_minGain_CS[20],
    const real32_T rtu_detentGain_CS[20], const real32_T rtu_maxGain_CS[20],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_CS[20], real32_T rtd_Premix_currentGain_CS[20], int32_T
    rtd_Premix_frameCount_CS[20], real32_T rtd_Premix_targetGain_CS[20])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Surround Level Control/Initialization and RMDL': '<S1582>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1582>:1:9' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1582>:1:23' gain = MedusaPremixGainComputation(minGain_CS, detentGain_CS, maxGain_CS, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_currentGain_CS[0], &rtu_minGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_currentGain_CS[0], &rtu_detentGain_CS[0], 20U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_currentGain_CS[0], &rtu_maxGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 20; i++)
                {
                    rtd_Premix_currentGain_CS[i] = (rtu_maxGain_CS[i] -
                        rtu_minGain_CS[i]) * position + rtu_minGain_CS[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 20; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_CS[i],
                        1.1920929E-7F));
                    rtd_Premix_currentGain_CS[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_CS[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1582>:1:27' Premix_currentGain_CS = gain; */
    /* '<S1582>:1:28' Premix_targetGain_CS = gain; */
    /* '<S1582>:1:29' Premix_SLCGain_CS = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1582>:1:32' Premix_frameCount_CS = zeros(size(Premix_currentGain_CS), 'int32'); */
    for (i = 0; i < 20; i++)
    {
        rtd_Premix_targetGain_CS[i] = rtd_Premix_currentGain_CS[i];
        rtd_Premix_SLCGain_CS[i] = rtd_Premix_currentGain_CS[i];
        rtd_Premix_frameCount_CS[i] = 0;
    }
}

/* Output and update for function-call system: '<S1599>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_n(const real32_T rtu_minGain_Right[77],
    const real32_T rtu_detentGain_Right[77], const real32_T rtu_maxGain_Right[77],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_Right[77], real32_T rtd_Premix_currentGain_Right[77],
    int32_T rtd_Premix_frameCount_Right[77], real32_T
    rtd_Premix_targetGain_Right[77])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Surround Level Control/Initialization and RMDL': '<S1606>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1606>:1:9' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1606>:1:23' gain = MedusaPremixGainComputation(minGain_Right, detentGain_Right, maxGain_Right, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_currentGain_Right[0], &rtu_minGain_Right[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_currentGain_Right[0], &rtu_detentGain_Right[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_currentGain_Right[0], &rtu_maxGain_Right[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 77; i++)
                {
                    rtd_Premix_currentGain_Right[i] = (rtu_maxGain_Right[i] -
                        rtu_minGain_Right[i]) * position + rtu_minGain_Right[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 77; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf
                        (rtu_minGain_Right[i], 1.1920929E-7F));
                    rtd_Premix_currentGain_Right[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Right[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1606>:1:27' Premix_currentGain_Right = gain; */
    /* '<S1606>:1:28' Premix_targetGain_Right = gain; */
    /* '<S1606>:1:29' Premix_SLCGain_Right = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1606>:1:32' Premix_frameCount_Right = zeros(size(Premix_currentGain_Right), 'int32'); */
    for (i = 0; i < 77; i++)
    {
        rtd_Premix_targetGain_Right[i] = rtd_Premix_currentGain_Right[i];
        rtd_Premix_SLCGain_Right[i] = rtd_Premix_currentGain_Right[i];
        rtd_Premix_frameCount_Right[i] = 0;
    }
}

/* Output and update for function-call system: '<S1496>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_o(const real32_T rtu_minGain_Left[30],
    const real32_T rtu_detentGain_Left[30], const real32_T rtu_maxGain_Left[30],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_Left[30], real32_T rtd_FRM_currentGain_Left[30], int32_T
    rtd_FRM_frameCount_Left[30], real32_T rtd_FRM_targetGain_Left[30])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Surround Level Control/Initialization and RMDL': '<S1503>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1503>:1:9' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1503>:1:23' gain = MedusaPremixGainComputation(minGain_Left, detentGain_Left, maxGain_Left, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_FRM_currentGain_Left[0], &rtu_minGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_FRM_currentGain_Left[0], &rtu_detentGain_Left[0], 30U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_FRM_currentGain_Left[0], &rtu_maxGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 30; i++)
                {
                    rtd_FRM_currentGain_Left[i] = (rtu_maxGain_Left[i] -
                        rtu_minGain_Left[i]) * position + rtu_minGain_Left[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 30; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_Left[i],
                        1.1920929E-7F));
                    rtd_FRM_currentGain_Left[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Left[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1503>:1:27' FRM_currentGain_Left = gain; */
    /* '<S1503>:1:28' FRM_targetGain_Left = gain; */
    /* '<S1503>:1:29' FRM_SLCGain_Left = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1503>:1:32' FRM_frameCount_Left = zeros(size(FRM_currentGain_Left), 'int32'); */
    for (i = 0; i < 30; i++)
    {
        rtd_FRM_targetGain_Left[i] = rtd_FRM_currentGain_Left[i];
        rtd_FRM_SLCGain_Left[i] = rtd_FRM_currentGain_Left[i];
        rtd_FRM_frameCount_Left[i] = 0;
    }
}

/* Output and update for function-call system: '<S1484>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_k(const real32_T rtu_minGain_CS[12],
    const real32_T rtu_detentGain_CS[12], const real32_T rtu_maxGain_CS[12],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_CS[12], real32_T rtd_FRM_currentGain_CS[12], int32_T
    rtd_FRM_frameCount_CS[12], real32_T rtd_FRM_targetGain_CS[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Surround Level Control/Initialization and RMDL': '<S1491>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1491>:1:9' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1491>:1:23' gain = MedusaPremixGainComputation(minGain_CS, detentGain_CS, maxGain_CS, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_currentGain_CS[i] = rtu_minGain_CS[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_currentGain_CS[i] = rtu_detentGain_CS[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_currentGain_CS[i] = rtu_maxGain_CS[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_FRM_currentGain_CS[i] = (rtu_maxGain_CS[i] -
                        rtu_minGain_CS[i]) * position + rtu_minGain_CS[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_CS[i],
                        1.1920929E-7F));
                    rtd_FRM_currentGain_CS[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_CS[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1491>:1:27' FRM_currentGain_CS = gain; */
    /* '<S1491>:1:28' FRM_targetGain_CS = gain; */
    /* '<S1491>:1:29' FRM_SLCGain_CS = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1491>:1:32' FRM_frameCount_CS = zeros(size(FRM_currentGain_CS), 'int32'); */
    for (i = 0; i < 12; i++)
    {
        rtd_FRM_targetGain_CS[i] = rtd_FRM_currentGain_CS[i];
        rtd_FRM_SLCGain_CS[i] = rtd_FRM_currentGain_CS[i];
        rtd_FRM_frameCount_CS[i] = 0;
    }
}

/* Output and update for function-call system: '<S1508>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_ou(const real32_T rtu_minGain_Right[30],
    const real32_T rtu_detentGain_Right[30], const real32_T rtu_maxGain_Right[30],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_Right[30], real32_T rtd_FRM_currentGain_Right[30], int32_T
    rtd_FRM_frameCount_Right[30], real32_T rtd_FRM_targetGain_Right[30])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Surround Level Control/Initialization and RMDL': '<S1515>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1515>:1:9' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1515>:1:23' gain = MedusaPremixGainComputation(minGain_Right, detentGain_Right, maxGain_Right, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_FRM_currentGain_Right[0], &rtu_minGain_Right[0], 30U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_FRM_currentGain_Right[0], &rtu_detentGain_Right[0], 30U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_FRM_currentGain_Right[0], &rtu_maxGain_Right[0], 30U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 30; i++)
                {
                    rtd_FRM_currentGain_Right[i] = (rtu_maxGain_Right[i] -
                        rtu_minGain_Right[i]) * position + rtu_minGain_Right[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 30; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf
                        (rtu_minGain_Right[i], 1.1920929E-7F));
                    rtd_FRM_currentGain_Right[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Right[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1515>:1:27' FRM_currentGain_Right = gain; */
    /* '<S1515>:1:28' FRM_targetGain_Right = gain; */
    /* '<S1515>:1:29' FRM_SLCGain_Right = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1515>:1:32' FRM_frameCount_Right = zeros(size(FRM_currentGain_Right), 'int32'); */
    for (i = 0; i < 30; i++)
    {
        rtd_FRM_targetGain_Right[i] = rtd_FRM_currentGain_Right[i];
        rtd_FRM_SLCGain_Right[i] = rtd_FRM_currentGain_Right[i];
        rtd_FRM_frameCount_Right[i] = 0;
    }
}

/* Output and update for function-call system: '<S1657>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_o4(const real32_T rtu_minGain[12], const
    real32_T rtu_detentGain[12], const real32_T rtu_maxGain[12], real32_T
    rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_VLSDrv_SLCGain[12], real32_T rtd_VLSDrv_currentGain[12], int32_T
    rtd_VLSDrv_frameCount[12], real32_T rtd_VLSDrv_targetGain[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Surround Level Control/Initialization and RMDL': '<S1662>:1' */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1662>:1:10' gain = MedusaPremixGainComputation(minGain, detentGain, maxGain, interpolation_method, surr_level, configStruct); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_currentGain[i] = rtu_minGain[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_currentGain[i] = rtu_detentGain[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_currentGain[i] = rtu_maxGain[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_VLSDrv_currentGain[i] = (rtu_maxGain[i] - rtu_minGain[i])
                        * position + rtu_minGain[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain[i],
                        1.1920929E-7F));
                    rtd_VLSDrv_currentGain[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1662>:1:14' VLSDrv_currentGain = gain; */
    /* '<S1662>:1:15' VLSDrv_targetGain = gain; */
    /* '<S1662>:1:16' VLSDrv_SLCGain = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1662>:1:19' VLSDrv_frameCount = zeros(size(VLSDrv_currentGain), 'int32'); */
    for (i = 0; i < 12; i++)
    {
        rtd_VLSDrv_targetGain[i] = rtd_VLSDrv_currentGain[i];
        rtd_VLSDrv_SLCGain[i] = rtd_VLSDrv_currentGain[i];
        rtd_VLSDrv_frameCount[i] = 0;
    }
}

/* Output and update for function-call system: '<S1682>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_b(const real32_T rtu_minGain[12], const
    real32_T rtu_detentGain[12], const real32_T rtu_maxGain[12], real32_T
    rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_VLSPax_SLCGain[12], real32_T rtd_VLSPax_currentGain[12], int32_T
    rtd_VLSPax_frameCount[12], real32_T rtd_VLSPax_targetGain[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Surround Level Control/Initialization and RMDL': '<S1687>:1' */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1687>:1:10' gain = MedusaPremixGainComputation(minGain, detentGain, maxGain, interpolation_method, surr_level, configStruct); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_currentGain[i] = rtu_minGain[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_currentGain[i] = rtu_detentGain[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_currentGain[i] = rtu_maxGain[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_VLSPax_currentGain[i] = (rtu_maxGain[i] - rtu_minGain[i])
                        * position + rtu_minGain[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain[i],
                        1.1920929E-7F));
                    rtd_VLSPax_currentGain[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1687>:1:14' VLSPax_currentGain = gain; */
    /* '<S1687>:1:15' VLSPax_targetGain = gain; */
    /* '<S1687>:1:16' VLSPax_SLCGain = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1687>:1:19' VLSPax_frameCount = zeros(size(VLSPax_currentGain), 'int32'); */
    for (i = 0; i < 12; i++)
    {
        rtd_VLSPax_targetGain[i] = rtd_VLSPax_currentGain[i];
        rtd_VLSPax_SLCGain[i] = rtd_VLSPax_currentGain[i];
        rtd_VLSPax_frameCount[i] = 0;
    }
}

/* Output and update for function-call system: '<S1627>/REQ' */
void HandleReqPreAmpMedusaSurroundLevelControlReset(void)
{
    /* MATLAB Function: '<S1587>/Initialization and RMDL' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1639>:1' */
    /* '<S1639>:1:3' go(); */
    Model_Target_InitializationandRMDL
        (&(Model_Target_PreAmp0.MedusaPremixMinLevel_Left[0]),
         &(Model_Target_PreAmp0.MedusaPremixDetentLevel_Left[0]),
         &(Model_Target_PreAmp0.MedusaPremixMaxLevel_Left[0]),
         Model_Target_PreAmp0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Left,
         Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left,
         Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Left,
         Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left);

    /* MATLAB Function: '<S1575>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_f
        (&(Model_Target_PreAmp0.MedusaPremixMinLevel_CS[0]),
         &(Model_Target_PreAmp0.MedusaPremixDetentLevel_CS[0]),
         &(Model_Target_PreAmp0.MedusaPremixMaxLevel_CS[0]),
         Model_Target_PreAmp0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_CS,
         Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS,
         Model_Target_Medusa5H1Part3_DW.Premix_frameCount_CS,
         Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS);

    /* MATLAB Function: '<S1599>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_n
        (&(Model_Target_PreAmp0.MedusaPremixMinLevel_Right[0]),
         &(Model_Target_PreAmp0.MedusaPremixDetentLevel_Right[0]),
         &(Model_Target_PreAmp0.MedusaPremixMaxLevel_Right[0]),
         Model_Target_PreAmp0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Right,
         Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right,
         Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Right,
         Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right);

    /* MATLAB Function: '<S1496>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_o
        (&(Model_Target_PreAmp0.MedusaFullRateMixerMinLevel_Left[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerDetentLevel_Left[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerMaxLevel_Left[0]),
         Model_Target_PreAmp0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Left,
         Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left,
         Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Left,
         Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left);

    /* MATLAB Function: '<S1484>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_k
        (&(Model_Target_PreAmp0.MedusaFullRateMixerMinLevel_CS[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerDetentLevel_CS[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerMaxLevel_CS[0]),
         Model_Target_PreAmp0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_CS,
         Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS,
         Model_Target_Medusa5H1Part3_DW.FRM_frameCount_CS,
         Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS);

    /* MATLAB Function: '<S1508>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_ou
        (&(Model_Target_PreAmp0.MedusaFullRateMixerMinLevel_Right[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerDetentLevel_Right[0]),
         &(Model_Target_PreAmp0.MedusaFullRateMixerMaxLevel_Right[0]),
         Model_Target_PreAmp0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Right,
         Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right,
         Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Right,
         Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right);

    /* MATLAB Function: '<S1657>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_o4
        (&(Model_Target_PreAmp0.MedusaVLSDrvGainsMinLevel[0]),
         &(Model_Target_PreAmp0.MedusaVLSDrvGainsDetentLevel[0]),
         &(Model_Target_PreAmp0.MedusaVLSDrvGainsMaxLevel[0]),
         Model_Target_PreAmp0.MedusaVLSDrvGainsInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_SLCGain,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_frameCount,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain);

    /* MATLAB Function: '<S1682>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_b
        (&(Model_Target_PreAmp0.MedusaVLSPaxGainsMinLevel[0]),
         &(Model_Target_PreAmp0.MedusaVLSPaxGainsDetentLevel[0]),
         &(Model_Target_PreAmp0.MedusaVLSPaxGainsMaxLevel[0]),
         Model_Target_PreAmp0.MedusaVLSPaxGainsInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.VLSPax_SLCGain,
         Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain,
         Model_Target_Medusa5H1Part3_DW.VLSPax_frameCount,
         Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain);
}

/*
 * Output and update for atomic system:
 *    '<S1644>/Fade_Trigger_Generation'
 *    '<S1669>/Fade_Trigger_Generation'
 */
void Model_Target_Fade_Trigger_Generation(real32_T rtu_gainDifference, const
    real32_T rtu_1[12], real32_T rtu_2, real32_T rtu_3, real32_T rtu_4, real32_T
    rtu_5, real32_T rtu_6, real32_T rtu_7,
    B_Fade_Trigger_Generation_Model_Target_T *localB)
{
    int32_T i;

    /*  #codegen */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Fade Inputs/Fade_Trigger_Generation': '<S1649>:1' */
    /* '<S1649>:1:3' fadeOn = false; */
    localB->fadeOn = false;

    /*  Generates function call triggers when incoming fade gain values change */
    /* '<S1649>:1:6' if(gainDifference > 0) */
    if (rtu_gainDifference > 0.0F)
    {
        /* Outputs for Function Call SubSystem: '<S1646>/Fader Downmix' */
        /* MATLAB Function: '<S1655>/MATLAB Function' */
        /* '<S1649>:1:7' fadeTrigger(); */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Fader Downmix/MATLAB Function': '<S1658>:1' */
        /* '<S1658>:1:4' if (forwardGain >= backwardGain) */
        if (rtu_2 >= rtu_5)
        {
            /* '<S1658>:1:5' downmix = (1 - min(backwardGain, forwardDownmixThreshold) / max(forwardDownmixThreshold, single(eps)))... */
            /* '<S1658>:1:6'         * forwardDownmixMax; */
            localB->downmix = (1.0F - qhmath_div_f(fminf(rtu_5, rtu_3), fmaxf
                                (rtu_3, 2.22044605E-16F))) * rtu_4;
        }
        else
        {
            /* '<S1658>:1:7' else */
            /* '<S1658>:1:8' downmix = (1 - min(forwardGain, backwardDownmixThreshold) / max(backwardDownmixThreshold, single(eps)))... */
            /* '<S1658>:1:9'         * backwardDownmixMax; */
            localB->downmix = (1.0F - qhmath_div_f(fminf(rtu_2, rtu_6), fmaxf
                                (rtu_6, 2.22044605E-16F))) * rtu_7;
        }

        /* End of MATLAB Function: '<S1655>/MATLAB Function' */
        for (i = 0; i < 12; i++)
        {
            /* Product: '<S1655>/Matrix Multiply' */
            localB->MatrixMultiply[i] = localB->downmix * rtu_1[i];
        }

        /* End of Outputs for SubSystem: '<S1646>/Fader Downmix' */
        /* '<S1649>:1:8' fadeOn = true; */
        localB->fadeOn = true;

        /*  Indicates that fade is triggered */
    }
}

/* Output and update for atomic system: '<S1656>/process' */
void Model_Target_process_c(const boolean_T *rtd_VLSDrv_Freeze, real32_T
    rtd_VLSDrv_currentGain[12], int32_T rtd_VLSDrv_frameCount[12], const
    real32_T rtd_VLSDrv_rampCoeff[12], const real32_T rtd_VLSDrv_targetGain[12])
{
    int32_T i;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Ramper/process': '<S1661>:1' */
    /* '<S1661>:1:10' for i = 1:numel(VLSDrv_currentGain) */
    for (i = 0; i < 12; i++)
    {
        /* '<S1661>:1:11' if (VLSDrv_Freeze(1) == false) */
        if (!*rtd_VLSDrv_Freeze)
        {
            /* '<S1661>:1:12' if (VLSDrv_frameCount(i) == 0) */
            if (rtd_VLSDrv_frameCount[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1661>:1:14' VLSDrv_currentGain(i) = VLSDrv_targetGain(i); */
                rtd_VLSDrv_currentGain[i] = rtd_VLSDrv_targetGain[i];
            }
            else
            {
                /* '<S1661>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1661>:1:17' VLSDrv_currentGain(i) = VLSDrv_currentGain(i)*VLSDrv_rampCoeff(i); */
                rtd_VLSDrv_currentGain[i] *= rtd_VLSDrv_rampCoeff[i];

                /* '<S1661>:1:18' VLSDrv_frameCount(i) = VLSDrv_frameCount(i) - 1; */
                rtd_VLSDrv_frameCount[i]--;
            }
        }
    }
}

/* Output and update for function-call system: '<S1656>/control' */
void Model_Target_control_as(const real32_T rtu_target_gains_linear[12],
    uint32_T rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_VLSDrv_Freeze,
    real32_T rtd_VLSDrv_currentGain[12], int32_T rtd_VLSDrv_frameCount[12],
    real32_T rtd_VLSDrv_rampCoeff[12], real32_T rtd_VLSDrv_targetGain[12])
{
    int32_T k;
    real32_T currentgain[12];
    real32_T diff[12];

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Ramper/control': '<S1660>:1' */
    /* '<S1660>:1:10' dim_rgain = size(VLSDrv_currentGain); */
    /* '<S1660>:1:11' rgain_SILENT_GAIN_mat = (configStruct.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1660>:1:15' VLSDrv_Freeze(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1660>:1:24' currentgain = max(VLSDrv_currentGain, rgain_SILENT_GAIN_mat); */
    /* '<S1660>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1660>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 12; k++)
    {
        currentgain[k] = fmaxf(rtd_VLSDrv_currentGain[k], 1.1920929E-7F);
        rtd_VLSDrv_rampCoeff[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1660>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1660>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1660>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1660>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1660>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 12; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_VLSDrv_rampCoeff[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1660>:1:43' quantum_ms = 1000 * (configStruct.frame_size) / (configStruct.sample_rate_in_hertz); */
    /* '<S1660>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1660>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1660>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1660>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1660>:1:63' VLSDrv_frameCount  = int32(numFrames); */
    /* '<S1660>:1:64' VLSDrv_rampCoeff   = single(RampCoef); */
    /* '<S1660>:1:65' VLSDrv_targetGain  = target_gains_linear; */
    /* '<S1660>:1:66' VLSDrv_currentGain = currentgain; */
    for (k = 0; k < 12; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_VLSDrv_rampCoeff[k] = qhmath_div_f(rtd_VLSDrv_rampCoeff[k],
            currentgain_0);
        rtd_VLSDrv_rampCoeff[k] = qhmath_log_f(rtd_VLSDrv_rampCoeff[k]);
        rtd_VLSDrv_rampCoeff[k] = qhmath_div_f(rtd_VLSDrv_rampCoeff[k],
            numFrames);
        rtd_VLSDrv_rampCoeff[k] = qhmath_exp_f(rtd_VLSDrv_rampCoeff[k]);
        rtd_VLSDrv_frameCount[k] = (int32_T)numFrames;
        rtd_VLSDrv_targetGain[k] = rtu_target_gains_linear[k];
        rtd_VLSDrv_currentGain[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1660>:1:69' VLSDrv_Freeze(1) = false; */
    *rtd_VLSDrv_Freeze = false;
}

/* Output and update for atomic system: '<S1681>/process' */
void Model_Target_process_e(const boolean_T *rtd_VLSPax_Freeze, real32_T
    rtd_VLSPax_currentGain[12], int32_T rtd_VLSPax_frameCount[12], const
    real32_T rtd_VLSPax_rampCoeff[12], const real32_T rtd_VLSPax_targetGain[12])
{
    int32_T i;

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Ramper/process': '<S1686>:1' */
    /* '<S1686>:1:10' for i = 1:numel(VLSPax_currentGain) */
    for (i = 0; i < 12; i++)
    {
        /* '<S1686>:1:11' if (VLSPax_Freeze(1) == false) */
        if (!*rtd_VLSPax_Freeze)
        {
            /* '<S1686>:1:12' if (VLSPax_frameCount(i) == 0) */
            if (rtd_VLSPax_frameCount[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1686>:1:14' VLSPax_currentGain(i) = VLSPax_targetGain(i); */
                rtd_VLSPax_currentGain[i] = rtd_VLSPax_targetGain[i];
            }
            else
            {
                /* '<S1686>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1686>:1:17' VLSPax_currentGain(i) = VLSPax_currentGain(i)*VLSPax_rampCoeff(i); */
                rtd_VLSPax_currentGain[i] *= rtd_VLSPax_rampCoeff[i];

                /* '<S1686>:1:18' VLSPax_frameCount(i) = VLSPax_frameCount(i) - 1; */
                rtd_VLSPax_frameCount[i]--;
            }
        }
    }
}

/* Output and update for function-call system: '<S1681>/control' */
void Model_Target_control_j(const real32_T rtu_target_gains_linear[12], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_VLSPax_Freeze, real32_T
    rtd_VLSPax_currentGain[12], int32_T rtd_VLSPax_frameCount[12], real32_T
    rtd_VLSPax_rampCoeff[12], real32_T rtd_VLSPax_targetGain[12])
{
    int32_T k;
    real32_T currentgain[12];
    real32_T diff[12];

    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Ramper/control': '<S1685>:1' */
    /* '<S1685>:1:10' dim_rgain = size(VLSPax_currentGain); */
    /* '<S1685>:1:11' rgain_SILENT_GAIN_mat = (configStruct.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1685>:1:15' VLSPax_Freeze(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1685>:1:24' currentgain = max(VLSPax_currentGain, rgain_SILENT_GAIN_mat); */
    /* '<S1685>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1685>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 12; k++)
    {
        currentgain[k] = fmaxf(rtd_VLSPax_currentGain[k], 1.1920929E-7F);
        rtd_VLSPax_rampCoeff[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1685>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1685>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1685>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1685>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1685>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 12; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_VLSPax_rampCoeff[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1685>:1:43' quantum_ms = 1000 * (configStruct.frame_size) / (configStruct.sample_rate_in_hertz); */
    /* '<S1685>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1685>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1685>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1685>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1685>:1:63' VLSPax_frameCount  = int32(numFrames); */
    /* '<S1685>:1:64' VLSPax_rampCoeff   = single(RampCoef); */
    /* '<S1685>:1:65' VLSPax_targetGain  = target_gains_linear; */
    /* '<S1685>:1:66' VLSPax_currentGain = currentgain; */
    for (k = 0; k < 12; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_VLSPax_rampCoeff[k] = qhmath_div_f(rtd_VLSPax_rampCoeff[k],
            currentgain_0);
        rtd_VLSPax_rampCoeff[k] = qhmath_log_f(rtd_VLSPax_rampCoeff[k]);
        rtd_VLSPax_rampCoeff[k] = qhmath_div_f(rtd_VLSPax_rampCoeff[k],
            numFrames);
        rtd_VLSPax_rampCoeff[k] = qhmath_exp_f(rtd_VLSPax_rampCoeff[k]);
        rtd_VLSPax_frameCount[k] = (int32_T)numFrames;
        rtd_VLSPax_targetGain[k] = rtu_target_gains_linear[k];
        rtd_VLSPax_currentGain[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1685>:1:69' VLSPax_Freeze(1) = false; */
    *rtd_VLSPax_Freeze = false;
}

/* Output and update for function-call system: '<S1432>/REQ' */
void HandleReqPreAmpMedusaPostUpmixDisable(void)
{
    /* Outputs for Function Call SubSystem: '<S1166>/Enable State Write' */
    /* DataStoreWrite: '<S1429>/Data Store Write' incorporates:
     *  Constant: '<S1429>/Constant'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1697>:1' */
    /* '<S1697>:1:3' go(); */
    Model_Target_Medusa5H1Part3_DW.MedusaPostUpmixEnable = 0U;

    /* End of Outputs for SubSystem: '<S1166>/Enable State Write' */
}

/* System initialize for atomic system: '<S1137>/Medusa5H1 Part 3' */
void Model_Target_Medusa5H1Part3_Init(void)
{
    int32_T i;

    /* Start for If: '<S1166>/If' */
    Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem = -1;

    /* Start for DataStoreMemory: '<S1166>/Data Store Memory' */
    Model_Target_Medusa5H1Part3_DW.MedusaPostUpmixEnable = 1U;

    /* SystemInitialize for IfAction SubSystem: '<S1166>/On' */

    /* user code (Initialize function Body) */

    // Trigger RTC request handler at init for '<S1627>/RTC Request Response Trigger'
    HandleReqPreAmpMedusaSurroundLevelControlReset();
    for (i = 0; i < 20; i++)
    {
        /* Start for DataStoreMemory: '<S1574>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_CS[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1533>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_CS[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1533>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1533>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[i] = 1.0F;
    }

    for (i = 0; i < 77; i++)
    {
        /* Start for DataStoreMemory: '<S1586>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1534>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1534>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1534>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1598>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Right[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1535>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Right[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1535>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1535>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right[i] = 1.0F;
    }

    for (i = 0; i < 12; i++)
    {
        /* Start for DataStoreMemory: '<S1483>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_CS[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1465>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_CS[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1465>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1465>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS[i] = 1.0E-5F;
    }

    for (i = 0; i < 30; i++)
    {
        /* Start for DataStoreMemory: '<S1495>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1466>/Data Store Memory1' */
        Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Left[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1466>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1466>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1507>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Right[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1467>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Right[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1467>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1467>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i] = 1.0E-5F;
    }

    for (i = 0; i < 12; i++)
    {
        /* Start for DataStoreMemory: '<S1656>/Ramp Coeff' */
        Model_Target_Medusa5H1Part3_DW.VLSDrv_rampCoeff[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1646>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.VLSDrv_SLCGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1646>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1646>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1681>/Ramp Coeff' */
        Model_Target_Medusa5H1Part3_DW.VLSPax_rampCoeff[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1671>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.VLSPax_SLCGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1671>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1671>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain[i] = 1.0E-5F;
    }

    /* SystemInitialize for Atomic SubSystem: '<S1430>/Expand Tail Components' */
    /* '<S1442>:1:18' delayIndex = int32(0); */
    /* '<S1443>:1:18' delayIndex = int32(0); */
    /* '<S1444>:1:18' delayIndex = int32(0); */
    Model_Target_ExpandTailComponents_Init();

    /* End of SystemInitialize for SubSystem: '<S1430>/Expand Tail Components' */
    /* '<S1629>:1:9' previousCount = single(0); */

    /* End of SystemInitialize for SubSystem: '<S1166>/On' */
}

/* Outputs for atomic system: '<S1137>/Medusa5H1 Part 3' */
void Model_Target_Medusa5H1Part3(void)
{
    int32_T colIdx;
    int32_T i;
    int32_T sample;
    int32_T writeIndex;
    real32_T PremixMatrixTarget[77];
    real32_T audioOut[64];
    real32_T MatrixConcatenate[56];
    real32_T PremixMatrix_e[30];
    real32_T PremixMatrix_i[30];
    real32_T PremixMatrix_a[20];
    real32_T rtb_Downsample_n[16];
    real32_T PremixMatrix_m[12];
    real32_T rtb_Transpose1_o_0[12];
    int8_T rtAction;
    int8_T rtPrevAction;
    static const int8_T tmp[18] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14, 15, 16, 17, 18, 19, 20
    };

    static const int8_T tmp_0[6] =
    {
        10, 21, 11, 22, 12, 23
    };

    static const int8_T tmp_1[22] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 10, 20, 11,
        21
    };

    static const int8_T tmp_2[4] =
    {
        5, 7, 5, 7
    };

    /* If: '<S1166>/If' incorporates:
     *  DataStoreRead: '<S1166>/Enable State Read'
     *  Math: '<S1494>/Transpose1'
     *  Math: '<S1506>/Transpose1'
     */
    rtPrevAction = Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem;
    rtAction = (int8_T)(Model_Target_Medusa5H1Part3_DW.MedusaPostUpmixEnable <=
                        0U);
    Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem = rtAction;
    if ((rtPrevAction != rtAction) && (rtPrevAction == 0))
    {
    }

    if (rtAction == 0)
    {
        boolean_T fadeOn;
        boolean_T rtb_SLC_On;
        if (rtPrevAction != 0)
        {
        }

        /* MATLAB Function: '<S1435>/MATLAB Function' */
        /* [Param:maxDelay] */
        /* MATLAB Function 'MedusaAlignmentDelay/MATLAB Function': '<S1444>:1' */
        /*  Our delayline lives in global variable. We treat as a circular buffer.  */
        /*  figure out the frame size and channel count */
        /* '<S1444>:1:9' [frameSize, numChannels] = size(audioIn); */
        /* '<S1444>:1:10' frameSize = int32(frameSize); */
        /* '<S1444>:1:11' stateLen = int32(maxDelay)+frameSize; */
        /* '<S1444>:1:12' totalLen = int32(stateLen * numChannels); */
        /* '<S1444>:1:13' audioOut = coder.nullcopy(audioIn); */
        /*  writeIndex points to our current write location in buffer */
        /* '<S1444>:1:17' if isempty(delayIndex) */
        /*  delayBuffer is a circular buffer that holds previous samples */
        /*  Write data to delay buffer */
        /* '<S1444>:1:24' bufferIndex = delayIndex; */
        i = Model_Target_Medusa5H1Part3_DW.delayIndex;

        /* '<S1444>:1:26' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 2; colIdx++)
        {
            /*  Save writeIndex for next channel */
            /* '<S1444>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
            writeIndex = circindex(i, 0, 70);

            /* '<S1444>:1:31' for sample = 1:frameSize */
            for (sample = 0; sample < 32; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S1444>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
                FullRateBassDelay[writeIndex] =
                    Model_Target_B.PreAmp2HeadrestDr[(colIdx << 5) + sample];

                /*  increment write pointer */
                /* '<S1444>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 70);
            }

            /*  Advance buffer index for next channel */
            /* '<S1444>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 35, 70);
        }

        /*  Reset */
        /* '<S1444>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
        i = circindex(Model_Target_Medusa5H1Part3_DW.delayIndex, 32, 70);

        /* '<S1444>:1:46' delayIndex = bufferIndex; */
        Model_Target_Medusa5H1Part3_DW.delayIndex = i;

        /*  Read samples from delay line */
        /* '<S1444>:1:49' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 2; colIdx++)
        {
            /*  Setup read pointer */
            /* '<S1444>:1:52' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
            writeIndex = circindex(i,
                                   -(Model_Target_PreAmp0.MedusaFullRateBassDelay
                                    + 32), 70);

            /* '<S1444>:1:54' for sample = 1:frameSize */
            for (sample = 0; sample < 32; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S1444>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
                audioOut[sample + (colIdx << 5)] = FullRateBassDelay[writeIndex];

                /*  increment write pointer */
                /* '<S1444>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 70);
            }

            /*  Advance buffer index for next channel */
            /* '<S1444>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 35, 70);
        }

        /* End of MATLAB Function: '<S1435>/MATLAB Function' */

        /* DownSample: '<S1430>/Downsample' */
        for (i = 0; i < 16; i++)
        {
            rtb_Downsample_n[i] = audioOut[i << 2];
        }

        /* End of DownSample: '<S1430>/Downsample' */
        /* MATLAB Function: '<S1434>/MATLAB Function' incorporates:
         *  DownSample: '<S1430>/Downsample'
         */
        /* [Param:maxDelay] */
        /* MATLAB Function 'MedusaAlignmentDelay/MATLAB Function': '<S1443>:1' */
        /*  Our delayline lives in global variable. We treat as a circular buffer.  */
        /*  figure out the frame size and channel count */
        /* '<S1443>:1:9' [frameSize, numChannels] = size(audioIn); */
        /* '<S1443>:1:10' frameSize = int32(frameSize); */
        /* '<S1443>:1:11' stateLen = int32(maxDelay)+frameSize; */
        /* '<S1443>:1:12' totalLen = int32(stateLen * numChannels); */
        /* '<S1443>:1:13' audioOut = coder.nullcopy(audioIn); */
        /*  writeIndex points to our current write location in buffer */
        /* '<S1443>:1:17' if isempty(delayIndex) */
        /*  delayBuffer is a circular buffer that holds previous samples */
        /*  Write data to delay buffer */
        /* '<S1443>:1:24' bufferIndex = delayIndex; */
        i = Model_Target_Medusa5H1Part3_DW.delayIndex_i;

        /* '<S1443>:1:26' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 2; colIdx++)
        {
            /*  Save writeIndex for next channel */
            /* '<S1443>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
            writeIndex = circindex(i, 0, 1482);

            /* '<S1443>:1:31' for sample = 1:frameSize */
            for (sample = 0; sample < 8; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S1443>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
                DeciRateBassDelay[writeIndex] = rtb_Downsample_n[(colIdx << 3) +
                    sample];

                /*  increment write pointer */
                /* '<S1443>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 1482);
            }

            /*  Advance buffer index for next channel */
            /* '<S1443>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 741, 1482);
        }

        /*  Reset */
        /* '<S1443>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
        i = circindex(Model_Target_Medusa5H1Part3_DW.delayIndex_i, 8, 1482);

        /* '<S1443>:1:46' delayIndex = bufferIndex; */
        Model_Target_Medusa5H1Part3_DW.delayIndex_i = i;

        /*  Read samples from delay line */
        /* '<S1443>:1:49' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 2; colIdx++)
        {
            /*  Setup read pointer */
            /* '<S1443>:1:52' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
            writeIndex = circindex(i,
                                   -(Model_Target_PreAmp0.MedusaDeciRateBassDelay
                                    + 8), 1482);

            /* '<S1443>:1:54' for sample = 1:frameSize */
            for (sample = 0; sample < 8; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S1443>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
                Model_Target_Medusa5H1Part3_B.audioOut_p[sample + (colIdx << 3)]
                    = DeciRateBassDelay[writeIndex];

                /*  increment write pointer */
                /* '<S1443>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 1482);
            }

            /*  Advance buffer index for next channel */
            /* '<S1443>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 741, 1482);
        }

        /* End of MATLAB Function: '<S1434>/MATLAB Function' */
        for (writeIndex = 0; writeIndex < 8; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S1609>/Submatrix' */
            Model_Target_Medusa5H1Part3_B.Submatrix[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_p[writeIndex];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1609>/Submatrix'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex] =
                Model_Target_Medusa5H1Part3_B.Submatrix[writeIndex];
        }

        /* MATLAB Function: '<S1433>/MATLAB Function' incorporates:
         *  Buffer: '<S1204>/BufferOut'
         */
        /* [Param:maxDelay] */
        /* MATLAB Function 'MedusaAlignmentDelay/MATLAB Function': '<S1442>:1' */
        /*  Our delayline lives in global variable. We treat as a circular buffer.  */
        /*  figure out the frame size and channel count */
        /* '<S1442>:1:9' [frameSize, numChannels] = size(audioIn); */
        /* '<S1442>:1:10' frameSize = int32(frameSize); */
        /* '<S1442>:1:11' stateLen = int32(maxDelay)+frameSize; */
        /* '<S1442>:1:12' totalLen = int32(stateLen * numChannels); */
        /* '<S1442>:1:13' audioOut = coder.nullcopy(audioIn); */
        /*  writeIndex points to our current write location in buffer */
        /* '<S1442>:1:17' if isempty(delayIndex) */
        /*  delayBuffer is a circular buffer that holds previous samples */
        /*  Write data to delay buffer */
        /* '<S1442>:1:24' bufferIndex = delayIndex; */
        i = Model_Target_Medusa5H1Part3_DW.delayIndex_d;

        /* '<S1442>:1:26' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 8; colIdx++)
        {
            /*  Save writeIndex for next channel */
            /* '<S1442>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
            writeIndex = circindex(i, 0, 1392);

            /* '<S1442>:1:31' for sample = 1:frameSize */
            for (sample = 0; sample < 8; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S1442>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
                MidrangeDelay[writeIndex] = Model_Target_B.BufferOut[(colIdx <<
                    3) + sample];

                /*  increment write pointer */
                /* '<S1442>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 1392);
            }

            /*  Advance buffer index for next channel */
            /* '<S1442>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 174, 1392);
        }

        /*  Reset */
        /* '<S1442>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
        i = circindex(Model_Target_Medusa5H1Part3_DW.delayIndex_d, 8, 1392);

        /* '<S1442>:1:46' delayIndex = bufferIndex; */
        Model_Target_Medusa5H1Part3_DW.delayIndex_d = i;

        /*  Read samples from delay line */
        /* '<S1442>:1:49' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 8; colIdx++)
        {
            /*  Setup read pointer */
            /* '<S1442>:1:52' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
            writeIndex = circindex(i, -(Model_Target_PreAmp0.MedusaMidrangeDelay
                                    + 8), 1392);

            /* '<S1442>:1:54' for sample = 1:frameSize */
            for (sample = 0; sample < 8; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S1442>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
                Model_Target_Medusa5H1Part3_B.audioOut_g[sample + (colIdx << 3)]
                    = MidrangeDelay[writeIndex];

                /*  increment write pointer */
                /* '<S1442>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 1392);
            }

            /*  Advance buffer index for next channel */
            /* '<S1442>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 174, 1392);
        }

        /* End of MATLAB Function: '<S1433>/MATLAB Function' */
        for (writeIndex = 0; writeIndex < 8; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S1610>/Submatrix2' */
            Model_Target_Medusa5H1Part3_B.Submatrix2[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix2'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 8] =
                Model_Target_Medusa5H1Part3_B.Submatrix2[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1610>/Submatrix4' */
            Model_Target_Medusa5H1Part3_B.Submatrix4[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 16];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix4'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 16] =
                Model_Target_Medusa5H1Part3_B.Submatrix4[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1610>/Submatrix6' */
            Model_Target_Medusa5H1Part3_B.Submatrix6[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 32];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix6'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 24] =
                Model_Target_Medusa5H1Part3_B.Submatrix6[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1610>/Submatrix7' */
            Model_Target_Medusa5H1Part3_B.Submatrix7[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 40];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix7'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 32] =
                Model_Target_Medusa5H1Part3_B.Submatrix7[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1609>/Submatrix1' */
            Model_Target_Medusa5H1Part3_B.Submatrix1[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_p[writeIndex + 8];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1609>/Submatrix1'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 40] =
                Model_Target_Medusa5H1Part3_B.Submatrix1[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1610>/Submatrix3' */
            Model_Target_Medusa5H1Part3_B.Submatrix3[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 8];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix3'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 48] =
                Model_Target_Medusa5H1Part3_B.Submatrix3[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1610>/Submatrix5' */
            Model_Target_Medusa5H1Part3_B.Submatrix5[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 24];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix5'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 56] =
                Model_Target_Medusa5H1Part3_B.Submatrix5[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1610>/Submatrix1' */
            Model_Target_Medusa5H1Part3_B.Submatrix1_a[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 48];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix1'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 64] =
                Model_Target_Medusa5H1Part3_B.Submatrix1_a[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1610>/Submatrix8' */
            Model_Target_Medusa5H1Part3_B.Submatrix8[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 56];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix8'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 72] =
                Model_Target_Medusa5H1Part3_B.Submatrix8[writeIndex];
        }

        /* S-Function (sdspsubmtrx): '<S1573>/Submatrix' incorporates:
         *  DataStoreRead: '<S1573>/Data Store Read1'
         */
        i = 0;
        for (colIdx = 0; colIdx < 10; colIdx++)
        {
            Model_Target_Medusa5H1Part3_B.Submatrix_g[i] =
                Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[(colIdx <<
                1) + 1];
            i++;
        }

        /* End of S-Function (sdspsubmtrx): '<S1573>/Submatrix' */

        /* S-Function (sdspsubmtrx): '<S1573>/Submatrix1' incorporates:
         *  DataStoreRead: '<S1573>/Data Store Read1'
         */
        i = 0;
        for (colIdx = 0; colIdx < 10; colIdx++)
        {
            Model_Target_Medusa5H1Part3_B.Submatrix1_c[i] =
                Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[colIdx << 1];
            Model_Target_Medusa5H1Part3_B.Submatrix1_c[i + 1] =
                Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[(colIdx <<
                1) + 1];
            i += 2;
        }

        /* End of S-Function (sdspsubmtrx): '<S1573>/Submatrix1' */

        /* Math: '<S1573>/Transpose1' incorporates:
         *  S-Function (sdspsubmtrx): '<S1573>/Submatrix1'
         */
        for (i = 0; i < 2; i++)
        {
            for (colIdx = 0; colIdx < 10; colIdx++)
            {
                PremixMatrix_a[colIdx + 10 * i] =
                    Model_Target_Medusa5H1Part3_B.Submatrix1_c[(colIdx << 1) + i];
            }
        }

        /* End of Math: '<S1573>/Transpose1' */

        /* Product: '<S1573>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1537>/Matrix Concatenate1'
         */
        for (i = 0; i < 2; i++)
        {
            for (colIdx = 0; colIdx < 8; colIdx++)
            {
                sample = (i << 3) + colIdx;
                rtb_Downsample_n[sample] = 0.0F;
                for (writeIndex = 0; writeIndex < 10; writeIndex++)
                {
                    rtb_Downsample_n[sample] +=
                        Model_Target_Medusa5H1Part3_B.MatrixConcatenate1
                        [(writeIndex << 3) + colIdx] * PremixMatrix_a[10 * i +
                        writeIndex];
                }
            }
        }

        /* MATLAB Function: '<S1530>/Selective Concatenation' incorporates:
         *  Merge: '<S1166>/Merge'
         *  Product: '<S1573>/Matrix Multiply1'
         */
        memcpy(&Model_Target_Medusa5H1Part3_B.Merge[0], &rtb_Downsample_n[0],
               sizeof(real32_T) << 4U);

        /* M-S-Function: '<S1530>/FeaturePath' */
        /*  Concatenate monosurround output (if available) to the center outputs */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/CS Processing/Selective Concatenation': '<S1543>:1' */
        /* '<S1543>:1:5' if MedusaPremixConfig.NumSurroundOut==0 */
        /* '<S1543>:1:6' CSOut = COut; */
        /* MATLAB Function: '<S1624>/MATLAB Function1' */
        /* MATLAB Function 'Surround Level Control Generic/Detect SLC REQ/MATLAB Function1': '<S1629>:1' */
        /*  Initialize previousCount */
        /* '<S1629>:1:8' if(isempty(previousCount)) */
        /* '<S1629>:1:12' SLC_On = false; */
        rtb_SLC_On = false;

        /*  Track changes in TriggerCount to indicate SLC Trigger */
        /* '<S1629>:1:15' if(TriggerCount ~= previousCount) */
        if (Model_Target_Medusa5H1Part3_DW.TriggerCount !=
                Model_Target_Medusa5H1Part3_DW.previousCount)
        {
            /* '<S1629>:1:16' SLC_On = true; */
            rtb_SLC_On = true;
        }

        /*  Update the previousCount to contain the previous value of Trigger Count for next instance */
        /* '<S1629>:1:20' previousCount = TriggerCount; */
        Model_Target_Medusa5H1Part3_DW.previousCount =
            Model_Target_Medusa5H1Part3_DW.TriggerCount;

        /* End of MATLAB Function: '<S1624>/MATLAB Function1' */

        /* Selector: '<S1430>/Selector' incorporates:
         *  Delay: '<S1430>/Delay6'
         */
        Model_Target_Medusa5H1Part3_B.Selector_p =
            Model_Target_Medusa5H1Part3_DW.Delay6_DSTATE[0];

        /* Selector: '<S1430>/Selector2' incorporates:
         *  Delay: '<S1430>/Delay6'
         */
        Model_Target_Medusa5H1Part3_B.Selector2 =
            Model_Target_Medusa5H1Part3_DW.Delay6_DSTATE[1];

        /* MATLAB Function: '<S1531>/Fade_Trigger_Generation' */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Fade Inputs/Fade_Trigger_Generation': '<S1564>:1' */
        /* '<S1564>:1:3' fadeOn = false; */
        fadeOn = false;

        /* Abs: '<S1531>/Abs2' incorporates:
         *  Delay: '<S1531>/Delay2'
         */
        /*  Generates function call triggers when incoming fade gain values change */
        /* '<S1564>:1:6' if(gainDifference > 0) */
        if (-Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE < 0)
        {
            i = Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE;
        }
        else
        {
            i = -Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE;
        }

        /* MATLAB Function: '<S1531>/Fade_Trigger_Generation' incorporates:
         *  Abs: '<S1531>/Abs'
         *  Abs: '<S1531>/Abs1'
         *  Abs: '<S1531>/Abs2'
         *  Delay: '<S1531>/Delay'
         *  Delay: '<S1531>/Delay1'
         *  Sum: '<S1531>/Add'
         *  Sum: '<S1531>/Subtract1'
         *  Sum: '<S1531>/Subtract2'
         */
        if ((qhmath_abs_f(Model_Target_Medusa5H1Part3_B.Selector_p -
                          Model_Target_Medusa5H1Part3_DW.Delay_DSTATE) +
                (real32_T)i) + qhmath_abs_f
                (Model_Target_Medusa5H1Part3_B.Selector2 -
                 Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE) > 0.0F)
        {
            /* Outputs for Function Call SubSystem: '<S1534>/Fader Downmix' */
            /* If: '<S1584>/If' */
            /* '<S1564>:1:7' fadeTrigger_Left(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1584>/Fading Forward' incorporates:
                 *  ActionPort: '<S1589>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp0.MedusaPremixForwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaPremixForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_p);

                /* End of Outputs for SubSystem: '<S1584>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1584>/Fading Backward' incorporates:
                 *  ActionPort: '<S1588>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp0.MedusaPremixBackwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaPremixBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_p);

                /* End of Outputs for SubSystem: '<S1584>/Fading Backward' */
            }

            /* End of If: '<S1584>/If' */
            /*  #codegen */
            /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Fader Downmix/MATLAB Function': '<S1590>:1' */
            /* '<S1590>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1590>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 77; i++)
            {
                /* Product: '<S1584>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1584>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1568>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_bn[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_p *
                    Model_Target_PreAmp0.MedusaPremixDownmixWeights_Left[i];
            }

            /* Outputs for Function Call SubSystem: '<S1533>/Fader Downmix' */
            /* If: '<S1572>/If' */
            /* '<S1564>:1:8' fadeTrigger_CS(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1572>/Fading Forward' incorporates:
                 *  ActionPort: '<S1577>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp0.MedusaPremixForwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaPremixForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_c);

                /* End of Outputs for SubSystem: '<S1572>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1572>/Fading Backward' incorporates:
                 *  ActionPort: '<S1576>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp0.MedusaPremixBackwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaPremixBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_c);

                /* End of Outputs for SubSystem: '<S1572>/Fading Backward' */
            }

            /* End of If: '<S1572>/If' */
            /*  #codegen */
            /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Fader Downmix/MATLAB Function': '<S1578>:1' */
            /* '<S1578>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1578>:1:6' if(MedusaPremixConfig.includeCAE ==1 && CAE_Enable == 1) */
            for (i = 0; i < 20; i++)
            {
                /* Product: '<S1572>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1572>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1567>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_b[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_c *
                    Model_Target_PreAmp0.MedusaPremixDownmixWeights_CS[i];
            }

            /* Outputs for Function Call SubSystem: '<S1535>/Fader Downmix' */
            /* If: '<S1596>/If' */
            /* '<S1564>:1:9' fadeTrigger_Right(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1596>/Fading Forward' incorporates:
                 *  ActionPort: '<S1601>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp0.MedusaPremixForwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaPremixForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_g);

                /* End of Outputs for SubSystem: '<S1596>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1596>/Fading Backward' incorporates:
                 *  ActionPort: '<S1600>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp0.MedusaPremixBackwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaPremixBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_g);

                /* End of Outputs for SubSystem: '<S1596>/Fading Backward' */
            }

            /* End of If: '<S1596>/If' */
            /*  #codegen */
            /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Fader Downmix/MATLAB Function': '<S1602>:1' */
            /* '<S1602>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1602>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 77; i++)
            {
                /* Product: '<S1596>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1596>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1569>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_g *
                    Model_Target_PreAmp0.MedusaPremixDownmixWeights_Right[i];
            }

            /* '<S1564>:1:10' fadeOn = true; */
            fadeOn = true;

            /*  Indicates that fade is triggered */
        }

        for (i = 0; i < 77; i++)
        {
            /* Sum: '<S1535>/Add' incorporates:
             *  Constant: '<S1535>/Constant'
             *  DataStoreRead: '<S1599>/Data Store Read'
             *  Product: '<S1535>/Matrix Multiply'
             *  Product: '<S1596>/Matrix Multiply'
             *  Sum: '<S1535>/Subtract'
             */
            Model_Target_Medusa5H1Part3_B.Transpose1_o[i] = (1.0F -
                Model_Target_Medusa5H1Part3_B.Merge_g) *
                Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Right[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply[i];
        }

        /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1626>/RTC Request Response Trigger' */
        for (i = 0; i < 77; i++)
        {
            /* Sum: '<S1534>/Add' incorporates:
             *  Constant: '<S1534>/Constant'
             *  DataStoreRead: '<S1587>/Data Store Read'
             *  Product: '<S1534>/Matrix Multiply'
             *  Product: '<S1584>/Matrix Multiply'
             *  Sum: '<S1534>/Subtract'
             */
            PremixMatrixTarget[i] = (1.0F -
                Model_Target_Medusa5H1Part3_B.Merge_p) *
                Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Left[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_bn[i];
        }

        for (i = 0; i < 20; i++)
        {
            /* Sum: '<S1533>/Add' incorporates:
             *  Constant: '<S1533>/Constant'
             *  DataStoreRead: '<S1575>/Data Store Read'
             *  Product: '<S1533>/Matrix Multiply'
             *  Product: '<S1572>/Matrix Multiply'
             *  Sum: '<S1533>/Subtract'
             */
            PremixMatrix_a[i] = (1.0F - Model_Target_Medusa5H1Part3_B.Merge_c) *
                Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_CS[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_b[i];
        }

        /* MATLAB Function: '<S1536>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S1531>/Fade_Trigger_Generation'
         */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Generate Ramp Trigger/MATLAB Function': '<S1608>:1' */
        /* '<S1608>:1:3' rampOn = 0; */
        /*  DEBUG parameter */
        /*  Trigger ramping if SLC OR Fade is triggered */
        /* '<S1608>:1:6' if(SLC_On || Fade_On) */
        if (rtb_SLC_On || fadeOn)
        {
            /* MATLAB Function: '<S1586>/control' */
            /* MATLAB Function: '<S1586>/control' */
            /* '<S1608>:1:7' rampOn = 1; */
            /* '<S1608>:1:8' ramp(); */
            Model_Target_control_p(PremixMatrixTarget,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.Premix_Freeze_Left,
                                   Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left,
                                   Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Left,
                                   Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Left,
                                   Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left);

            /* MATLAB Function: '<S1574>/control' */
            /* MATLAB Function: '<S1574>/control' */
            Model_Target_control_l(PremixMatrix_a,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.Premix_Freeze_CS,
                                   Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS,
                                   Model_Target_Medusa5H1Part3_DW.Premix_frameCount_CS,
                                   Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_CS,
                                   Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS);

            /* MATLAB Function: '<S1598>/control' */
            /* MATLAB Function: '<S1598>/control' */
            Model_Target_control_c(Model_Target_Medusa5H1Part3_B.Transpose1_o,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.Premix_Freeze_Right,
                                   Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right,
                                   Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Right,
                                   Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Right,
                                   Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right);
        }

        /* End of MATLAB Function: '<S1536>/MATLAB Function' */
        /* End of Outputs for S-Function (RTC_NTF): '<S1626>/NTF Trigger' */

        /* MATLAB Function: '<S1574>/process' */
        Model_Target_process_p(&Model_Target_Medusa5H1Part3_DW.Premix_Freeze_CS,
                               Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS,
                               Model_Target_Medusa5H1Part3_DW.Premix_frameCount_CS,
                               Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_CS,
                               Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS);

        /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1627>/RTC Request Response Trigger' */
        for (i = 0; i < 8; i++)
        {
            /* SignalConversion generated from: '<S1537>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1609>/Submatrix'
             */
            MatrixConcatenate[i] = Model_Target_Medusa5H1Part3_B.Submatrix[i];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix2'
             */
            MatrixConcatenate[i + 8] =
                Model_Target_Medusa5H1Part3_B.Submatrix2[i];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix4'
             */
            MatrixConcatenate[i + 16] =
                Model_Target_Medusa5H1Part3_B.Submatrix4[i];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix6'
             */
            MatrixConcatenate[i + 24] =
                Model_Target_Medusa5H1Part3_B.Submatrix6[i];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix7'
             */
            MatrixConcatenate[i + 32] =
                Model_Target_Medusa5H1Part3_B.Submatrix7[i];
        }

        /* Selector: '<S1430>/Selector1' incorporates:
         *  Buffer: '<S1204>/BufferOut'
         */
        for (i = 0; i < 4; i++)
        {
            for (colIdx = 0; colIdx < 8; colIdx++)
            {
                Model_Target_Medusa5H1Part3_B.LtailRtailLtailRtail[colIdx + (i <<
                    3)] = Model_Target_B.BufferOut[(tmp_2[i] << 3) + colIdx];
            }
        }

        /* End of Selector: '<S1430>/Selector1' */

        /* Outputs for Atomic SubSystem: '<S1430>/Expand Tail Components' */
        Model_Target_ExpandTailComponents();

        /* End of Outputs for SubSystem: '<S1430>/Expand Tail Components' */
        for (writeIndex = 0; writeIndex < 8; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S1611>/Submatrix' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate'
             *  Reshape: '<S1453>/Reshape'
             */
            MatrixConcatenate[writeIndex + 40] =
                Model_Target_ExpandTailComponents_B.Reshape[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1611>/Submatrix2' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate'
             *  Reshape: '<S1453>/Reshape'
             */
            MatrixConcatenate[writeIndex + 48] =
                Model_Target_ExpandTailComponents_B.Reshape[writeIndex + 16];
        }

        /* Product: '<S1585>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1537>/Matrix Concatenate'
         *  DataStoreRead: '<S1585>/Mixing Gains'
         *  Math: '<S1585>/Transpose1'
         *  Merge: '<S1166>/Merge'
         */
        for (i = 0; i < 8; i++)
        {
            for (colIdx = 0; colIdx < 11; colIdx++)
            {
                sample = (colIdx << 3) + i;
                Model_Target_Medusa5H1Part3_B.MatrixConcatenate[sample] = 0.0F;
                for (writeIndex = 0; writeIndex < 7; writeIndex++)
                {
                    Model_Target_Medusa5H1Part3_B.MatrixConcatenate[sample] +=
                        MatrixConcatenate[(writeIndex << 3) + i] *
                        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left
                        [11 * writeIndex + colIdx];
                }
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge[16],
               &Model_Target_Medusa5H1Part3_B.MatrixConcatenate[0], 88U * sizeof
               (real32_T));

        /* End of Product: '<S1585>/Matrix Multiply1' */

        /* MATLAB Function: '<S1586>/process' */
        Model_Target_process_in
            (&Model_Target_Medusa5H1Part3_DW.Premix_Freeze_Left,
             Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left,
             Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Left,
             Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Left,
             Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left);
        for (writeIndex = 0; writeIndex < 8; writeIndex++)
        {
            /* SignalConversion generated from: '<S1537>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1609>/Submatrix1'
             */
            MatrixConcatenate[writeIndex] =
                Model_Target_Medusa5H1Part3_B.Submatrix1[writeIndex];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix3'
             */
            MatrixConcatenate[writeIndex + 8] =
                Model_Target_Medusa5H1Part3_B.Submatrix3[writeIndex];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix5'
             */
            MatrixConcatenate[writeIndex + 16] =
                Model_Target_Medusa5H1Part3_B.Submatrix5[writeIndex];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix1'
             */
            MatrixConcatenate[writeIndex + 24] =
                Model_Target_Medusa5H1Part3_B.Submatrix1_a[writeIndex];

            /* SignalConversion generated from: '<S1537>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1610>/Submatrix8'
             */
            MatrixConcatenate[writeIndex + 32] =
                Model_Target_Medusa5H1Part3_B.Submatrix8[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1611>/Submatrix1' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate4'
             *  Reshape: '<S1453>/Reshape'
             */
            MatrixConcatenate[writeIndex + 40] =
                Model_Target_ExpandTailComponents_B.Reshape[writeIndex + 8];

            /* S-Function (sdspsubmtrx): '<S1611>/Submatrix3' incorporates:
             *  Concatenate: '<S1537>/Matrix Concatenate4'
             *  Reshape: '<S1453>/Reshape'
             */
            MatrixConcatenate[writeIndex + 48] =
                Model_Target_ExpandTailComponents_B.Reshape[writeIndex + 24];
        }

        /* Product: '<S1597>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1537>/Matrix Concatenate4'
         *  DataStoreRead: '<S1597>/Data Store Read1'
         *  Math: '<S1597>/Transpose1'
         *  Merge: '<S1166>/Merge'
         */
        for (i = 0; i < 8; i++)
        {
            for (colIdx = 0; colIdx < 11; colIdx++)
            {
                sample = (colIdx << 3) + i;
                Model_Target_Medusa5H1Part3_B.MatrixConcatenate[sample] = 0.0F;
                for (writeIndex = 0; writeIndex < 7; writeIndex++)
                {
                    Model_Target_Medusa5H1Part3_B.MatrixConcatenate[sample] +=
                        MatrixConcatenate[(writeIndex << 3) + i] *
                        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right
                        [11 * writeIndex + colIdx];
                }
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge[104],
               &Model_Target_Medusa5H1Part3_B.MatrixConcatenate[0], 88U * sizeof
               (real32_T));

        /* End of Product: '<S1597>/Matrix Multiply1' */

        /* MATLAB Function: '<S1598>/process' */
        Model_Target_process_f
            (&Model_Target_Medusa5H1Part3_DW.Premix_Freeze_Right,
             Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right,
             Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Right,
             Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Right,
             Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right);

        /* MATLAB Function: '<S1463>/Fade_Trigger_Generation' */
        /*  #codegen */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Fade Inputs/Fade_Trigger_Generation': '<S1473>:1' */
        /* '<S1473>:1:3' fadeOn = false; */
        fadeOn = false;

        /* Abs: '<S1463>/Abs2' incorporates:
         *  Delay: '<S1463>/Delay2'
         */
        /*  Generates function call triggers when incoming fade gain values change */
        /* '<S1473>:1:6' if(gainDifference > 0) */
        if (-Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE_k < 0)
        {
            i = Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE_k;
        }
        else
        {
            i = -Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE_k;
        }

        /* MATLAB Function: '<S1463>/Fade_Trigger_Generation' incorporates:
         *  Abs: '<S1463>/Abs'
         *  Abs: '<S1463>/Abs1'
         *  Abs: '<S1463>/Abs2'
         *  Delay: '<S1463>/Delay'
         *  Delay: '<S1463>/Delay1'
         *  Sum: '<S1463>/Add'
         *  Sum: '<S1463>/Subtract1'
         *  Sum: '<S1463>/Subtract2'
         */
        if ((qhmath_abs_f(Model_Target_Medusa5H1Part3_B.Selector_p -
                          Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_c) +
                (real32_T)i) + qhmath_abs_f
                (Model_Target_Medusa5H1Part3_B.Selector2 -
                 Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_m) > 0.0F)
        {
            /* Outputs for Function Call SubSystem: '<S1466>/Fader Downmix' */
            /* If: '<S1493>/If' */
            /* '<S1473>:1:7' fadeTrigger_Left(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1493>/Fading Forward' incorporates:
                 *  ActionPort: '<S1498>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp0.MedusaFullRateMixerForwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaFullRateMixerForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_pk);

                /* End of Outputs for SubSystem: '<S1493>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1493>/Fading Backward' incorporates:
                 *  ActionPort: '<S1497>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp0.MedusaFullRateMixerBackwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaFullRateMixerBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_pk);

                /* End of Outputs for SubSystem: '<S1493>/Fading Backward' */
            }

            /* End of If: '<S1493>/If' */
            /*  #codegen */
            /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Fader Downmix/MATLAB Function': '<S1499>:1' */
            /* '<S1499>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1499>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 30; i++)
            {
                /* Product: '<S1493>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1493>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1477>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_n[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_pk *
                    Model_Target_PreAmp0.MedusaFullRateMixerDownmixWeights_Left[i];
            }

            /* Outputs for Function Call SubSystem: '<S1465>/Fader Downmix' */
            /* If: '<S1481>/If' */
            /* '<S1473>:1:8' fadeTrigger_CS(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1481>/Fading Forward' incorporates:
                 *  ActionPort: '<S1486>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp0.MedusaFullRateMixerForwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaFullRateMixerForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_n);

                /* End of Outputs for SubSystem: '<S1481>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1481>/Fading Backward' incorporates:
                 *  ActionPort: '<S1485>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp0.MedusaFullRateMixerBackwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaFullRateMixerBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_n);

                /* End of Outputs for SubSystem: '<S1481>/Fading Backward' */
            }

            /* End of If: '<S1481>/If' */
            /*  #codegen */
            /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Fader Downmix/MATLAB Function': '<S1487>:1' */
            /* '<S1487>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1487>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 12; i++)
            {
                /* Product: '<S1481>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1481>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1476>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_e[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_n *
                    Model_Target_PreAmp0.MedusaFullRateMixerDownmixWeights_CS[i];
            }

            /* Outputs for Function Call SubSystem: '<S1467>/Fader Downmix' */
            /* If: '<S1505>/If' */
            /* '<S1473>:1:9' fadeTrigger_Right(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1505>/Fading Forward' incorporates:
                 *  ActionPort: '<S1510>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp0.MedusaFullRateMixerForwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaFullRateMixerForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_go);

                /* End of Outputs for SubSystem: '<S1505>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1505>/Fading Backward' incorporates:
                 *  ActionPort: '<S1509>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp0.MedusaFullRateMixerBackwardDownmixThreshold,
                     Model_Target_PreAmp0.MedusaFullRateMixerBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_go);

                /* End of Outputs for SubSystem: '<S1505>/Fading Backward' */
            }

            /* End of If: '<S1505>/If' */
            /*  #codegen */
            /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Fader Downmix/MATLAB Function': '<S1511>:1' */
            /* '<S1511>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1511>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 30; i++)
            {
                /* Product: '<S1505>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1505>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1478>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_i[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_go *
                    Model_Target_PreAmp0.MedusaFullRateMixerDownmixWeights_Right[
                    i];
            }

            /* '<S1473>:1:10' fadeOn = true; */
            fadeOn = true;

            /*  Indicates that fade is triggered */
        }

        for (i = 0; i < 30; i++)
        {
            /* Sum: '<S1467>/Add' incorporates:
             *  Constant: '<S1467>/Constant'
             *  DataStoreRead: '<S1508>/Data Store Read'
             *  Product: '<S1467>/Matrix Multiply'
             *  Product: '<S1505>/Matrix Multiply'
             *  Sum: '<S1467>/Subtract'
             */
            PremixMatrix_i[i] = (1.0F - Model_Target_Medusa5H1Part3_B.Merge_go) *
                Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Right[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_i[i];

            /* Sum: '<S1466>/Add' incorporates:
             *  Constant: '<S1466>/Constant'
             *  DataStoreRead: '<S1496>/Data Store Read'
             *  Product: '<S1466>/Matrix Multiply'
             *  Product: '<S1493>/Matrix Multiply'
             *  Sum: '<S1466>/Subtract'
             */
            PremixMatrix_e[i] = (1.0F - Model_Target_Medusa5H1Part3_B.Merge_pk) *
                Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Left[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_n[i];
        }

        for (i = 0; i < 12; i++)
        {
            /* Sum: '<S1465>/Add' incorporates:
             *  Constant: '<S1465>/Constant'
             *  DataStoreRead: '<S1484>/Data Store Read'
             *  Product: '<S1465>/Matrix Multiply'
             *  Product: '<S1481>/Matrix Multiply'
             *  Sum: '<S1465>/Subtract'
             */
            PremixMatrix_m[i] = (1.0F - Model_Target_Medusa5H1Part3_B.Merge_n) *
                Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_CS[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_e[i];
        }

        /* MATLAB Function: '<S1468>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S1463>/Fade_Trigger_Generation'
         */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Generate Ramp Trigger/MATLAB Function': '<S1517>:1' */
        /* '<S1517>:1:3' rampOn = 0; */
        /*  DEBUG parameter */
        /*  Trigger ramping if SLC OR Fade is triggered */
        /* '<S1517>:1:6' if(SLC_On || Fade_On) */
        if (rtb_SLC_On || fadeOn)
        {
            /* MATLAB Function: '<S1495>/control' */
            /* MATLAB Function: '<S1495>/control' */
            /* '<S1517>:1:7' rampOn = 1; */
            /* '<S1517>:1:8' ramp(); */
            Model_Target_control_m(PremixMatrix_e,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.FRM_Freeze_Left,
                                   Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left,
                                   Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Left,
                                   Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Left,
                                   Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left);

            /* MATLAB Function: '<S1483>/control' */
            /* MATLAB Function: '<S1483>/control' */
            Model_Target_control_e(PremixMatrix_m,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.FRM_Freeze_CS,
                                   Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS,
                                   Model_Target_Medusa5H1Part3_DW.FRM_frameCount_CS,
                                   Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_CS,
                                   Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS);

            /* MATLAB Function: '<S1507>/control' */
            /* MATLAB Function: '<S1507>/control' */
            Model_Target_control_a(PremixMatrix_i,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.FRM_Freeze_Right,
                                   Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right,
                                   Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Right,
                                   Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Right,
                                   Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right);
        }

        /* End of MATLAB Function: '<S1468>/MATLAB Function' */
        for (writeIndex = 0; writeIndex < 32; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S1518>/Submatrix2' incorporates:
             *  Buffer: '<S1205>/BufferOut'
             *  Concatenate: '<S1469>/Matrix Concatenate'
             */
            Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[writeIndex]
                = Model_Target_B.BufferOut_c[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1518>/Submatrix4' incorporates:
             *  Buffer: '<S1205>/BufferOut'
             *  Concatenate: '<S1469>/Matrix Concatenate'
             */
            Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[writeIndex
                + 32] = Model_Target_B.BufferOut_c[writeIndex + 64];

            /* S-Function (sdspsubmtrx): '<S1518>/Submatrix5' incorporates:
             *  Buffer: '<S1205>/BufferOut'
             *  Concatenate: '<S1469>/Matrix Concatenate'
             */
            Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[writeIndex
                + 64] = Model_Target_B.BufferOut_c[writeIndex + 96];
        }

        /* SignalConversion generated from: '<S1469>/Matrix Concatenate1' incorporates:
         *  Concatenate: '<S1469>/Matrix Concatenate'
         */
        memcpy(&Model_Target_Medusa5H1Part3_B.MatrixConcatenate1_j[0],
               &Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[0], 96U
               * sizeof(real32_T));
        for (writeIndex = 0; writeIndex < 32; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S1518>/Submatrix3' incorporates:
             *  Buffer: '<S1205>/BufferOut'
             *  Concatenate: '<S1469>/Matrix Concatenate2'
             */
            Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[writeIndex] =
                Model_Target_B.BufferOut_c[writeIndex + 32];

            /* S-Function (sdspsubmtrx): '<S1518>/Submatrix6' incorporates:
             *  Buffer: '<S1205>/BufferOut'
             *  Concatenate: '<S1469>/Matrix Concatenate2'
             */
            Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[writeIndex +
                32] = Model_Target_B.BufferOut_c[writeIndex + 128];

            /* S-Function (sdspsubmtrx): '<S1518>/Submatrix7' incorporates:
             *  Buffer: '<S1205>/BufferOut'
             *  Concatenate: '<S1469>/Matrix Concatenate2'
             */
            Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[writeIndex +
                64] = Model_Target_B.BufferOut_c[writeIndex + 160];
        }

        /* SignalConversion generated from: '<S1469>/Matrix Concatenate1' incorporates:
         *  Concatenate: '<S1469>/Matrix Concatenate2'
         */
        memcpy(&Model_Target_Medusa5H1Part3_B.MatrixConcatenate1_j[96],
               &Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[0], 96U *
               sizeof(real32_T));

        /* Math: '<S1482>/Transpose1' incorporates:
         *  DataStoreRead: '<S1482>/Data Store Read'
         */
        for (i = 0; i < 2; i++)
        {
            for (colIdx = 0; colIdx < 6; colIdx++)
            {
                PremixMatrix_m[colIdx + 6 * i] =
                    Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS[(colIdx <<
                    1) + i];
            }
        }

        for (i = 0; i < 12; i++)
        {
            rtb_Transpose1_o_0[i] = PremixMatrix_m[i];
        }

        /* End of Math: '<S1482>/Transpose1' */

        /* Product: '<S1482>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1469>/Matrix Concatenate1'
         *  Merge: '<S1166>/Merge1'
         */
        for (i = 0; i < 2; i++)
        {
            for (colIdx = 0; colIdx < 32; colIdx++)
            {
                sample = (i << 5) + colIdx;
                audioOut[sample] = 0.0F;
                for (writeIndex = 0; writeIndex < 6; writeIndex++)
                {
                    audioOut[sample] +=
                        Model_Target_Medusa5H1Part3_B.MatrixConcatenate1_j
                        [(writeIndex << 5) + colIdx] * rtb_Transpose1_o_0[6 * i
                        + writeIndex];
                }
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge1[0], &audioOut[0], sizeof
               (real32_T) << 6U);

        /* End of Product: '<S1482>/Matrix Multiply1' */

        /* MATLAB Function: '<S1483>/process' */
        Model_Target_process(&Model_Target_Medusa5H1Part3_DW.FRM_Freeze_CS,
                             Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS,
                             Model_Target_Medusa5H1Part3_DW.FRM_frameCount_CS,
                             Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_CS,
                             Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS);

        /* Math: '<S1494>/Transpose1' incorporates:
         *  DataStoreRead: '<S1494>/Data Store Read'
         */
        for (i = 0; i < 10; i++)
        {
            PremixMatrix_i[3 * i] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i];
            PremixMatrix_i[3 * i + 1] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i + 10];
            PremixMatrix_i[3 * i + 2] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i + 20];
        }

        memcpy(&PremixMatrix_e[0], &PremixMatrix_i[0], 30U * sizeof(real32_T));

        /* Product: '<S1494>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1469>/Matrix Concatenate'
         *  Math: '<S1494>/Transpose1'
         *  Merge: '<S1166>/Merge1'
         */
        for (i = 0; i < 10; i++)
        {
            for (colIdx = 0; colIdx < 32; colIdx++)
            {
                writeIndex = (i << 5) + colIdx;
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    = 0.0F;
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i] *
                    Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[colIdx];
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i + 1] *
                    Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[colIdx
                    + 32];
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i + 2] *
                    Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[colIdx
                    + 64];
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge1[64],
               &Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[0], 320U *
               sizeof(real32_T));

        /* End of Product: '<S1494>/Matrix Multiply1' */

        /* MATLAB Function: '<S1495>/process' */
        Model_Target_process_o(&Model_Target_Medusa5H1Part3_DW.FRM_Freeze_Left,
                               Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left,
                               Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Left,
                               Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Left,
                               Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left);

        /* Math: '<S1506>/Transpose1' incorporates:
         *  DataStoreRead: '<S1506>/Data Store Read'
         */
        for (i = 0; i < 10; i++)
        {
            PremixMatrix_i[3 * i] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i];
            PremixMatrix_i[3 * i + 1] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i + 10];
            PremixMatrix_i[3 * i + 2] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i + 20];
        }

        memcpy(&PremixMatrix_e[0], &PremixMatrix_i[0], 30U * sizeof(real32_T));

        /* Product: '<S1506>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1469>/Matrix Concatenate2'
         *  Math: '<S1506>/Transpose1'
         *  Merge: '<S1166>/Merge1'
         */
        for (i = 0; i < 10; i++)
        {
            for (colIdx = 0; colIdx < 32; colIdx++)
            {
                writeIndex = (i << 5) + colIdx;
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    = 0.0F;
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i] *
                    Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[colIdx];
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i + 1] *
                    Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[colIdx
                    + 32];
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i + 2] *
                    Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[colIdx
                    + 64];
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge1[384],
               &Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[0], 320U *
               sizeof(real32_T));

        /* End of Product: '<S1506>/Matrix Multiply1' */

        /* MATLAB Function: '<S1507>/process' */
        Model_Target_process_i(&Model_Target_Medusa5H1Part3_DW.FRM_Freeze_Right,
                               Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right,
                               Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Right,
                               Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Right,
                               Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right);

        /* MATLAB Function: '<S1644>/Fade_Trigger_Generation' incorporates:
         *  Abs: '<S1644>/Abs'
         *  Abs: '<S1644>/Abs1'
         *  Delay: '<S1644>/Delay'
         *  Delay: '<S1644>/Delay1'
         *  Sum: '<S1644>/Add'
         *  Sum: '<S1644>/Subtract1'
         *  Sum: '<S1644>/Subtract2'
         */
        Model_Target_Fade_Trigger_Generation(qhmath_abs_f
            (Model_Target_Medusa5H1Part3_B.Selector_p -
             Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_p) + qhmath_abs_f
            (Model_Target_Medusa5H1Part3_B.Selector2 -
             Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_o),
            &(Model_Target_PreAmp0.MedusaVLSDrvGainsDownmixWeights[0]),
            Model_Target_Medusa5H1Part3_B.Selector_p,
            Model_Target_PreAmp0.MedusaVLSDrvGainsForwardDownmixThreshold,
            Model_Target_PreAmp0.MedusaVLSDrvGainsForwardDownmixMax,
            Model_Target_Medusa5H1Part3_B.Selector2,
            Model_Target_PreAmp0.MedusaVLSDrvGainsBackwardDownmixThreshold,
            Model_Target_PreAmp0.MedusaVLSDrvGainsBackwardDownmixMax,
            &Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_n);
        for (i = 0; i < 12; i++)
        {
            /* Sum: '<S1646>/Add' incorporates:
             *  Constant: '<S1646>/Constant'
             *  DataStoreRead: '<S1657>/Data Store Read'
             *  Product: '<S1646>/Matrix Multiply'
             *  Product: '<S1655>/Matrix Multiply'
             *  Sum: '<S1646>/Subtract'
             */
            PremixMatrix_m[i] = (1.0F -
                                 Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_n.downmix)
                * Model_Target_Medusa5H1Part3_DW.VLSDrv_SLCGain[i] +
                Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_n.MatrixMultiply
                [i];
        }

        /* MATLAB Function: '<S1647>/MATLAB Function' */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Generate Ramp Trigger/MATLAB Function': '<S1664>:1' */
        /* '<S1664>:1:3' rampOn = 0; */
        /*  DEBUG parameter */
        /*  Trigger ramping if SLC OR Fade is triggered */
        /* '<S1664>:1:6' if(SLC_On || Fade_On) */
        if (rtb_SLC_On ||
                Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_n.fadeOn)
        {
            /* MATLAB Function: '<S1656>/control' */
            /* MATLAB Function: '<S1656>/control' */
            /* '<S1664>:1:7' rampOn = 1; */
            /* '<S1664>:1:8' ramp(); */
            Model_Target_control_as(PremixMatrix_m,
                                    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                    &Model_Target_Medusa5H1Part3_DW.VLSDrv_Freeze,
                                    Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain,
                                    Model_Target_Medusa5H1Part3_DW.VLSDrv_frameCount,
                                    Model_Target_Medusa5H1Part3_DW.VLSDrv_rampCoeff,
                                    Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain);
        }

        /* End of MATLAB Function: '<S1647>/MATLAB Function' */
        for (i = 0; i < 12; i++)
        {
            /* Merge: '<S1166>/Merge2' incorporates:
             *  DataStoreRead: '<S1646>/Mixing Gains'
             */
            Model_Target_Medusa5H1Part3_B.Merge2[i] =
                Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain[i];
        }

        /* MATLAB Function: '<S1656>/process' */
        Model_Target_process_c(&Model_Target_Medusa5H1Part3_DW.VLSDrv_Freeze,
                               Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain,
                               Model_Target_Medusa5H1Part3_DW.VLSDrv_frameCount,
                               Model_Target_Medusa5H1Part3_DW.VLSDrv_rampCoeff,
                               Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain);

        /* MATLAB Function: '<S1669>/Fade_Trigger_Generation' incorporates:
         *  Abs: '<S1669>/Abs'
         *  Abs: '<S1669>/Abs1'
         *  Delay: '<S1669>/Delay'
         *  Delay: '<S1669>/Delay1'
         *  Sum: '<S1669>/Add'
         *  Sum: '<S1669>/Subtract1'
         *  Sum: '<S1669>/Subtract2'
         */
        Model_Target_Fade_Trigger_Generation(qhmath_abs_f
            (Model_Target_Medusa5H1Part3_B.Selector_p -
             Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_e) + qhmath_abs_f
            (Model_Target_Medusa5H1Part3_B.Selector2 -
             Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_n),
            &(Model_Target_PreAmp0.MedusaVLSPaxGainsDownmixWeights[0]),
            Model_Target_Medusa5H1Part3_B.Selector_p,
            Model_Target_PreAmp0.MedusaVLSPaxGainsForwardDownmixThreshold,
            Model_Target_PreAmp0.MedusaVLSPaxGainsForwardDownmixMax,
            Model_Target_Medusa5H1Part3_B.Selector2,
            Model_Target_PreAmp0.MedusaVLSPaxGainsBackwardDownmixThreshold,
            Model_Target_PreAmp0.MedusaVLSPaxGainsBackwardDownmixMax,
            &Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_a);
        for (i = 0; i < 12; i++)
        {
            /* Sum: '<S1671>/Add' incorporates:
             *  Constant: '<S1671>/Constant'
             *  DataStoreRead: '<S1682>/Data Store Read'
             *  Product: '<S1671>/Matrix Multiply'
             *  Product: '<S1680>/Matrix Multiply'
             *  Sum: '<S1671>/Subtract'
             */
            PremixMatrix_m[i] = (1.0F -
                                 Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_a.downmix)
                * Model_Target_Medusa5H1Part3_DW.VLSPax_SLCGain[i] +
                Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_a.MatrixMultiply
                [i];
        }

        /* MATLAB Function: '<S1672>/MATLAB Function' */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Generate Ramp Trigger/MATLAB Function': '<S1689>:1' */
        /* '<S1689>:1:3' rampOn = 0; */
        /*  DEBUG parameter */
        /*  Trigger ramping if SLC OR Fade is triggered */
        /* '<S1689>:1:6' if(SLC_On || Fade_On) */
        if (rtb_SLC_On ||
                Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_a.fadeOn)
        {
            /* MATLAB Function: '<S1681>/control' */
            /* MATLAB Function: '<S1681>/control' */
            /* '<S1689>:1:7' rampOn = 1; */
            /* '<S1689>:1:8' ramp(); */
            Model_Target_control_j(PremixMatrix_m,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.VLSPax_Freeze,
                                   Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain,
                                   Model_Target_Medusa5H1Part3_DW.VLSPax_frameCount,
                                   Model_Target_Medusa5H1Part3_DW.VLSPax_rampCoeff,
                                   Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain);
        }

        /* End of MATLAB Function: '<S1672>/MATLAB Function' */
        for (i = 0; i < 12; i++)
        {
            /* Merge: '<S1166>/Merge3' incorporates:
             *  DataStoreRead: '<S1671>/Mixing Gains'
             */
            Model_Target_Medusa5H1Part3_B.Merge3[i] =
                Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain[i];
        }

        /* MATLAB Function: '<S1681>/process' */
        Model_Target_process_e(&Model_Target_Medusa5H1Part3_DW.VLSPax_Freeze,
                               Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain,
                               Model_Target_Medusa5H1Part3_DW.VLSPax_frameCount,
                               Model_Target_Medusa5H1Part3_DW.VLSPax_rampCoeff,
                               Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain);

        /* End of Outputs for S-Function (RTC_NTF): '<S1627>/NTF Trigger' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1166>/Bypass' incorporates:
         *  ActionPort: '<S1428>/Action Port'
         */
        /* Merge: '<S1166>/Merge' incorporates:
         *  SignalConversion generated from: '<S1428>/PremixOut'
         */
        memset(&Model_Target_Medusa5H1Part3_B.Merge[0], 0, 192U * sizeof
               (real32_T));

        /* Merge: '<S1166>/Merge1' incorporates:
         *  SignalConversion generated from: '<S1428>/FRMixerOut'
         */
        memset(&Model_Target_Medusa5H1Part3_B.Merge1[0], 0, 704U * sizeof
               (real32_T));
        for (i = 0; i < 12; i++)
        {
            /* Merge: '<S1166>/Merge2' incorporates:
             *  SignalConversion generated from: '<S1428>/DgainsOut'
             */
            Model_Target_Medusa5H1Part3_B.Merge2[i] = 0.0F;

            /* Merge: '<S1166>/Merge3' incorporates:
             *  SignalConversion generated from: '<S1428>/PgainsOut'
             */
            Model_Target_Medusa5H1Part3_B.Merge3[i] = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1166>/Bypass' */
    }

    /* End of If: '<S1166>/If' */
    for (i = 0; i < 18; i++)
    {
        for (colIdx = 0; colIdx < 8; colIdx++)
        {
            /* Selector: '<S1431>/Selector' incorporates:
             *  Merge: '<S1166>/Merge'
             */
            Model_Target_Medusa5H1Part3_B.Selector[colIdx + (i << 3)] =
                Model_Target_Medusa5H1Part3_B.Merge[(tmp[i] << 3) + colIdx];
        }
    }

    for (i = 0; i < 6; i++)
    {
        for (colIdx = 0; colIdx < 8; colIdx++)
        {
            /* Selector: '<S1431>/Selector1' incorporates:
             *  Merge: '<S1166>/Merge'
             */
            Model_Target_Medusa5H1Part3_B.LoRoLsRsLsrRsr[colIdx + (i << 3)] =
                Model_Target_Medusa5H1Part3_B.Merge[(tmp_0[i] << 3) + colIdx];
        }
    }

    for (i = 0; i < 22; i++)
    {
        for (colIdx = 0; colIdx < 32; colIdx++)
        {
            /* Selector: '<S1431>/Selector4' incorporates:
             *  Merge: '<S1166>/Merge1'
             */
            Model_Target_Medusa5H1Part3_B.Selector4[colIdx + (i << 5)] =
                Model_Target_Medusa5H1Part3_B.Merge1[(tmp_1[i] << 5) + colIdx];
        }
    }

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1432>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1432>/NTF Trigger' */
}

/* Update for atomic system: '<S1137>/Medusa5H1 Part 3' */
void Model_Target_Medusa5H1Part3_Update(void)
{
    /* Update for If: '<S1166>/If' */
    if (Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem == 0)
    {
        /* Update for IfAction SubSystem: '<S1166>/On' incorporates:
         *  ActionPort: '<S1430>/Action Port'
         */
        /* Update for Delay: '<S1531>/Delay' */
        Model_Target_Medusa5H1Part3_DW.Delay_DSTATE =
            Model_Target_Medusa5H1Part3_B.Selector_p;

        /* Update for Delay: '<S1430>/Delay6' */
        Model_Target_Medusa5H1Part3_DW.Delay6_DSTATE[0] =
            Model_Target_B.sf_fade_l.tgtGains[0];
        Model_Target_Medusa5H1Part3_DW.Delay6_DSTATE[1] =
            Model_Target_B.sf_fade_l.tgtGains[1];

        /* Update for Delay: '<S1531>/Delay2' incorporates:
         *  Constant: '<S1430>/Constant3'
         */
        Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE = 0;

        /* Update for Delay: '<S1531>/Delay1' */
        Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE =
            Model_Target_Medusa5H1Part3_B.Selector2;

        /* Update for Delay: '<S1463>/Delay' */
        Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_c =
            Model_Target_Medusa5H1Part3_B.Selector_p;

        /* Update for Delay: '<S1463>/Delay2' incorporates:
         *  Constant: '<S1430>/Constant3'
         */
        Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE_k = 0;

        /* Update for Delay: '<S1463>/Delay1' */
        Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_m =
            Model_Target_Medusa5H1Part3_B.Selector2;

        /* Update for Delay: '<S1644>/Delay' */
        Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_p =
            Model_Target_Medusa5H1Part3_B.Selector_p;

        /* Update for Delay: '<S1644>/Delay1' */
        Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_o =
            Model_Target_Medusa5H1Part3_B.Selector2;

        /* Update for Delay: '<S1669>/Delay' */
        Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_e =
            Model_Target_Medusa5H1Part3_B.Selector_p;

        /* Update for Delay: '<S1669>/Delay1' */
        Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_n =
            Model_Target_Medusa5H1Part3_B.Selector2;

        /* End of Update for SubSystem: '<S1166>/On' */
    }

    /* End of Update for If: '<S1166>/If' */
}

/* Output and update for function-call system: '<S1716>/init' */
void InitTrigger_Model_141_472_249_99(void)
{
    /* MATLAB Function: '<S1713>/FirGenericInitFcn' */
    /* MATLAB Function: '<S1713>/FirGenericInitFcn' incorporates:
     *  Constant: '<S1704>/filterMapping'
     *  S-Function (TOP_MEX): '<S1711>/TOP2'
     *  S-Function (TOP_MEX): '<S1731>/TOP'
     *  Selector: '<S1431>/Selector'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1718>:1' */
    /* '<S1718>:1:3' init(); */
    /*  Generic FIR function to work with M inputs, N outputs and K filters */
    /*  */
    /*  Parameters: */
    /*    u:              input channels [frame size x number of inputs] */
    /*    CoeffsTarget:    coefficient sets [total filter lengths x 1] */
    /*    CoeffsLengths:  array of filter lengths [number of filters x 1] */
    /*    InputMapping:   zero-based input mapping for each filter  [number of outputs x 1] */
    /*    CoeffsMapping:  zero-based filter mapping for each filter [number of outputs x 1] */
    /*  */
    /*  Global parameters: */
    /*    States:         array of states [totalBufferSize x 1] */
    /*    CodeWorkMemory: working memory set up during roommode reset/init CRL */
    /*                    function call [codeWorkMemorySize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'Fir/Fir/TargetSpecific/FirGenericInitFcn': '<S1714>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1714>:1:18' [FrameSize, NumInputs]  = size(u); */
    /* '<S1714>:1:19' NumOutputs = numel(InputMapping); */
    /*  Get the work memory and states size */
    /* '<S1714>:1:25' WorkMemorySize = numel(CodeWorkMemory); */
    /* '<S1714>:1:26' StatesSize = numel(States); */
    /*  Set correct data types */
    /* '<S1714>:1:29' CoeffsLengths = uint32(CoeffsLengths); */
    /* '<S1714>:1:30' NumCoeffSets = uint32(numel(CoeffsLengths)); */
    /* '<S1714>:1:31' FrameSize = uint32(FrameSize); */
    /* '<S1714>:1:32' NumOutputs = uint32(NumOutputs); */
    /* '<S1714>:1:33' NumInputs = uint32(NumInputs); */
    /* '<S1714>:1:34' WorkMemorySize = uint32(WorkMemorySize); */
    /* '<S1714>:1:35' StatesSize = uint32(StatesSize); */
    /*  Reconstitute Variant */
    /* '<S1714>:1:38' VariantSelect = char(VariantUint8); */
    /* '<S1714>:1:40' switch(VariantSelect) */
    /* '<S1714>:1:52' case {'Hexagon'} */
    /* '<S1714>:1:53' y = fir_hexagon_init(u, CoeffsTarget, States, CoeffsLengths, InputMapping, CoeffsMapping, ... */
    /* '<S1714>:1:54'             FrameSize, NumCoeffSets, NumInputs, NumOutputs, CodeWorkMemory); */
    fir_init(&MedusaDrHoligramFirEqCodeWorkMemory[0],
             &Model_Target_Medusa5H1Part3_B.Selector[0],
             &MedusaDrHoligramFirEqCoeffsTarget[0],
             &MedusaDrHoligramFirEqStates[0],
             &(Model_Target_PreAmp0.MedusaDRHoligramPaddedFilterLengths[0]),
             &(Model_Target_PreAmp0.MedusaDRHoligramInputMapping[0]),
             &Model_Target_ConstP.filterMapping_Value[0], 8U, 66U, 18U, 66U,
             &MedusaDrHoligramFirEqCodeWorkMemory[0]);

    /* '<S1714>:1:55' CodeWorkMemory(1) = y; */
}

/* Output and update for function-call system: '<S1720>/init' */
void InitTrigger_Model_141_472_249_224(void)
{
    /* MATLAB Function: '<S1719>/SignalBreakFcn' */
    /* MATLAB Function: '<S1719>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1711>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1722>:1' */
    /* '<S1722>:1:3' init(); */
    /* MATLAB Function 'Fir/Fir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1721>:1' */
    /* '<S1721>:1:3' y = u; */
    memcpy(&MedusaDrHoligramFirEqCoeffsTarget[0],
           &(Model_Target_PreAmp1.MedusaDRHoligramFIRCoeffs[0]), 35112U * sizeof
           (real32_T));
}

/* Output and update for function-call system: '<S1727>/init' */
void InitTrigger_Model_141_472_254_172_156(void)
{
    /* MATLAB Function: '<S1726>/PoolIirInit' */
    /* MATLAB Function: '<S1726>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S1723>/TOP'
     *  S-Function (TOP_MEX): '<S1723>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1730>:1' */
    /* '<S1730>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1728>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1728>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1728>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1728>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1728>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1728>:1:28' else */
    /* '<S1728>:1:29' switch(VariantStr) */
    /* '<S1728>:1:30' case{"Hexagon"} */
    /* '<S1728>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1728>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1728>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaDrHoligramIirEq26171states[0],
                 &Model_Target_Medusa5H1Part4_B.y_k[0], 8U, 66U,
                 &(Model_Target_PreAmp0.MedusaDRHoligramPoolIirTunableConfigPooliirNumStages
                   [0]),
                 &(Model_Target_PreAmp0.MedusaDRHoligramPoolIirTunableConfigpooliirCoeffs
                   [0]), &MedusaDrHoligramIirEq26171states[0], 174257U, 0U,
                 5280U);

    /* '<S1728>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1738>/init' */
void InitTrigger_Model_141_473_11_172_156(void)
{
    /* MATLAB Function: '<S1737>/PoolIirInit' */
    /* MATLAB Function: '<S1737>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S1734>/TOP'
     *  S-Function (TOP_MEX): '<S1734>/TOP1'
     *  Selector: '<S1431>/Selector4'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1741>:1' */
    /* '<S1741>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1739>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1739>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1739>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1739>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1739>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1739>:1:28' else */
    /* '<S1739>:1:29' switch(VariantStr) */
    /* '<S1739>:1:30' case{"Hexagon"} */
    /* '<S1739>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1739>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1739>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&HoligramFrIir20562states[0],
                 &Model_Target_Medusa5H1Part3_B.Selector4[0], 32U, 22U,
                 &(Model_Target_PreAmp0.MedusaFRHoligramIirConfigPooliirNumStages
                   [0]),
                 &(Model_Target_PreAmp0.MedusaFRHoligramIirConfigpooliirCoeffs[0]),
                 &HoligramFrIir20562states[0], 7761U, 0U, 704U);

    /* '<S1739>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1749>/init' */
void InitTrigger_Model_141_595_232_99(void)
{
    /* MATLAB Function: '<S1746>/FirGenericInitFcn' */
    /* MATLAB Function: '<S1746>/FirGenericInitFcn' incorporates:
     *  Constant: '<S1706>/filterMapping'
     *  Constant: '<S1706>/filterMapping1'
     *  S-Function (TOP_MEX): '<S1706>/TOP2'
     *  Selector: '<S1431>/Selector1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1751>:1' */
    /* '<S1751>:1:3' init(); */
    /*  Generic FIR function to work with M inputs, N outputs and K filters */
    /*  */
    /*  Parameters: */
    /*    u:              input channels [frame size x number of inputs] */
    /*    CoeffsTarget:    coefficient sets [total filter lengths x 1] */
    /*    CoeffsLengths:  array of filter lengths [number of filters x 1] */
    /*    InputMapping:   zero-based input mapping for each filter  [number of outputs x 1] */
    /*    CoeffsMapping:  zero-based filter mapping for each filter [number of outputs x 1] */
    /*  */
    /*  Global parameters: */
    /*    States:         array of states [totalBufferSize x 1] */
    /*    CodeWorkMemory: working memory set up during roommode reset/init CRL */
    /*                    function call [codeWorkMemorySize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'Fir/Fir/TargetSpecific/FirGenericInitFcn': '<S1747>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1747>:1:18' [FrameSize, NumInputs]  = size(u); */
    /* '<S1747>:1:19' NumOutputs = numel(InputMapping); */
    /*  Get the work memory and states size */
    /* '<S1747>:1:25' WorkMemorySize = numel(CodeWorkMemory); */
    /* '<S1747>:1:26' StatesSize = numel(States); */
    /*  Set correct data types */
    /* '<S1747>:1:29' CoeffsLengths = uint32(CoeffsLengths); */
    /* '<S1747>:1:30' NumCoeffSets = uint32(numel(CoeffsLengths)); */
    /* '<S1747>:1:31' FrameSize = uint32(FrameSize); */
    /* '<S1747>:1:32' NumOutputs = uint32(NumOutputs); */
    /* '<S1747>:1:33' NumInputs = uint32(NumInputs); */
    /* '<S1747>:1:34' WorkMemorySize = uint32(WorkMemorySize); */
    /* '<S1747>:1:35' StatesSize = uint32(StatesSize); */
    /*  Reconstitute Variant */
    /* '<S1747>:1:38' VariantSelect = char(VariantUint8); */
    /* '<S1747>:1:40' switch(VariantSelect) */
    /* '<S1747>:1:52' case {'Hexagon'} */
    /* '<S1747>:1:53' y = fir_hexagon_init(u, CoeffsTarget, States, CoeffsLengths, InputMapping, CoeffsMapping, ... */
    /* '<S1747>:1:54'             FrameSize, NumCoeffSets, NumInputs, NumOutputs, CodeWorkMemory); */
    fir_init(&DrHeadrestFirEqCodeWorkMemory[0],
             &Model_Target_Medusa5H1Part3_B.LoRoLsRsLsrRsr[0],
             &DrHeadrestFirEqCoeffsTarget[0], &DrHeadrestFirEqStates[0],
             &(Model_Target_PreAmp0.MedusaHeadrestCompEQPaddedFilterLengths[0]),
             &Model_Target_ConstP.filterMapping1_Value[0],
             &Model_Target_ConstP.filterMapping_Value_a[0], 8U, 12U, 6U, 12U,
             &DrHeadrestFirEqCodeWorkMemory[0]);

    /* '<S1747>:1:55' CodeWorkMemory(1) = y; */
}

/* Output and update for function-call system: '<S1753>/init' */
void InitTrigger_Model_141_595_232_224(void)
{
    /* MATLAB Function: '<S1752>/SignalBreakFcn' */
    /* MATLAB Function: '<S1752>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1706>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1755>:1' */
    /* '<S1755>:1:3' init(); */
    /* MATLAB Function 'Fir/Fir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1754>:1' */
    /* '<S1754>:1:3' y = u; */
    memcpy(&DrHeadrestFirEqCoeffsTarget[0],
           &(Model_Target_PreAmp1.MedusaHeadrestCompEQFIRCoeffs[0]), 6384U *
           sizeof(real32_T));
}

/* Output and update for function-call system: '<S1760>/init' */
void InitTrigger_Model_141_595_237_172_156(void)
{
    /* MATLAB Function: '<S1759>/PoolIirInit' */
    /* MATLAB Function: '<S1759>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S1756>/TOP'
     *  S-Function (TOP_MEX): '<S1756>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1763>:1' */
    /* '<S1763>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1761>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1761>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1761>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1761>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1761>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1761>:1:28' else */
    /* '<S1761>:1:29' switch(VariantStr) */
    /* '<S1761>:1:30' case{"Hexagon"} */
    /* '<S1761>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1761>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1761>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&VlsHeadrestEq20140states[0], &Model_Target_Medusa5H1Part4_B.y
                 [0], 8U, 12U,
                 &(Model_Target_PreAmp0.MedusaHeadrestCompEQIirConfigPooliirNumStages
                   [0]),
                 &(Model_Target_PreAmp0.MedusaHeadrestCompEQIirConfigpooliirCoeffs
                   [0]), &VlsHeadrestEq20140states[0], 5777U, 0U, 960U);

    /* '<S1761>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1703>/REQ' */
void HandleReqPreAmpMedusaHoligramDisable(void)
{
    /* Outputs for Function Call SubSystem: '<S1167>/Enable State Write' */
    /* DataStoreWrite: '<S1701>/Data Store Write' incorporates:
     *  Constant: '<S1701>/Constant'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1767>:1' */
    /* '<S1767>:1:3' go(); */
    Model_Target_Medusa5H1Part4_DW.MedusaHoligramEnable = 0U;

    /* End of Outputs for SubSystem: '<S1167>/Enable State Write' */
}

/* Function for MATLAB Function: '<S1704>/Sum Channels' */
static void Model_Target_sum(const real32_T x_data[], const int32_T x_size[2],
    real32_T y[8])
{
    int32_T b_xj;
    int32_T i;
    int32_T xj;
    i = x_size[1];
    if (x_size[1] == 0)
    {
        for (i = 0; i < 8; i++)
        {
            y[i] = 0.0F;
        }
    }
    else
    {
        for (xj = 0; xj < 8; xj++)
        {
            y[xj] = x_data[xj];
        }

        for (xj = 2; xj <= i; xj++)
        {
            int32_T xoffset;
            xoffset = (xj - 1) << 3;
            for (b_xj = 0; b_xj < 8; b_xj++)
            {
                y[b_xj] += x_data[xoffset + b_xj];
            }
        }
    }
}

/* System initialize for atomic system: '<S1137>/Medusa5H1 Part 4' */
void Model_Target_Medusa5H1Part4_Init(void)
{
    /* Start for If: '<S1167>/If' */
    Model_Target_Medusa5H1Part4_DW.If_ActiveSubsystem = -1;

    /* Start for DataStoreMemory: '<S1167>/Data Store Memory' */
    Model_Target_Medusa5H1Part4_DW.MedusaHoligramEnable = 1U;

    /* SystemInitialize for IfAction SubSystem: '<S1167>/On' */

    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S1720>/ITC1' */
    InitTrigger_Model_141_472_249_224();

    /* InitTriggerControl '<S1716>/ITC1' */
    InitTrigger_Model_141_472_249_99();

    /* InitTriggerControl '<S1727>/ITC1' */
    InitTrigger_Model_141_472_254_172_156();

    /* InitTriggerControl '<S1753>/ITC1' */
    InitTrigger_Model_141_595_232_224();

    /* InitTriggerControl '<S1749>/ITC1' */
    InitTrigger_Model_141_595_232_99();

    /* InitTriggerControl '<S1760>/ITC1' */
    InitTrigger_Model_141_595_237_172_156();

    /* InitTriggerControl '<S1738>/ITC1' */
    InitTrigger_Model_141_473_11_172_156();

    /* End of SystemInitialize for SubSystem: '<S1167>/On' */
}

/* Output and update for atomic system: '<S1137>/Medusa5H1 Part 4' */
void Model_Target_Medusa5H1Part4(void)
{
    int32_T delayChans[66];
    int32_T delayChans_0[12];
    int32_T rtb_Add_fzw_size[2];
    int32_T i;
    int32_T i_0;
    int32_T readIdx;
    int32_T writeIdx;
    real32_T rtb_y_cz[144];
    real32_T tmp[96];
    real32_T tmp_0[96];
    int8_T rtAction;
    int8_T rtPrevAction;

    /* If: '<S1167>/If' incorporates:
     *  DataStoreRead: '<S1167>/Enable State Read'
     */
    rtPrevAction = Model_Target_Medusa5H1Part4_DW.If_ActiveSubsystem;
    rtAction = (int8_T)(Model_Target_Medusa5H1Part4_DW.MedusaHoligramEnable <=
                        0U);
    Model_Target_Medusa5H1Part4_DW.If_ActiveSubsystem = rtAction;
    if ((rtPrevAction != rtAction) && (rtPrevAction == 0))
    {
    }

    if (rtAction == 0)
    {
        int32_T loop_ub;
        if (rtPrevAction != 0)
        {
        }

        /* S-Function (TOP_MEX): '<S1711>/TOP1' */
        /*  Generic FIR function to work with M inputs, N outputs and K filters */
        /*  */
        /*  Parameters: */
        /*    u:              input channels [frame size x number of inputs] */
        /*    CoeffsTarget:   coefficient sets, translated to target specfic format [total filter lengths x 1] */
        /*    CoeffsLengths:  array of filter lengths [number of filters x 1] */
        /*    InputMapping:   zero-based input mapping for each filter  [number of outputs x 1] */
        /*    CoeffsMapping:  zero-based filter mapping for each filter [number of outputs x 1] */
        /*    VariantStr:     string corresponding to the variant type */
        /*  */
        /*  Global parameters: */
        /*    States:         array of states [totalBufferSize x 1] */
        /*    CodeWorkMemory: working memory set up during roommode reset/init CRL */
        /*                    function call [codeWorkMemorySize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'Fir/Fir/TargetSpecific/FirGenericProcessFcn': '<S1715>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1715>:1:20' [FrameSize, ~]  = size(u); */
        /* '<S1715>:1:21' NumOutputs = numel(InputMapping); */
        /*  Define persistent variables for SharcPlusAccel Variant */
        /*  Set correct data types */
        /* '<S1715>:1:31' CoeffsLengths = uint32(CoeffsLengths); */
        /* '<S1715>:1:32' FrameSize = uint32(FrameSize); */
        /* '<S1715>:1:33' NumOutputs = uint32(NumOutputs); */
        /* '<S1715>:1:34' InputMapping = uint32(InputMapping); */
        /*  Reconstitute Variant */
        /* '<S1715>:1:37' VariantSelect = char(VariantUint8); */
        /*  Simulation */
        /* '<S1715>:1:40' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1715>:1:60' else */
        /* '<S1715>:1:61' switch(VariantSelect) */
        /* '<S1715>:1:67' case {'Hexagon'} */
        /* '<S1715>:1:68' y = fir_hexagon_process(u, CodeWorkMemory, NumOutputs); */
        /* MATLAB Function: '<S1704>/Delay Line Update' incorporates:
         *  S-Function (TOP_MEX): '<S1711>/TOP1'
         *  S-Function (TOP_MEX): '<S1731>/TOP'
         *  Selector: '<S1431>/Selector'
         */
        /*  Note: This block only reads 'states' to get the delayed samples. A */
        /*  separate function is responsible for writing to 'states' to update the  */
        /*  delay line Data Store Memory. Thus it is important to ensure all DSM   */
        /*  write happens before DSM read. */
        /*  */
        /*  This is different from pooldelay, as the delay for ALL channel is */
        /*  intentionally set to be the max amount to allow for 'double' sharing */
        /*  between FIR filter and delay buffer. */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 4/On/DR Mix Matrix with Hybrid Holigram EQ/Delay Line Update': '<S1707>:1' */
        /* '<S1707>:1:15' numOutput = numel(delayChans); */
        /* '<S1707>:1:16' [frameSize, numChannelIn] = size(u); */
        /* '<S1707>:1:17' y = single(zeros(frameSize, numOutput)); */
        /* '<S1707>:1:18' delayChans = int32(delayChans); */
        for (i = 0; i < 66; i++)
        {
            delayChans[i] = (int32_T)
                Model_Target_PreAmp0.MedusaDRHoligramFilterLengths[i];
        }

        /*  Write incoming input to delay line */
        /* '<S1707>:1:21' writeIdx = stateIndex; */
        writeIdx = Model_Target_Medusa5H1Part4_DW.stateIndex;

        /* '<S1707>:1:22' for sample = 1:frameSize */
        for (readIdx = 0; readIdx < 8; readIdx++)
        {
            /* '<S1707>:1:23' for i = 1:numChannelIn */
            for (i = 0; i < 18; i++)
            {
                /* '<S1707>:1:24' states(writeIdx+1,i) = u(sample, i); */
                PeripheralDelayBuffer[writeIdx + 660 * i] =
                    Model_Target_Medusa5H1Part3_B.Selector[(i << 3) + readIdx];

                /*  add 1 for Matlab indexing */
            }

            /* '<S1707>:1:26' writeIdx = circindex(writeIdx, int32(1), fixedDelayLength); */
            writeIdx = circindex(writeIdx, 1, Model_Target_fixedDelayLength);
        }

        /* '<S1707>:1:28' stateIndex = writeIdx; */
        Model_Target_Medusa5H1Part4_DW.stateIndex = writeIdx;

        /*  Read out values from delay line */
        /* '<S1707>:1:31' for i = 1:numOutput */
        for (writeIdx = 0; writeIdx < 66; writeIdx++)
        {
            /* '<S1707>:1:32' inputIdx = inputMapping(i); */
            /*  which input to delay */
            /* '<S1707>:1:33' delay = delayChans(i); */
            /*  delay amount */
            /* '<S1707>:1:34' offset = - (delay + frameSize); */
            /*  offset from start index */
            /* '<S1707>:1:35' readIdx = circindex(stateIndex, offset, fixedDelayLength); */
            readIdx = circindex(Model_Target_Medusa5H1Part4_DW.stateIndex,
                                -(delayChans[writeIdx] + 8),
                                Model_Target_fixedDelayLength);

            /* '<S1707>:1:37' for sample = 1:frameSize */
            for (i = 0; i < 8; i++)
            {
                /* '<S1707>:1:38' y(sample, i) = states(readIdx+1, inputIdx+1); */
                Model_Target_Medusa5H1Part4_B.y_k[i + (writeIdx << 3)] =
                    PeripheralDelayBuffer[660 * (int32_T)
                    Model_Target_PreAmp0.MedusaDRHoligramInputMapping[writeIdx]
                    + readIdx];

                /*  add 1 for Matlab indexing */
                /* '<S1707>:1:39' readIdx = circindex(readIdx, int32(1), fixedDelayLength); */
                readIdx = circindex(readIdx, 1, Model_Target_fixedDelayLength);
            }
        }

        /* End of MATLAB Function: '<S1704>/Delay Line Update' */
        /* MATLAB Function: '<S1713>/FirGenericProcessFcn' incorporates:
         *  Selector: '<S1431>/Selector'
         */
        /*  Process function for Pooliir */
        /*  */
        /*  Parameters: */
        /*    x:              input channels [frame size x number of inputs] */
        /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
        /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
        /*   */
        /*  Global parameters: */
        /*    states: working memory set up during roommode reset/init CRL */
        /*                    function call [StatesSize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1729>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1729>:1:15' [~, NumChannels] = size(x); */
        /*  Initialize variables */
        /* '<S1729>:1:20' VariantStr = char(VariantUint8); */
        /* '<S1729>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1729>:1:29' else */
        /* '<S1729>:1:30' switch(VariantStr) */
        /* '<S1729>:1:31' case{"Hexagon"} */
        /* '<S1729>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
        fir_process(&Model_Target_Medusa5H1Part4_B.Add_fzw[0],
                    &Model_Target_Medusa5H1Part3_B.Selector[0],
                    &MedusaDrHoligramFirEqCodeWorkMemory[0], 66U);

        /* MATLAB Function: '<S1726>/PoolIirProcess' */
        pooliir_process(&Model_Target_Medusa5H1Part4_B.rtb_Add_fzw_data[0],
                        &Model_Target_Medusa5H1Part4_B.y_k[0],
                        &MedusaDrHoligramIirEq26171states[0]);

        /* Sum: '<S1704>/Add' incorporates:
         *  MATLAB Function: '<S1713>/FirGenericProcessFcn'
         *  MATLAB Function: '<S1726>/PoolIirProcess'
         */
        for (i = 0; i < 528; i++)
        {
            Model_Target_Medusa5H1Part4_B.Add_fzw[i] +=
                Model_Target_Medusa5H1Part4_B.rtb_Add_fzw_data[i];
        }

        /* End of Sum: '<S1704>/Add' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1720>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1716>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1727>/ITC1' */
        /* MATLAB Function: '<S1704>/Sum Channels' incorporates:
         *  S-Function (TOP_MEX): '<S1732>/TOP'
         *  Sum: '<S1704>/Add'
         */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 4/On/DR Mix Matrix with Hybrid Holigram EQ/Sum Channels': '<S1710>:1' */
        /* '<S1710>:1:2' [frame_size, ~] = size(in); */
        /* '<S1710>:1:3' [num_output, ~] = size(startIdx); */
        /* '<S1710>:1:5' y = coder.nullcopy(single(zeros(frame_size, num_output))); */
        /* '<S1710>:1:6' for iter = 1:num_output-1 */
        for (writeIdx = 0; writeIdx < 17; writeIdx++)
        {
            real32_T tmp_1;

            /* '<S1710>:1:7' start_idx = startIdx(iter); */
            /* '<S1710>:1:8' end_idx = startIdx(iter+1)-1; */
            /* '<S1710>:1:9' y(:,iter) = sum(in(:,start_idx+1:end_idx+1),2); */
            tmp_1 = (Model_Target_PreAmp0.MedusaDRHoligramOutputMapping[writeIdx
                     + 1] - 1.0F) + 1.0F;
            if (Model_Target_PreAmp0.MedusaDRHoligramOutputMapping[writeIdx] +
                    1.0F > tmp_1)
            {
                readIdx = 0;
                i = 0;
            }
            else
            {
                readIdx = (int32_T)
                    (Model_Target_PreAmp0.MedusaDRHoligramOutputMapping[writeIdx]
                     + 1.0F) - 1;
                i = (int32_T)tmp_1;
            }

            rtb_Add_fzw_size[0] = 8;
            loop_ub = i - readIdx;
            rtb_Add_fzw_size[1] = loop_ub;
            for (i = 0; i < loop_ub; i++)
            {
                for (i_0 = 0; i_0 < 8; i_0++)
                {
                    Model_Target_Medusa5H1Part4_B.rtb_Add_fzw_data[i_0 + (i << 3)]
                        = Model_Target_Medusa5H1Part4_B.Add_fzw[((readIdx + i) <<
                        3) + i_0];
                }
            }

            Model_Target_sum(Model_Target_Medusa5H1Part4_B.rtb_Add_fzw_data,
                             rtb_Add_fzw_size, &rtb_y_cz[writeIdx << 3]);
        }

        /* '<S1710>:1:11' start_idx = startIdx(end); */
        /* '<S1710>:1:12' y(:,end) = sum(in(:,start_idx+1:end),2); */
        if (Model_Target_PreAmp0.MedusaDRHoligramOutputMapping[17] + 1.0F >
                66.0F)
        {
            writeIdx = 0;
            readIdx = 0;
        }
        else
        {
            writeIdx = (int32_T)
                (Model_Target_PreAmp0.MedusaDRHoligramOutputMapping[17] + 1.0F)
                - 1;
            readIdx = 66;
        }

        rtb_Add_fzw_size[0] = 8;
        loop_ub = readIdx - writeIdx;
        rtb_Add_fzw_size[1] = loop_ub;
        for (i = 0; i < loop_ub; i++)
        {
            for (i_0 = 0; i_0 < 8; i_0++)
            {
                Model_Target_Medusa5H1Part4_B.rtb_Add_fzw_data[i_0 + (i << 3)] =
                    Model_Target_Medusa5H1Part4_B.Add_fzw[((writeIdx + i) << 3)
                    + i_0];
            }
        }

        Model_Target_sum(Model_Target_Medusa5H1Part4_B.rtb_Add_fzw_data,
                         rtb_Add_fzw_size, &rtb_y_cz[136]);

        /* End of MATLAB Function: '<S1704>/Sum Channels' */
        /* SignalConversion generated from: '<S1702>/PeripheralOut' incorporates:
         *  Concatenate: '<S1771>/Matrix Concatenate'
         */
        memcpy(&Model_Target_Medusa5H1Part5_B.MatrixConcatenate[0], &rtb_y_cz[0],
               144U * sizeof(real32_T));

        /* S-Function (TOP_MEX): '<S1706>/TOP1' */
        /*  Generic FIR function to work with M inputs, N outputs and K filters */
        /*  */
        /*  Parameters: */
        /*    u:              input channels [frame size x number of inputs] */
        /*    CoeffsTarget:   coefficient sets, translated to target specfic format [total filter lengths x 1] */
        /*    CoeffsLengths:  array of filter lengths [number of filters x 1] */
        /*    InputMapping:   zero-based input mapping for each filter  [number of outputs x 1] */
        /*    CoeffsMapping:  zero-based filter mapping for each filter [number of outputs x 1] */
        /*    VariantStr:     string corresponding to the variant type */
        /*  */
        /*  Global parameters: */
        /*    States:         array of states [totalBufferSize x 1] */
        /*    CodeWorkMemory: working memory set up during roommode reset/init CRL */
        /*                    function call [codeWorkMemorySize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'Fir/Fir/TargetSpecific/FirGenericProcessFcn': '<S1748>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1748>:1:20' [FrameSize, ~]  = size(u); */
        /* '<S1748>:1:21' NumOutputs = numel(InputMapping); */
        /*  Define persistent variables for SharcPlusAccel Variant */
        /*  Set correct data types */
        /* '<S1748>:1:31' CoeffsLengths = uint32(CoeffsLengths); */
        /* '<S1748>:1:32' FrameSize = uint32(FrameSize); */
        /* '<S1748>:1:33' NumOutputs = uint32(NumOutputs); */
        /* '<S1748>:1:34' InputMapping = uint32(InputMapping); */
        /*  Reconstitute Variant */
        /* '<S1748>:1:37' VariantSelect = char(VariantUint8); */
        /*  Simulation */
        /* '<S1748>:1:40' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1748>:1:60' else */
        /* '<S1748>:1:61' switch(VariantSelect) */
        /* '<S1748>:1:67' case {'Hexagon'} */
        /* '<S1748>:1:68' y = fir_hexagon_process(u, CodeWorkMemory, NumOutputs); */
        /* MATLAB Function: '<S1706>/Delay Line Update' incorporates:
         *  Constant: '<S1706>/filterMapping1'
         *  S-Function (TOP_MEX): '<S1706>/TOP1'
         *  Selector: '<S1431>/Selector1'
         */
        /*  Note: This block only reads 'states' to get the delayed samples. A */
        /*  separate function is responsible for writing to 'states' to update the  */
        /*  delay line Data Store Memory. Thus it is important to ensure all DSM   */
        /*  write happens before DSM read. */
        /*  */
        /*  This is different from pooldelay, as the delay for ALL channel is */
        /*  intentionally set to be the max amount to allow for 'double' sharing */
        /*  between FIR filter and delay buffer. */
        /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 4/On/Headrest Comp EQ/Delay Line Update': '<S1742>:1' */
        /* '<S1742>:1:15' numOutput = numel(delayChans); */
        /* '<S1742>:1:16' [frameSize, numChannelIn] = size(u); */
        /* '<S1742>:1:17' y = single(zeros(frameSize, numOutput)); */
        /* '<S1742>:1:18' delayChans = int32(delayChans); */
        for (i = 0; i < 12; i++)
        {
            delayChans_0[i] = (int32_T)
                Model_Target_PreAmp0.MedusaHeadrestCompEQFilterLengths[i];
        }

        /*  Write incoming input to delay line */
        /* '<S1742>:1:21' writeIdx = stateIndex; */
        writeIdx = Model_Target_Medusa5H1Part4_DW.stateIndex_e;

        /* '<S1742>:1:22' for sample = 1:frameSize */
        for (readIdx = 0; readIdx < 8; readIdx++)
        {
            /* '<S1742>:1:23' for i = 1:numChannelIn */
            for (i = 0; i < 6; i++)
            {
                /* '<S1742>:1:24' states(writeIdx+1,i) = u(sample, i); */
                Model_Target_Medusa5H1Part4_DW.states[writeIdx + 540 * i] =
                    Model_Target_Medusa5H1Part3_B.LoRoLsRsLsrRsr[(i << 3) +
                    readIdx];

                /*  add 1 for Matlab indexing */
            }

            /* '<S1742>:1:26' writeIdx = circindex(writeIdx, int32(1), fixedDelayLength); */
            writeIdx = circindex(writeIdx, 1, Model_Target_fixedDelayLength_l);
        }

        /* '<S1742>:1:28' stateIndex = writeIdx; */
        Model_Target_Medusa5H1Part4_DW.stateIndex_e = writeIdx;

        /*  Read out values from delay line */
        /* '<S1742>:1:31' for i = 1:numOutput */
        for (writeIdx = 0; writeIdx < 12; writeIdx++)
        {
            /* '<S1742>:1:32' inputIdx = inputMapping(i); */
            /*  which input to delay */
            /* '<S1742>:1:33' delay = delayChans(i); */
            /*  delay amount */
            /* '<S1742>:1:34' offset = - (delay + frameSize); */
            /*  offset from start index */
            /* '<S1742>:1:35' readIdx = circindex(stateIndex, offset, fixedDelayLength); */
            readIdx = circindex(Model_Target_Medusa5H1Part4_DW.stateIndex_e,
                                -(delayChans_0[writeIdx] + 8),
                                Model_Target_fixedDelayLength_l);

            /* '<S1742>:1:37' for sample = 1:frameSize */
            for (i = 0; i < 8; i++)
            {
                /* '<S1742>:1:38' y(sample, i) = states(readIdx+1, inputIdx+1); */
                Model_Target_Medusa5H1Part4_B.y[i + (writeIdx << 3)] =
                    Model_Target_Medusa5H1Part4_DW.states[540 * (int32_T)
                    Model_Target_ConstP.filterMapping1_Value[writeIdx] + readIdx];

                /*  add 1 for Matlab indexing */
                /* '<S1742>:1:39' readIdx = circindex(readIdx, int32(1), fixedDelayLength); */
                readIdx = circindex(readIdx, 1, Model_Target_fixedDelayLength_l);
            }
        }

        /* End of MATLAB Function: '<S1706>/Delay Line Update' */
        /* MATLAB Function: '<S1746>/FirGenericProcessFcn' incorporates:
         *  Selector: '<S1431>/Selector1'
         */
        /*  Process function for Pooliir */
        /*  */
        /*  Parameters: */
        /*    x:              input channels [frame size x number of inputs] */
        /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
        /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
        /*   */
        /*  Global parameters: */
        /*    states: working memory set up during roommode reset/init CRL */
        /*                    function call [StatesSize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1762>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1762>:1:15' [~, NumChannels] = size(x); */
        /*  Initialize variables */
        /* '<S1762>:1:20' VariantStr = char(VariantUint8); */
        /* '<S1762>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1762>:1:29' else */
        /* '<S1762>:1:30' switch(VariantStr) */
        /* '<S1762>:1:31' case{"Hexagon"} */
        /* '<S1762>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
        fir_process(&tmp[0], &Model_Target_Medusa5H1Part3_B.LoRoLsRsLsrRsr[0],
                    &DrHeadrestFirEqCodeWorkMemory[0], 12U);

        /* MATLAB Function: '<S1759>/PoolIirProcess' */
        pooliir_process(&tmp_0[0], &Model_Target_Medusa5H1Part4_B.y[0],
                        &VlsHeadrestEq20140states[0]);

        /* Sum: '<S1706>/Add' incorporates:
         *  Concatenate: '<S1771>/Matrix Concatenate'
         *  MATLAB Function: '<S1746>/FirGenericProcessFcn'
         *  MATLAB Function: '<S1759>/PoolIirProcess'
         */
        for (i = 0; i < 96; i++)
        {
            Model_Target_Medusa5H1Part5_B.MatrixConcatenate[i + 152] = tmp[i] +
                tmp_0[i];
        }

        /* End of Sum: '<S1706>/Add' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1753>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1749>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1760>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1738>/ITC1' */

        /* MATLAB Function: '<S1737>/PoolIirProcess' incorporates:
         *  Selector: '<S1431>/Selector4'
         */
        /*  Process function for Pooliir */
        /*  */
        /*  Parameters: */
        /*    x:              input channels [frame size x number of inputs] */
        /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
        /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
        /*   */
        /*  Global parameters: */
        /*    states: working memory set up during roommode reset/init CRL */
        /*                    function call [StatesSize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1740>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1740>:1:15' [~, NumChannels] = size(x); */
        /*  Initialize variables */
        /* '<S1740>:1:20' VariantStr = char(VariantUint8); */
        /* '<S1740>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1740>:1:29' else */
        /* '<S1740>:1:30' switch(VariantStr) */
        /* '<S1740>:1:31' case{"Hexagon"} */
        /* '<S1740>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
        pooliir_process(&Model_Target_Medusa5H1Part4_B.y_iv[0],
                        &Model_Target_Medusa5H1Part3_B.Selector4[0],
                        &HoligramFrIir20562states[0]);

        /* Merge: '<S1167>/Merge2' incorporates:
         *  SignalConversion generated from: '<S1702>/FROut'
         */
        memcpy(&Model_Target_Medusa5H1Part4_B.Merge2[0],
               &Model_Target_Medusa5H1Part4_B.y_iv[0], 704U * sizeof(real32_T));

        /* End of Outputs for SubSystem: '<S1167>/On' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1167>/Bypass' incorporates:
         *  ActionPort: '<S1700>/Action Port'
         */
        /* SignalConversion generated from: '<S1700>/PeripheralOut' incorporates:
         *  Concatenate: '<S1771>/Matrix Concatenate'
         */
        memset(&Model_Target_Medusa5H1Part5_B.MatrixConcatenate[0], 0, 144U *
               sizeof(real32_T));

        /* SignalConversion generated from: '<S1700>/HeadrestOut' incorporates:
         *  Concatenate: '<S1771>/Matrix Concatenate'
         */
        memset(&Model_Target_Medusa5H1Part5_B.MatrixConcatenate[152], 0, 96U *
               sizeof(real32_T));

        /* Merge: '<S1167>/Merge2' incorporates:
         *  SignalConversion generated from: '<S1700>/FROut'
         */
        memset(&Model_Target_Medusa5H1Part4_B.Merge2[0], 0, 704U * sizeof
               (real32_T));

        /* End of Outputs for SubSystem: '<S1167>/Bypass' */
    }

    /* End of If: '<S1167>/If' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1703>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1703>/NTF Trigger' */
}

/* Output and update for function-call system: '<S1772>/REQ' */
void HandleReqPreAmpMedusaOverheadHoligramDisable(void)
{
    /* Outputs for Function Call SubSystem: '<S1168>/Triggered Subsystem' */
    /* DataStoreWrite: '<S1773>/Data Store Write' incorporates:
     *  Constant: '<S1773>/Constant'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1779>:1' */
    /* '<S1779>:1:3' go(); */
    Model_Target_Medusa5H1Part5_DW.MedusaOverheadHoligramEnable = 0.0;

    /* End of Outputs for SubSystem: '<S1168>/Triggered Subsystem' */
}

/* System initialize for atomic system: '<S1137>/Medusa5H1 Part 5' */
void Model_Target_Medusa5H1Part5_Init(void)
{
    /* Start for DataStoreMemory: '<S1168>/Data Store Memory' */
    Model_Target_Medusa5H1Part5_DW.MedusaOverheadHoligramEnable = 1.0;
}

/* Outputs for atomic system: '<S1137>/Medusa5H1 Part 5' */
void Model_Target_Medusa5H1Part5(void)
{
    int32_T i;
    int32_T i_0;
    static const int8_T tmp[30] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21,
        22, 23, 24, 25, 26, 27, 28, 29, 30
    };

    /* If: '<S1168>/If' incorporates:
     *  Constant: '<S1775>/Constant'
     *  DataStoreRead: '<S1168>/Data Store Read'
     */
    if (Model_Target_Medusa5H1Part5_DW.MedusaOverheadHoligramEnable > 0.0)
    {
        /* Outputs for IfAction SubSystem: '<S1168>/On' incorporates:
         *  ActionPort: '<S1771>/Action Port'
         */
        for (i = 0; i < 8; i++)
        {
            Model_Target_Medusa5H1Part5_B.MatrixConcatenate[i + 144] = 0.0F;
        }

        for (i = 0; i < 30; i++)
        {
            for (i_0 = 0; i_0 < 8; i_0++)
            {
                /* Merge: '<S1168>/Merge' incorporates:
                 *  Concatenate: '<S1771>/Matrix Concatenate'
                 *  Selector: '<S1771>/Selector'
                 */
                Model_Target_Medusa5H1Part5_B.Merge[i_0 + (i << 3)] =
                    Model_Target_Medusa5H1Part5_B.MatrixConcatenate[(tmp[i] << 3)
                    + i_0];
            }
        }

        /* Merge: '<S1168>/Merge1' incorporates:
         *  Constant: '<S1775>/Constant'
         *  Merge: '<S1167>/Merge2'
         *  SignalConversion generated from: '<S1771>/FRMixerOut'
         */
        memcpy(&Model_Target_Medusa5H1Part5_B.Merge1[0],
               &Model_Target_Medusa5H1Part4_B.Merge2[0], 704U * sizeof(real32_T));

        /* End of Outputs for SubSystem: '<S1168>/On' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1168>/Bypass' incorporates:
         *  ActionPort: '<S1770>/Action Port'
         */
        /* Merge: '<S1168>/Merge' incorporates:
         *  SignalConversion generated from: '<S1770>/DRBypass'
         */
        memset(&Model_Target_Medusa5H1Part5_B.Merge[0], 0, 240U * sizeof
               (real32_T));

        /* Merge: '<S1168>/Merge1' incorporates:
         *  SignalConversion generated from: '<S1770>/FRBypass'
         */
        memset(&Model_Target_Medusa5H1Part5_B.Merge1[0], 0, 704U * sizeof
               (real32_T));

        /* End of Outputs for SubSystem: '<S1168>/Bypass' */
    }

    /* End of If: '<S1168>/If' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1772>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1772>/NTF Trigger' */
}

/* System initialize for atomic system: '<S1137>/Medusa5H1 Part 6' */
void Model_Target_Medusa5H1Part6_Init(void)
{
    /* '<S1785>:1:18' delayIndex = int32(0); */
    /* '<S1786>:1:18' delayIndex = int32(0); */
}

/* Output and update for atomic system: '<S1137>/Medusa5H1 Part 6' */
void Model_Target_Medusa5H1Part6(void)
{
    int32_T bufferIndex;
    int32_T channel;
    int32_T sample;
    int32_T writeIndex;

    /* MATLAB Function: '<S1782>/MATLAB Function' incorporates:
     *  Merge: '<S1168>/Merge'
     *  S-Function (TOP_MEX): '<S1784>/TOP5'
     */
    /* [Param: maxDelay] */
    /* MATLAB Function 'MedusaTunableDelay/MATLAB Function': '<S1785>:1' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /*  figure out the frame size and channel count */
    /* '<S1785>:1:9' [frameSize, numChannels] = size(audioIn); */
    /* '<S1785>:1:10' frameSize = int32(frameSize); */
    /* '<S1785>:1:11' stateLen = int32(maxDelay)+frameSize; */
    /* '<S1785>:1:12' totalLen = int32(stateLen * numChannels); */
    /* '<S1785>:1:13' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1785>:1:17' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1785>:1:24' bufferIndex = delayIndex; */
    bufferIndex = Model_Target_Medusa5H1Part6_DW.delayIndex_j;

    /* '<S1785>:1:26' for channel = 1:numChannels */
    for (channel = 0; channel < 30; channel++)
    {
        /*  Save writeIndex for next channel */
        /* '<S1785>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(bufferIndex, 0, 10170);

        /* '<S1785>:1:31' for sample = 1:frameSize */
        for (sample = 0; sample < 8; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1785>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            DeciRateSpeakerDelay[writeIndex] =
                Model_Target_Medusa5H1Part5_B.Merge[(channel << 3) + sample];

            /*  increment write pointer */
            /* '<S1785>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 10170);
        }

        /*  Advance buffer index for next channel */
        /* '<S1785>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 339, 10170);
    }

    /*  Reset */
    /* '<S1785>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    bufferIndex = circindex(Model_Target_Medusa5H1Part6_DW.delayIndex_j, 8,
                            10170);

    /* '<S1785>:1:46' delayIndex = bufferIndex; */
    Model_Target_Medusa5H1Part6_DW.delayIndex_j = bufferIndex;

    /*  Read samples from delay line */
    /* '<S1785>:1:49' for channel = 1:numChannels */
    for (channel = 0; channel < 30; channel++)
    {
        /*  Setup read pointer */
        /* '<S1785>:1:52' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        writeIndex = circindex(bufferIndex,
                               -(Model_Target_PreAmp0.MedusaDRSpeakerDelay[channel]
                                + 8), 10170);

        /* '<S1785>:1:54' for sample = 1:frameSize */
        for (sample = 0; sample < 8; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1785>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_Medusa5H1Part6_B.audioOut_d[sample + (channel << 3)] =
                DeciRateSpeakerDelay[writeIndex];

            /*  increment write pointer */
            /* '<S1785>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 10170);
        }

        /*  Advance buffer index for next channel */
        /* '<S1785>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 339, 10170);
    }

    /* End of MATLAB Function: '<S1782>/MATLAB Function' */
    /* MATLAB Function: '<S1783>/MATLAB Function' incorporates:
     *  Merge: '<S1168>/Merge1'
     *  S-Function (TOP_MEX): '<S1784>/TOP3'
     */
    /* [Param: maxDelay] */
    /* MATLAB Function 'MedusaTunableDelay/MATLAB Function': '<S1786>:1' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /*  figure out the frame size and channel count */
    /* '<S1786>:1:9' [frameSize, numChannels] = size(audioIn); */
    /* '<S1786>:1:10' frameSize = int32(frameSize); */
    /* '<S1786>:1:11' stateLen = int32(maxDelay)+frameSize; */
    /* '<S1786>:1:12' totalLen = int32(stateLen * numChannels); */
    /* '<S1786>:1:13' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1786>:1:17' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1786>:1:24' bufferIndex = delayIndex; */
    bufferIndex = Model_Target_Medusa5H1Part6_DW.delayIndex;

    /* '<S1786>:1:26' for channel = 1:numChannels */
    for (channel = 0; channel < 22; channel++)
    {
        /*  Save writeIndex for next channel */
        /* '<S1786>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(bufferIndex, 0, 30822);

        /* '<S1786>:1:31' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1786>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            FullRateSpeakerDelay[writeIndex] =
                Model_Target_Medusa5H1Part5_B.Merge1[(channel << 5) + sample];

            /*  increment write pointer */
            /* '<S1786>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 30822);
        }

        /*  Advance buffer index for next channel */
        /* '<S1786>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 1401, 30822);
    }

    /*  Reset */
    /* '<S1786>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    bufferIndex = circindex(Model_Target_Medusa5H1Part6_DW.delayIndex, 32, 30822);

    /* '<S1786>:1:46' delayIndex = bufferIndex; */
    Model_Target_Medusa5H1Part6_DW.delayIndex = bufferIndex;

    /*  Read samples from delay line */
    /* '<S1786>:1:49' for channel = 1:numChannels */
    for (channel = 0; channel < 22; channel++)
    {
        /*  Setup read pointer */
        /* '<S1786>:1:52' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        writeIndex = circindex(bufferIndex,
                               -(Model_Target_PreAmp0.MedusaFRSpeakerDelay[channel]
                                + 32), 30822);

        /* '<S1786>:1:54' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1786>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_Medusa5H1Part6_B.audioOut[sample + (channel << 5)] =
                FullRateSpeakerDelay[writeIndex];

            /*  increment write pointer */
            /* '<S1786>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 30822);
        }

        /*  Advance buffer index for next channel */
        /* '<S1786>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 1401, 30822);
    }

    /* End of MATLAB Function: '<S1783>/MATLAB Function' */
}

/* Output and update for function-call system: '<S1813>/init' */
void InitTrigger_Model_1112_65(void)
{
    /* MATLAB Function: '<S1810>/FirEvenInit' */
    /* MATLAB Function: '<S1810>/FirEvenInit' incorporates:
     *  S-Function (TOP_MEX): '<S1806>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1814>:1' */
    /* '<S1814>:1:3' init(); */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenInit': '<S1811>:1' */
    /* '<S1811>:1:4' [FilterLength, NumFilters] = size(FlippedCoefficients); */
    /* '<S1811>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Simulation */
    /* '<S1811>:1:10' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1811>:1:12' else */
    /* '<S1811>:1:13' y = fireven_hexagon_init(uint32(FrameSize), uint32(NumChannels), uint32(NumFilters), uint32(FilterLength), single(FlippedCoefficients), uint32(CodeWorkMemory), uint32(MaxNumOfThreds)); */
    fireven_init(&NearWiggleCodeWorkMemory[0], 8U, 2U, 2U, 1024U,
                 &(Model_Target_PreAmp0.NearWiggleCoeffs[0]),
                 &NearWiggleCodeWorkMemory[0], 4U);

    /*  NOTE: The CRL mechanism requires an output for the function call, */
    /*  and appears to be optimized out if that return value isn't used.  */
    /*  This is a dummy operation to make sure CRL ends up in generated code */
    /* '<S1811>:1:17' CodeWorkMemory(1) = y; */
}

/*
 * Output and update for function-call system:
 *    '<S1974>/index to linear'
 *    '<S1975>/index to linear gain mapping'
 *    '<S1977>/index to linear'
 */
void Model_Target_indextolinear(real32_T rtu_scale, real32_T rtu_offset,
    uint32_T rtu_index, B_indextolinear_Model_Target_T *localB)
{
    /*  The midrange curve is configured as a piecewise linear plot, with */
    /*  configurable values of the maximum boost ('maxB') and maximum cut ('maxC') */
    /*  in dB.  */
    /*     dB ^ */
    /*        | */
    /*  maxB  ----------/ */
    /*        |        / */
    /*        |       / */
    /*   0    ------|---|----> index */
    /*        |   /128  255 */
    /*        |  / */
    /*  maxC  --/ */
    /*        | */
    /*  Hence, for any given index, the gain is calculated as a value in  */
    /*  between 0 and 1 for boost and 0 and -1 for cut. This will later be */
    /*  multiplied with the maxB or maxC to get the actual gain value.  */
    /*  (y - y1) / (x - x1) = (y1 - y2) / (x1 - x2) */
    /*  (y - 0) / (x - 128) = (0 - 1) / (128 - 255) */
    /*                    y = (x - 128)/127 */
    /*  'offset' represents the center point between boost and cut (i.e. 128) and */
    /*  'scale' represents how many intervals are available for boost/cut (i.e. 127) */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Bass/index to linear': '<S1986>:1' */
    /*  Apply the tuning calibration */
    /* '<S1986>:1:27' floatIndex = single(index); */
    /* '<S1986>:1:28' linearGain = single((floatIndex - offset) / scale); */
    localB->linearGain = qhmath_div_f((real32_T)rtu_index - rtu_offset,
        rtu_scale);

    /*  Ensure the result is between -1 and 1 */
    /* '<S1986>:1:31' linearGain = min(linearGain, 1); */
    localB->linearGain = fminf(localB->linearGain, 1.0F);

    /* '<S1986>:1:32' linearGain = max(linearGain, -1); */
    localB->linearGain = fmaxf(localB->linearGain, -1.0F);
}

/*
 * Output and update for function-call system:
 *    '<S1974>/ramp parameters'
 *    '<S1977>/ramp parameters'
 */
void Model_Target_rampparameters_g(real32_T rtu_data, uint32_T rtu_rampTimeRTC,
    uint32_T rtu_rampRateRTC, const real_T rtp_rampRateBounds[2], const real_T
    rtp_rampTimeBounds[2], B_rampparameters_Model_Target_k_T *localB)
{
    real32_T y;
    y = rtu_data;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Bass/ramp parameters': '<S1987>:1' */
    /*  Ramp time mentioned in the RTC message gets priority over the tune */
    /*  variable. Boundary conditions are also included based on BDSP values. */
    /*  If neither ramp time nor rate are given in the RTC message (i.e. both */
    /*  = 0), then the ramp time in the Tune variable is taken as the default */
    /*  value for that message. */
    /* '<S1987>:1:11' ramptime = single(data); */
    /* '<S1987>:1:12' rampRate = single(0); */
    localB->rampRate = 0.0F;

    /* '<S1987>:1:14' if (rampRateRTC) */
    if (rtu_rampRateRTC != 0U)
    {
        /* '<S1987>:1:15' rampRate = single(rampRateRTC); */
        /* '<S1987>:1:16' rampRate = max(rampRateBounds(1), rampRate); */
        /* '<S1987>:1:17' rampRate = min(rampRateBounds(2), rampRate); */
        localB->rampRate = fminf((real32_T)rtp_rampRateBounds[1], fmaxf
            ((real32_T)rtp_rampRateBounds[0], (real32_T)rtu_rampRateRTC));
    }

    /* '<S1987>:1:19' if (rampTimeRTC) */
    if (rtu_rampTimeRTC != 0U)
    {
        /* '<S1987>:1:20' ramptime = single(rampTimeRTC); */
        y = (real32_T)rtu_rampTimeRTC;
    }

    /* '<S1987>:1:22' ramptime = max(rampTimeBounds(1), ramptime); */
    /* '<S1987>:1:23' ramptime = min(rampTimeBounds(2), ramptime); */
    localB->ramptime = fminf((real32_T)rtp_rampTimeBounds[1], fmaxf((real32_T)
        rtp_rampTimeBounds[0], y));
}

/*
 * Output and update for function-call system:
 *    '<S1974>/SetDsm'
 *    '<S1974>/SetDsm1'
 */
void Model_Target_SetDsm_m(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S1979>/Data Store Write' incorporates:
     *  Constant: '<S1979>/Constant'
     */
    Model_TargetControlDsms.PreAmpBassFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1974>/tone control' */
void Model_Target_tonecontrol(real32_T rtu_boost_max_db, real32_T rtu_cut_max_db,
    real32_T rtu_normalized_gain_impact, real32_T rtu_db_per_sec, real32_T
    rtu_ramp_time_ms, real32_T rtu_sample_rate_in_hertz, real32_T rtu_frame_size)
{
    suFnE4DIYISSjYbtQHPXOwD_Model_Target_T phaseConfig[2];
    real32_T currentGain_tmp;
    real32_T currentImpact_db;
    real32_T db_diff;
    real32_T quantum_ms;
    real32_T targetEffectiveGain;
    real32_T targetImpact_db;
    real32_T x;
    boolean_T currentIsBoost;
    boolean_T targetIsBoost;

    /*  %inputs */
    /*  % inputs % parameters */
    /* parameters */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Bass/tone control': '<S1989>:1' */
    /*  See Control summary at the end: */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step now performed on canvas) */
    /*  Step 2a: IMPACT-TARGET Translate the normalized gain into a dB impact */
    /*  based on the maximum boost or cut values. */
    /*  ("-1" = maximum cut, "1" = maximum boost.) */
    /* '<S1989>:1:16' targetIsBoost = (normalized_gain_impact >= 0); */
    targetIsBoost = (rtu_normalized_gain_impact >= 0.0F);

    /* '<S1989>:1:17' if (targetIsBoost) */
    if (targetIsBoost)
    {
        /* '<S1989>:1:18' targetImpact_db = normalized_gain_impact * boost_max_db; */
        targetImpact_db = rtu_normalized_gain_impact * rtu_boost_max_db;

        /* '<S1989>:1:19' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(targetImpact_db *
            2.30258512F, 20.0F));

        /*  1 or greater */
    }
    else
    {
        /* '<S1989>:1:20' else */
        /* '<S1989>:1:21' targetImpact_db = normalized_gain_impact * cut_max_db; */
        targetImpact_db = rtu_normalized_gain_impact * rtu_cut_max_db;

        /* '<S1989>:1:22' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(targetImpact_db *
            2.30258512F, 20.0F));

        /*  less than 1 */
    }

    /* '<S1989>:1:25' actualTargetGainLinear = targetEffectiveGain; */
    /*  Step 2b: IMPACT-CURRENT Fetch the current gain from the previously */
    /*  active ramper. */
    /* '<S1989>:1:29' currentPhase = Phase; */
    /* '<S1989>:1:30' currentGain = Rampers(currentPhase).currentGain; */
    currentGain_tmp = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
        Model_TargetControlDsms.PreAmpBassPhase - 1].currentGain;

    /* '<S1989>:1:31' currentIsBoost = (currentGain >= 1); */
    currentIsBoost = (currentGain_tmp >= 1.0F);

    /* '<S1989>:1:32' currentImpact_db = db20(currentGain); */
    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    currentImpact_db = qhmath_log_f(qhmath_abs_f(currentGain_tmp)) * 8.68588924F;

    /*  Setup processing to continue on seamlessly while we work here */
    /* '<S1989>:1:35' Rampers(1).currentGain = currentGain; */
    /* '<S1989>:1:36' Phase = uint32(1); */
    Model_TargetControlDsms.PreAmpBassPhase = 1U;

    /*  reset phase to 1 */
    /*  Now that we have both current and target impacts, find the difference */
    /* '<S1989>:1:38' db_diff = abs(currentImpact_db - targetImpact_db); */
    db_diff = qhmath_abs_f(currentImpact_db - targetImpact_db);

    /*  Step 3a: TIME- If a slope in dB/second is provided, ignore the ramp time */
    /* '<S1989>:1:41' if (db_per_sec) */
    if (rtu_db_per_sec != 0.0F)
    {
        /* '<S1989>:1:42' ramp_ms = db_diff / single(db_per_sec) * 1000; */
        x = qhmath_div_f(db_diff, rtu_db_per_sec) * 1000.0F;
    }
    else
    {
        /* '<S1989>:1:43' else */
        /* '<S1989>:1:44' ramp_ms = single(ramp_time_ms); */
        x = rtu_ramp_time_ms;
    }

    /*  Step 3b: TIME- QUANTIZE the desired ramp time to our FrameSize.  */
    /* '<S1989>:1:48' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);

    /* '<S1989>:1:49' numFrames = ramp_ms / quantum_ms; */
    /* '<S1989>:1:50' numFrames = max (1, ceil(numFrames)); */
    x = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(x, quantum_ms)));

    /*  Step 4a: PHASES- Determine whether ramping from current gain to target */
    /*  gain requires a unity crossing in linear gain. */
    /* '<S1989>:1:54' isTwoPhase = (currentIsBoost ~= targetIsBoost) && ... */
    /* '<S1989>:1:55'              (currentGain ~= 1) && ... % cannot cross if you're already there */
    /* '<S1989>:1:56'              (targetImpact_db ~= 1); */
    /*  % cannot cross if you're already there */
    /*  no crossing needed when impact already nothing */
    /*  Setup a structure to hold information about what the rampers should do */
    /* '<S1989>:1:58' twoSingles = {single(0) single(0)}; */
    /* '<S1989>:1:59' phaseConfig = struct('frames',twoSingles,'target_linear',twoSingles,'current_linear',twoSingles); */
    /* '<S1989>:1:60' phaseConfig = tone_control_split(numFrames,currentImpact_db,db_diff,... */
    /* '<S1989>:1:61'     currentGain,currentIsBoost,rgain_SILENT_GAIN,targetIsBoost,... */
    /* '<S1989>:1:62'     targetEffectiveGain,isTwoPhase,phaseConfig); */
    /* '<S1989>:1:104' if (isTwoPhase) */
    if ((currentIsBoost != targetIsBoost) && (currentGain_tmp != 1.0F) &&
            (targetImpact_db != 1.0F))
    {
        /*  Both boost and cut phases will be required to get where we are going. */
        /*  Make sure we have at least two frames to work with: */
        /* '<S1989>:1:107' numFrames = max (2, round(numFrames)); */
        x = fmaxf(2.0F, x);

        /*  Divide up our ramp time into pieces for each phase to use */
        /* '<S1989>:1:110' phase1Frames = ceil(numFrames * abs(currentImpact_db) / db_diff); */
        targetImpact_db = qhmath_ceil_f(qhmath_div_f(x * qhmath_abs_f
            (currentImpact_db), db_diff));

        /* '<S1989>:1:111' phase2Frames = numFrames - phase1Frames; */
        /*  Make sure phase 2 has at least 1 frame to work with */
        /* '<S1989>:1:114' phase2Frames = max(1, phase2Frames); */
        phaseConfig[1].frames = fmaxf(1.0F, x - targetImpact_db);

        /*  Setup Phase 1 ramper that takes us to zero impact (i.e. unity gain) */
        /* '<S1989>:1:117' phaseConfig(1).current_linear   = currentGain; */
        phaseConfig[0].current_linear = currentGain_tmp;

        /*  we know this is not 1 */
        /* '<S1989>:1:118' phaseConfig(1).target_linear    = NudgeUnity(1,currentIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1989>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1989>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = 1.00000048F;
        }
        else
        {
            /* '<S1989>:1:96' else */
            /* '<S1989>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = 0.999999523F;
        }

        /* '<S1989>:1:119' phaseConfig(1).frames           = phase1Frames; */
        phaseConfig[0].frames = targetImpact_db;

        /*  Setup Phase 2 ramper that delivers us to target impact */
        /* '<S1989>:1:122' phaseConfig(2).current_linear   = NudgeUnity(1,targetIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1989>:1:94' if (isPositive) */
        if (targetIsBoost)
        {
            /* '<S1989>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].current_linear = 1.00000048F;
        }
        else
        {
            /* '<S1989>:1:96' else */
            /* '<S1989>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].current_linear = 0.999999523F;
        }

        /*  start quiet */
        /* '<S1989>:1:123' phaseConfig(2).target_linear    = targetEffectiveGain; */
        phaseConfig[1].target_linear = targetEffectiveGain;

        /*  we know this is not 0 */
        /* '<S1989>:1:124' phaseConfig(2).frames           = phase2Frames; */
    }
    else
    {
        /* '<S1989>:1:125' else */
        /*  Only one phase is needed to accomplish our goal. We are are the */
        /*  target side of unity... but we must determine which side that is */
        /* '<S1989>:1:128' if (currentGain == 1) */
        if (currentGain_tmp == 1.0F)
        {
            /*  One is in-between sides: use the target to determine the side */
            /* '<S1989>:1:130' isBoost = targetIsBoost; */
            currentIsBoost = targetIsBoost;
        }
        else
        {
            /* '<S1989>:1:131' else */
            /*  Current gain is already on one side of unity so use that */
            /* '<S1989>:1:133' isBoost = currentIsBoost; */
        }

        /* '<S1989>:1:135' phaseConfig(1).current_linear   = NudgeUnity(currentGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1989>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1989>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].current_linear = fmaxf(currentGain_tmp, 1.00000048F);

            /* '<S1989>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = fmaxf(targetEffectiveGain,
                1.00000048F);
        }
        else
        {
            /* '<S1989>:1:96' else */
            /* '<S1989>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].current_linear = fminf(currentGain_tmp, 0.999999523F);

            /* '<S1989>:1:96' else */
            /* '<S1989>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = fminf(targetEffectiveGain,
                0.999999523F);
        }

        /* '<S1989>:1:136' phaseConfig(1).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1989>:1:94' if (isPositive) */
        /* '<S1989>:1:137' phaseConfig(1).frames           = numFrames; */
        phaseConfig[0].frames = x;

        /*  Setup Phase 2 ramper to sit at the target gain */
        /* '<S1989>:1:140' phaseConfig(2).current_linear   = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1989>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1989>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            targetImpact_db = fmaxf(targetEffectiveGain, 1.00000048F);
            phaseConfig[1].current_linear = targetImpact_db;

            /* '<S1989>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].target_linear = targetImpact_db;
        }
        else
        {
            /* '<S1989>:1:96' else */
            /* '<S1989>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            targetImpact_db = fminf(targetEffectiveGain, 0.999999523F);
            phaseConfig[1].current_linear = targetImpact_db;

            /* '<S1989>:1:96' else */
            /* '<S1989>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].target_linear = targetImpact_db;
        }

        /* '<S1989>:1:141' phaseConfig(2).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1989>:1:94' if (isPositive) */
        /* '<S1989>:1:142' phaseConfig(2).frames           = single(0); */
        phaseConfig[1].frames = 0.0F;
    }

    /*  Step 4b: PHASES- Setup rampers for both phases */
    /* '<S1989>:1:65' for currentPhase=1:2 */
    /* '<S1989>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[0].frames != 0.0F)
    {
        /* '<S1989>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S1989>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S1989>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpBassRampers[0].rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[0].target_linear,
                phaseConfig[0].current_linear)), qhmath_div_f(quantum_ms *
               phaseConfig[0].frames * rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S1989>:1:70' else */
        /* '<S1989>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpBassRampers[0].rampCoeff = 1.0F;
    }

    /* '<S1989>:1:73' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S1989>:1:74' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpBassRampers[0].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S1989>:1:75' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpBassRampers[0].currentGain = phaseConfig[0].
        current_linear;

    /* '<S1989>:1:76' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpBassRampers[0].frameCount = (int32_T)
        phaseConfig[0].frames;

    /* '<S1989>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[1].frames != 0.0F)
    {
        /* '<S1989>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S1989>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S1989>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpBassRampers[1].rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[1].target_linear,
                phaseConfig[1].current_linear)), qhmath_div_f(quantum_ms *
               phaseConfig[1].frames * rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S1989>:1:70' else */
        /* '<S1989>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpBassRampers[1].rampCoeff = 1.0F;
    }

    /* '<S1989>:1:73' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S1989>:1:74' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpBassRampers[1].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S1989>:1:75' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpBassRampers[1].currentGain = phaseConfig[1].
        current_linear;

    /* '<S1989>:1:76' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpBassRampers[1].frameCount = (int32_T)
        phaseConfig[1].frames;

    /*  unfreeze the gain. (This step now performed on canvas) */
}

/* Output and update for function-call system: '<S1978>/REQ' */
void HandleReqPreAmpBassSet(void)
{
    /* MATLAB Function: '<S1974>/index to linear' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1993>:1' */
    /* '<S1993>:1:3' go(); */
    Model_Target_indextolinear(Model_Target_PreAmp0.BassScale,
        Model_Target_PreAmp0.BassOffset,
        Model_TargetPreAmpBassSetRtcOut.REQ_gain_index,
        &Model_Target_PreAmpPart1_B.sf_indextolinear);

    /* MATLAB Function: '<S1974>/ramp parameters' */
    Model_Target_rampparameters_g(Model_Target_PreAmp0.Bassramptime,
        Model_TargetPreAmpBassSetRtcOut.REQ_ramp_milliseconds,
        Model_TargetPreAmpBassSetRtcOut.REQ_ramp_db_per_second,
        Model_Target_ConstP.pooled1, Model_Target_ConstP.pooled2,
        &Model_Target_PreAmpPart1_B.sf_rampparameters);

    /* Outputs for Function Call SubSystem: '<S1974>/SetDsm' */
    Model_Target_SetDsm_m(1U);

    /* End of Outputs for SubSystem: '<S1974>/SetDsm' */

    /* MATLAB Function: '<S1974>/tone control' */
    /* MATLAB Function: '<S1974>/tone control' incorporates:
     *  S-Function (AudioStats_MEX): '<S1974>/Audio Stats'
     */
    Model_Target_tonecontrol(Model_Target_PreAmp0.BassBoostMaximum_dB,
        Model_Target_PreAmp0.BassCutMaximum_dB,
        Model_Target_PreAmpPart1_B.sf_indextolinear.linearGain,
        Model_Target_PreAmpPart1_B.sf_rampparameters.rampRate,
        Model_Target_PreAmpPart1_B.sf_rampparameters.ramptime,
        44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S1974>/SetDsm1' */
    Model_Target_SetDsm_m(0U);

    /* End of Outputs for SubSystem: '<S1974>/SetDsm1' */
}

/* Output and update for atomic system: '<S1974>/tone' */
void Model_Target_tone(const real32_T rtu_boost_coeffs[3], const real32_T
                       rtu_cut_coeffs[3], const real32_T rtu_audioIn[64],
                       B_tone_Model_Target_T *localB, DW_tone_Model_Target_T
                       *localDW)
{
    int32_T q0;
    int32_T qY;
    real32_T aCoeffs;
    real32_T bCoeffs_idx_0;
    real32_T bCoeffs_idx_1;
    real32_T gain;
    real32_T k;
    uint32_T ramper;

    /*     % inputs % parameters */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Bass/tone': '<S1988>:1' */
    /*  Data Store objects (registered in "Edit Data" dialog */
    /*  Keep memory for the filter persistent from frame to frame */
    /*  figure out the frame size and channel count */
    /* '<S1988>:1:15' [frame_size, channel_count] = size(audioIn); */
    /* '<S1988>:1:17' if (isempty(toneFilterStates)) */
    /*  set the size and datatype of the output buffer */
    /* '<S1988>:1:23' audioOut = coder.nullcopy(audioIn); */
    /* '<S1988>:1:25' ramper = Phase; */
    ramper = Model_TargetControlDsms.PreAmpBassPhase;

    /* '<S1988>:1:26' ramperCount = numel(Rampers); */
    /* '<S1988>:1:28' if (Freeze == false) */
    if (Model_TargetControlDsms.PreAmpBassFreeze == 0U)
    {
        /* '<S1988>:1:29' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                Model_TargetControlDsms.PreAmpBassPhase - 1].frameCount == 0)
        {
            /*  The current ramper is finished. Is there another one? */
            /* '<S1988>:1:31' if (ramper < ramperCount && Rampers(ramper+1).frameCount > 0) */
            if ((Model_TargetControlDsms.PreAmpBassPhase < 2U) &&
                    (Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                     Model_TargetControlDsms.PreAmpBassPhase].frameCount > 0))
            {
                /*  Yes - move on to the next phase */
                /* '<S1988>:1:33' ramper = ramper + 1; */
                qY = (int32_T)(Model_TargetControlDsms.PreAmpBassPhase +
                               /*MW:OvSatOk*/ 1U);
                ramper = Model_TargetControlDsms.PreAmpBassPhase + 1U;

                /* '<S1988>:1:34' Phase = ramper; */
                Model_TargetControlDsms.PreAmpBassPhase =
                    Model_TargetControlDsms.PreAmpBassPhase + 1U;

                /* '<S1988>:1:35' k = Rampers(ramper).rampCoeff; */
                k = Model_TargetControlDsms.PreAmpBassRampers[qY - 1].rampCoeff;

                /* '<S1988>:1:36' gain = Rampers(ramper).currentGain; */
                gain = Model_TargetControlDsms.PreAmpBassRampers[qY - 1].
                    currentGain;

                /* '<S1988>:1:37' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
                q0 = Model_TargetControlDsms.PreAmpBassRampers[qY - 1].
                    frameCount;
                if (q0 < -2147483647)
                {
                    Model_TargetControlDsms.PreAmpBassRampers[qY - 1].frameCount
                        = MIN_int32_T;
                }
                else
                {
                    Model_TargetControlDsms.PreAmpBassRampers[qY - 1].frameCount
                        = q0 - 1;
                }
            }
            else
            {
                /* '<S1988>:1:38' else */
                /*   Stop ramping and SNAP to the target */
                /* '<S1988>:1:40' k = single(1); */
                k = 1.0F;

                /* '<S1988>:1:41' gain = Rampers(ramper).targetGain; */
                gain = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpBassPhase - 1].targetGain;

                /*  Update completion flag */
            }
        }
        else
        {
            /* '<S1988>:1:44' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S1988>:1:46' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                Model_TargetControlDsms.PreAmpBassPhase - 1].rampCoeff;

            /* '<S1988>:1:47' gain = Rampers(ramper).currentGain; */
            gain = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                Model_TargetControlDsms.PreAmpBassPhase - 1].currentGain;

            /* '<S1988>:1:48' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            q0 = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                Model_TargetControlDsms.PreAmpBassPhase - 1].frameCount;
            if (q0 < -2147483647)
            {
                Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpBassPhase - 1].frameCount =
                    MIN_int32_T;
            }
            else
            {
                Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpBassPhase - 1].frameCount = q0
                    - 1;
            }
        }
    }
    else
    {
        /* '<S1988>:1:50' else */
        /*  Frozen. Stay at current gain */
        /* '<S1988>:1:52' k = single(1); */
        k = 1.0F;

        /* '<S1988>:1:53' gain = Rampers(ramper).currentGain; */
        gain = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
            Model_TargetControlDsms.PreAmpBassPhase - 1].currentGain;
    }

    /*  Apply the tone filter */
    /* '<S1988>:1:57' if (gain < 1) */
    if (gain < 1.0F)
    {
        /*  Cut */
        /* '<S1988>:1:59' bCoeffs = cut_coeffs(1:2); */
        bCoeffs_idx_0 = rtu_cut_coeffs[0];
        bCoeffs_idx_1 = rtu_cut_coeffs[1];

        /* '<S1988>:1:60' aCoeffs = cut_coeffs(3); */
        aCoeffs = rtu_cut_coeffs[2];
    }
    else
    {
        /* '<S1988>:1:61' else */
        /*  Boost */
        /* '<S1988>:1:63' bCoeffs = boost_coeffs(1:2); */
        bCoeffs_idx_0 = rtu_boost_coeffs[0];
        bCoeffs_idx_1 = rtu_boost_coeffs[1];

        /* '<S1988>:1:64' aCoeffs = boost_coeffs(3); */
        aCoeffs = rtu_boost_coeffs[2];
    }

    /*  [filtered,toneFilterStates] = filter(bCoeffs, aCoeffs, audioIn, toneFilterStates); */
    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S1988>:1:70' for n=1:frame_size */
    for (q0 = 0; q0 < 32; q0++)
    {
        real32_T filterOut;
        real32_T filterOut_tmp;

        /*  Update the gain and then subtract one before applying it to the */
        /*  filtered signal. Disregarding phase shifting  */
        /* '<S1988>:1:73' gain = gain * k; */
        gain *= k;

        /* '<S1988>:1:74' filterGain = gain - 1; */
        /*  Loop through channels adding in gain-adjusted filtered samples */
        /* '<S1988>:1:76' for chanIdx = 1:channel_count */
        /* '<S1988>:1:78' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(chanIdx); */
        filterOut = bCoeffs_idx_0 * rtu_audioIn[q0] + localDW->toneFilterStates
            [0];

        /* '<S1988>:1:79' toneFilterStates(chanIdx) = (bCoeffs(2) * audioIn(n,chanIdx)) + (aCoeffs(1) * filterOut); */
        localDW->toneFilterStates[0] = bCoeffs_idx_1 * rtu_audioIn[q0] + aCoeffs
            * filterOut;

        /* '<S1988>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0] = (gain - 1.0F) * filterOut + rtu_audioIn[q0];

        /* '<S1988>:1:78' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(chanIdx); */
        filterOut_tmp = rtu_audioIn[q0 + 32];
        filterOut = filterOut_tmp * bCoeffs_idx_0 + localDW->toneFilterStates[1];

        /* '<S1988>:1:79' toneFilterStates(chanIdx) = (bCoeffs(2) * audioIn(n,chanIdx)) + (aCoeffs(1) * filterOut); */
        localDW->toneFilterStates[1] = filterOut_tmp * bCoeffs_idx_1 + aCoeffs *
            filterOut;

        /* '<S1988>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0 + 32] = (gain - 1.0F) * filterOut + filterOut_tmp;
    }

    /* '<S1988>:1:85' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.PreAmpBassRampers[(int32_T)ramper - 1].currentGain =
        gain;
}

/*
 * Output and update for function-call system:
 *    '<S1975>/SetDsm'
 *    '<S1975>/SetDsm1'
 */
void Model_Target_SetDsm_c1(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S1997>/Data Store Write' incorporates:
     *  Constant: '<S1997>/Constant'
     */
    Model_TargetControlDsms.PreAmpMidrangeCfgFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1975>/tone control' */
void Model_Target_tonecontrol_l(real32_T rtu_boost_max_db, real32_T
    rtu_cut_max_db, real32_T rtu_normalized_gain_impact, real32_T rtu_db_per_sec,
    real32_T rtu_ramp_time_ms, real32_T rtu_sample_rate_in_hertz, real32_T
    rtu_frame_size)
{
    suFnE4DIYISSjYbtQHPXOwD_Model_Target_T phaseConfig[2];
    real32_T currentGain_tmp;
    real32_T currentImpact_db;
    real32_T db_diff;
    real32_T phase1Frames;
    real32_T quantum_ms;
    real32_T targetEffectiveGain;
    real32_T x;
    boolean_T currentIsBoost;
    boolean_T targetIsBoost;

    /*  See Controlsummary at the end; */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Midrange/tone control': '<S2007>:1' */
    /* '<S2007>:1:10' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step now performed on canvas) */
    /*  Step 2a: IMPACT-TARGET Translate the normalized gain into a dB impact */
    /*  based on the maximum boost or cut values. */
    /*  ("-1" = maximum cut, "1" = maximum boost.) */
    /* '<S2007>:1:18' [targetIsBoost,targetImpact_db,targetEffectiveGain,... */
    /* '<S2007>:1:19'     actualTargetGainLinear] = ... */
    /* '<S2007>:1:20'     tone_control_split1(normalized_gain_impact,boost_max_db,cut_max_db); */
    /*  NudgeUnity end */
    /* '<S2007>:1:105' targetIsBoost = (normalized_gain_impact >= 0); */
    targetIsBoost = (rtu_normalized_gain_impact >= 0.0F);

    /* '<S2007>:1:106' if (targetIsBoost) */
    if (targetIsBoost)
    {
        /* '<S2007>:1:107' targetImpact_db = normalized_gain_impact * boost_max_db; */
        phase1Frames = rtu_normalized_gain_impact * rtu_boost_max_db;

        /* '<S2007>:1:108' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(phase1Frames *
            2.30258512F, 20.0F));

        /*  1 or greater */
    }
    else
    {
        /* '<S2007>:1:109' else */
        /* '<S2007>:1:110' targetImpact_db = normalized_gain_impact * cut_max_db; */
        phase1Frames = rtu_normalized_gain_impact * rtu_cut_max_db;

        /* '<S2007>:1:111' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(phase1Frames *
            2.30258512F, 20.0F));

        /*  less than 1 */
    }

    /*  remember the actual target because we will nudge this value away from one */
    /*  during the ramper calculations. This actual target value is used below as */
    /*  the target in the ramper data itself. */
    /* '<S2007>:1:116' actualTargetGainLinear = targetEffectiveGain; */
    /*  Step 2b: IMPACT-CURRENT Fetch the current gain from the previously */
    /*  active ramper. */
    /* '<S2007>:1:24' currentPhase = Phase; */
    /* '<S2007>:1:25' currentGain = Rampers(currentPhase).currentGain; */
    currentGain_tmp = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
        Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].currentGain;

    /* '<S2007>:1:26' currentIsBoost = (currentGain >= 1); */
    currentIsBoost = (currentGain_tmp >= 1.0F);

    /* '<S2007>:1:27' currentImpact_db = db20(currentGain); */
    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    currentImpact_db = qhmath_log_f(qhmath_abs_f(currentGain_tmp)) * 8.68588924F;

    /*  Setup processing to continue on seamlessly while we work here */
    /* '<S2007>:1:30' Rampers(1).currentGain = currentGain; */
    /* '<S2007>:1:31' Phase = uint32(1); */
    Model_TargetControlDsms.PreAmpMidrangeCfgPhase = 1U;

    /*  reset phase to 1 */
    /*  Now that we have both current and target impacts, find the difference */
    /* '<S2007>:1:33' db_diff = abs(currentImpact_db - targetImpact_db); */
    db_diff = qhmath_abs_f(currentImpact_db - phase1Frames);

    /*  Step 3a: TIME- If a slope in dB/second is provided, ignore the ramp time */
    /*  and instead calculate a new ramp time that matches the slope. */
    /* '<S2007>:1:37' if (db_per_sec) */
    if (rtu_db_per_sec != 0.0F)
    {
        /* '<S2007>:1:38' ramp_ms = db_diff / single(db_per_sec) * 1000; */
        x = qhmath_div_f(db_diff, rtu_db_per_sec) * 1000.0F;
    }
    else
    {
        /* '<S2007>:1:39' else */
        /* '<S2007>:1:40' ramp_ms = single(ramp_time_ms); */
        x = rtu_ramp_time_ms;
    }

    /*  Step 3b: TIME- QUANTIZE the desired ramp time to our FrameSize.  */
    /* '<S2007>:1:44' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);

    /* '<S2007>:1:45' numFrames = ramp_ms / quantum_ms; */
    /* '<S2007>:1:46' numFrames = max (1, ceil(numFrames)); */
    x = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(x, quantum_ms)));

    /*  Step 4a: PHASES- Determine whether ramping from current gain to target */
    /*  gain requires a unity crossing in linear gain.  */
    /* '<S2007>:1:50' isTwoPhase = (currentIsBoost ~= targetIsBoost) && ... */
    /* '<S2007>:1:51'     (currentGain ~= 1) && ... % cannot cross if you're already there */
    /* '<S2007>:1:52'     (targetImpact_db ~= 1); */
    /*  % cannot cross if you're already there */
    /*  no crossing needed when impact already nothing */
    /*  Setup a structure to hold information about what the rampers should do */
    /* '<S2007>:1:54' twoSingles = {single(0) single(0)}; */
    /* '<S2007>:1:55' phaseConfig = struct('frames',twoSingles,'target_linear',twoSingles,'current_linear',twoSingles); */
    /* '<S2007>:1:56' phaseConfig = tone_control_split2(numFrames,currentImpact_db,... */
    /* '<S2007>:1:57'     db_diff,currentGain,currentIsBoost,rgain_SILENT_GAIN,targetIsBoost,... */
    /* '<S2007>:1:58'     targetEffectiveGain,isTwoPhase,phaseConfig); */
    /* tone_control_split1 */
    /* '<S2007>:1:125' if (isTwoPhase) */
    if ((currentIsBoost != targetIsBoost) && (currentGain_tmp != 1.0F) &&
            (phase1Frames != 1.0F))
    {
        /*  Both boost and cut phases will be required to get where we are going. */
        /*  Make sure we have at least two frames to work with: */
        /* '<S2007>:1:128' numFrames = max (2, round(numFrames)); */
        x = fmaxf(2.0F, x);

        /*  Divide up our ramp time into pieces for each phase to use */
        /* '<S2007>:1:131' phase1Frames = ceil(numFrames * abs(currentImpact_db) / db_diff); */
        phase1Frames = qhmath_ceil_f(qhmath_div_f(x * qhmath_abs_f
            (currentImpact_db), db_diff));

        /* '<S2007>:1:132' phase2Frames = numFrames - phase1Frames; */
        /*  Make sure phase 2 has at least 1 frame to work with */
        /* '<S2007>:1:135' phase2Frames = max(1, phase2Frames); */
        phaseConfig[1].frames = fmaxf(1.0F, x - phase1Frames);

        /*  Setup Phase 1 ramper that takes us to zero impact (i.e. unity gain) */
        /* '<S2007>:1:138' phaseConfig(1).current_linear   = currentGain; */
        phaseConfig[0].current_linear = currentGain_tmp;

        /*  we know this is not 1 */
        /* '<S2007>:1:139' phaseConfig(1).target_linear    = NudgeUnity(1,currentIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2007>:1:95' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S2007>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = 1.00000048F;
        }
        else
        {
            /* '<S2007>:1:97' else */
            /* '<S2007>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = 0.999999523F;
        }

        /* '<S2007>:1:140' phaseConfig(1).frames           = phase1Frames; */
        phaseConfig[0].frames = phase1Frames;

        /*  Setup Phase 2 ramper that delivers us to target impact */
        /* '<S2007>:1:143' phaseConfig(2).current_linear   = NudgeUnity(1,targetIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2007>:1:95' if (isPositive) */
        if (targetIsBoost)
        {
            /* '<S2007>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].current_linear = 1.00000048F;
        }
        else
        {
            /* '<S2007>:1:97' else */
            /* '<S2007>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].current_linear = 0.999999523F;
        }

        /*  start quiet */
        /* '<S2007>:1:144' phaseConfig(2).target_linear    = targetEffectiveGain; */
        phaseConfig[1].target_linear = targetEffectiveGain;

        /*  we know this is not 0 */
        /* '<S2007>:1:145' phaseConfig(2).frames           = phase2Frames; */
    }
    else
    {
        /* '<S2007>:1:146' else */
        /*  Only one phase is needed to accomplish our goal. We are are the */
        /*  target side of unity... but we must determine which side that is */
        /* '<S2007>:1:149' if (currentGain == 1) */
        if (currentGain_tmp == 1.0F)
        {
            /*  One is in-between sides: use the target to determine the side */
            /* '<S2007>:1:151' isBoost = targetIsBoost; */
            currentIsBoost = targetIsBoost;
        }
        else
        {
            /* '<S2007>:1:152' else */
            /*  Current gain is already on one side of unity so use that */
            /* '<S2007>:1:154' isBoost = currentIsBoost; */
        }

        /* '<S2007>:1:156' phaseConfig(1).current_linear   = NudgeUnity(currentGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2007>:1:95' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S2007>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].current_linear = fmaxf(currentGain_tmp, 1.00000048F);

            /* '<S2007>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = fmaxf(targetEffectiveGain,
                1.00000048F);
        }
        else
        {
            /* '<S2007>:1:97' else */
            /* '<S2007>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].current_linear = fminf(currentGain_tmp, 0.999999523F);

            /* '<S2007>:1:97' else */
            /* '<S2007>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = fminf(targetEffectiveGain,
                0.999999523F);
        }

        /* '<S2007>:1:157' phaseConfig(1).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2007>:1:95' if (isPositive) */
        /* '<S2007>:1:158' phaseConfig(1).frames           = numFrames; */
        phaseConfig[0].frames = x;

        /*  Setup Phase 2 ramper to sit at the target gain */
        /* '<S2007>:1:161' phaseConfig(2).current_linear   = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2007>:1:95' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S2007>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phase1Frames = fmaxf(targetEffectiveGain, 1.00000048F);
            phaseConfig[1].current_linear = phase1Frames;

            /* '<S2007>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].target_linear = phase1Frames;
        }
        else
        {
            /* '<S2007>:1:97' else */
            /* '<S2007>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phase1Frames = fminf(targetEffectiveGain, 0.999999523F);
            phaseConfig[1].current_linear = phase1Frames;

            /* '<S2007>:1:97' else */
            /* '<S2007>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].target_linear = phase1Frames;
        }

        /* '<S2007>:1:162' phaseConfig(2).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2007>:1:95' if (isPositive) */
        /* '<S2007>:1:163' phaseConfig(2).frames           = single(0); */
        phaseConfig[1].frames = 0.0F;
    }

    /*  Step 4b: PHASES- Setup rampers for both phases */
    /* '<S2007>:1:61' for currentPhase=1:2 */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /* '<S2007>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[0].frames != 0.0F)
    {
        /* '<S2007>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S2007>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S2007>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpMidrangeCfgRampers[0].rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[0].
                            target_linear, phaseConfig[0].current_linear)),
                          qhmath_div_f(quantum_ms * phaseConfig[0].frames *
                           rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S2007>:1:70' else */
        /* '<S2007>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpMidrangeCfgRampers[0].rampCoeff = 1.0F;
    }

    /*  Output control signals */
    /* '<S2007>:1:75' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[0].frameCount = (int32_T)
        phaseConfig[0].frames;

    /* '<S2007>:1:76' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S2007>:1:77' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[0].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S2007>:1:78' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[0].currentGain =
        phaseConfig[0].current_linear;

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /* '<S2007>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[1].frames != 0.0F)
    {
        /* '<S2007>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S2007>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S2007>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpMidrangeCfgRampers[1].rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[1].
                            target_linear, phaseConfig[1].current_linear)),
                          qhmath_div_f(quantum_ms * phaseConfig[1].frames *
                           rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S2007>:1:70' else */
        /* '<S2007>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpMidrangeCfgRampers[1].rampCoeff = 1.0F;
    }

    /*  Output control signals */
    /* '<S2007>:1:75' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[1].frameCount = (int32_T)
        phaseConfig[1].frames;

    /* '<S2007>:1:76' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S2007>:1:77' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[1].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S2007>:1:78' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[1].currentGain =
        phaseConfig[1].current_linear;

    /*  unfreeze the gain (This step now performed on canvas) */
}

/* Output and update for function-call system: '<S1996>/REQ' */
void HandleReqPreAmpMidrangeCfgSet(void)
{
    int32_T rampRate;
    real32_T y;

    /* MATLAB Function: '<S1975>/index to linear gain mapping' */
    /* MATLAB Function: '<S1975>/index to linear gain mapping' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2011>:1' */
    /* '<S2011>:1:3' go(); */
    Model_Target_indextolinear(Model_Target_PreAmp0.MidrangeCfgScale,
        Model_Target_PreAmp0.MidrangeCfgOffset,
        Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_gain_index,
        &Model_Target_PreAmpPart1_B.sf_indextolineargainmapping_m);

    /* MATLAB Function: '<S1975>/calculate ramp parameters' */
    /* MATLAB Function: '<S1975>/calculate ramp parameters' */
    y = Model_Target_PreAmp0.MidrangeCfgRampTime;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Midrange/calculate ramp parameters': '<S2003>:1' */
    /*  Ramp time mentioned in the RTC message gets priority over the tune */
    /*  variable. Boundary conditions are also included based on BDSP values. */
    /* '<S2003>:1:8' ramptime = single(rampTimeTune); */
    /* '<S2003>:1:9' rampRate = single(0); */
    rampRate = 0;

    /* '<S2003>:1:11' if (rampRateRTC) */
    if (Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_ramp_db_per_second != 0U)
    {
        /* '<S2003>:1:12' rampRate = single(rampRateRTC); */
        /* '<S2003>:1:13' rampRate = max(rampRateBounds(1), rampRate); */
        /* '<S2003>:1:14' rampRate = min(rampRateBounds(2), rampRate); */
        rampRate = (int32_T)fminf(50000.0F, fmaxf(5.0F, (real32_T)
            Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_ramp_db_per_second));
    }

    /* '<S2003>:1:16' if (rampTimeRTC) */
    if (Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_ramp_milliseconds != 0U)
    {
        /* '<S2003>:1:17' ramptime = single(rampTimeRTC); */
        y = (real32_T)
            Model_TargetPreAmpMidrangeCfgSetRtcOut.REQ_ramp_milliseconds;
    }

    /* Outputs for Function Call SubSystem: '<S1975>/SetDsm' */
    /* '<S2003>:1:19' ramptime = max(rampTimeBounds(1), ramptime); */
    /* '<S2003>:1:20' ramptime = min(rampTimeBounds(2), ramptime); */
    Model_Target_SetDsm_c1(1U);

    /* End of Outputs for SubSystem: '<S1975>/SetDsm' */

    /* MATLAB Function: '<S1975>/tone control' */
    /* MATLAB Function: '<S1975>/calculate ramp parameters' */
    /* MATLAB Function: '<S1975>/tone control' incorporates:
     *  MATLAB Function: '<S1975>/calculate ramp parameters'
     *  S-Function (AudioStats_MEX): '<S1975>/Audio Stats'
     */
    Model_Target_tonecontrol_l(Model_Target_PreAmp0.MidrangeCfgBoostMaximum_dB,
        Model_Target_PreAmp0.MidrangeCfgCutMaximum_dB,
        Model_Target_PreAmpPart1_B.sf_indextolineargainmapping_m.linearGain,
        (real32_T)rampRate, fminf(3000.0F, fmaxf(1.0F, y)), 44307.692307692312,
        32.0);

    /* Outputs for Function Call SubSystem: '<S1975>/SetDsm1' */
    Model_Target_SetDsm_c1(0U);

    /* End of Outputs for SubSystem: '<S1975>/SetDsm1' */
}

/* Output and update for atomic system: '<S1975>/tone' */
void Model_Target_tone_k(const real32_T rtu_boost_coeffs[5], const real32_T
    rtu_cut_coeffs[5], const real32_T rtu_audioIn[64], B_tone_Model_Target_b_T
    *localB, DW_tone_Model_Target_d_T *localDW)
{
    int32_T q0;
    int32_T qY;
    real32_T aCoeffs_idx_0;
    real32_T aCoeffs_idx_1;
    real32_T bCoeffs_idx_0;
    real32_T bCoeffs_idx_2;
    real32_T gain;
    real32_T k;
    uint32_T ramper;

    /*     % inputs % parameters */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Midrange/tone': '<S2006>:1' */
    /*  Data Store objects (registered in "Edit Data" dialog */
    /*  Keep memory for the filter persistent from frame to frame */
    /*  figure out the frame size and channel count */
    /* '<S2006>:1:15' [frame_size, channel_count] = size(audioIn); */
    /* '<S2006>:1:17' if (isempty(toneFilterStates)) */
    /*  set the size and datatype of the output buffer */
    /* '<S2006>:1:22' audioOut = coder.nullcopy(audioIn); */
    /* '<S2006>:1:24' ramper = Phase; */
    ramper = Model_TargetControlDsms.PreAmpMidrangeCfgPhase;

    /* '<S2006>:1:25' ramperCount = numel(Rampers); */
    /* '<S2006>:1:27' if (Freeze == false) */
    if (Model_TargetControlDsms.PreAmpMidrangeCfgFreeze == 0U)
    {
        /* '<S2006>:1:28' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
                Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].frameCount ==
            0)
        {
            /*  The current ramper is finished. Is there another one? */
            /* '<S2006>:1:30' if (ramper < ramperCount && Rampers(ramper+1).frameCount > 0) */
            if ((Model_TargetControlDsms.PreAmpMidrangeCfgPhase < 2U) &&
                    (Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
                     Model_TargetControlDsms.PreAmpMidrangeCfgPhase].frameCount >
                     0))
            {
                /*  Yes - move on to the next phase */
                /* '<S2006>:1:32' ramper = ramper + 1; */
                qY = (int32_T)(Model_TargetControlDsms.PreAmpMidrangeCfgPhase +
                               /*MW:OvSatOk*/ 1U);
                ramper = Model_TargetControlDsms.PreAmpMidrangeCfgPhase + 1U;

                /* '<S2006>:1:33' Phase = ramper; */
                Model_TargetControlDsms.PreAmpMidrangeCfgPhase =
                    Model_TargetControlDsms.PreAmpMidrangeCfgPhase + 1U;

                /* '<S2006>:1:34' k = Rampers(ramper).rampCoeff; */
                k = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[qY - 1].
                    rampCoeff;

                /* '<S2006>:1:35' gain = Rampers(ramper).currentGain; */
                gain = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[qY - 1].
                    currentGain;

                /* '<S2006>:1:36' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
                q0 = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[qY - 1].
                    frameCount;
                if (q0 < -2147483647)
                {
                    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[qY - 1].
                        frameCount = MIN_int32_T;
                }
                else
                {
                    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[qY - 1].
                        frameCount = q0 - 1;
                }
            }
            else
            {
                /* '<S2006>:1:37' else */
                /*   Stop ramping and SNAP to the target */
                /* '<S2006>:1:39' k = single(1); */
                k = 1.0F;

                /* '<S2006>:1:40' gain = Rampers(ramper).targetGain; */
                gain = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].
                    targetGain;

                /*  Update completion flag */
            }
        }
        else
        {
            /* '<S2006>:1:43' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S2006>:1:45' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
                Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].rampCoeff;

            /* '<S2006>:1:46' gain = Rampers(ramper).currentGain; */
            gain = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
                Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].currentGain;

            /* '<S2006>:1:47' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            q0 = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
                Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].frameCount;
            if (q0 < -2147483647)
            {
                Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].
                    frameCount = MIN_int32_T;
            }
            else
            {
                Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].
                    frameCount = q0 - 1;
            }
        }
    }
    else
    {
        /* '<S2006>:1:49' else */
        /*  Frozen. Stay at current gain */
        /* '<S2006>:1:51' k = single(1); */
        k = 1.0F;

        /* '<S2006>:1:52' gain = Rampers(ramper).currentGain; */
        gain = Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)
            Model_TargetControlDsms.PreAmpMidrangeCfgPhase - 1].currentGain;
    }

    /*  Apply the tone filter */
    /* '<S2006>:1:56' if (gain < 1) */
    if (gain < 1.0F)
    {
        /*  Cut */
        /* '<S2006>:1:58' aCoeffs = cut_coeffs(1:2); */
        aCoeffs_idx_0 = rtu_cut_coeffs[0];
        aCoeffs_idx_1 = rtu_cut_coeffs[1];

        /* '<S2006>:1:59' bCoeffs = cut_coeffs(3:5); */
        bCoeffs_idx_0 = rtu_cut_coeffs[2];
        bCoeffs_idx_2 = rtu_cut_coeffs[4];
    }
    else
    {
        /* '<S2006>:1:60' else */
        /*  Boost */
        /* '<S2006>:1:62' aCoeffs = boost_coeffs(1:2); */
        aCoeffs_idx_0 = rtu_boost_coeffs[0];
        aCoeffs_idx_1 = rtu_boost_coeffs[1];

        /* '<S2006>:1:63' bCoeffs = boost_coeffs(3:5); */
        bCoeffs_idx_0 = rtu_boost_coeffs[2];
        bCoeffs_idx_2 = rtu_boost_coeffs[4];
    }

    /*  [filtered,toneFilterStates] = filter(bCoeffs, aCoeffs, audioIn, toneFilterStates); */
    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S2006>:1:69' for n=1:frame_size */
    for (q0 = 0; q0 < 32; q0++)
    {
        real32_T filterOut;
        real32_T filterOut_tmp;

        /*  Update the gain and then subtract one before applying it to the */
        /*  filtered signal. Disregarding phase shifting  */
        /* '<S2006>:1:72' gain = gain * k; */
        gain *= k;

        /* '<S2006>:1:73' filterGain = gain - 1; */
        /*  Loop through channels adding in gain-adjusted filtered samples */
        /* '<S2006>:1:75' for chanIdx = 1:channel_count */
        /* '<S2006>:1:77' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(1,chanIdx); */
        filterOut = bCoeffs_idx_0 * rtu_audioIn[q0] + localDW->toneFilterStates
            [0];

        /* '<S2006>:1:78' toneFilterStates(1,chanIdx) = toneFilterStates(2,chanIdx) - aCoeffs(1) * filterOut; */
        localDW->toneFilterStates[0] = localDW->toneFilterStates[1] -
            aCoeffs_idx_0 * filterOut;

        /* '<S2006>:1:79' toneFilterStates(2,chanIdx) = bCoeffs(3) * audioIn(n,chanIdx) - (aCoeffs(2) * filterOut); */
        localDW->toneFilterStates[1] = bCoeffs_idx_2 * rtu_audioIn[q0] -
            aCoeffs_idx_1 * filterOut;

        /* '<S2006>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0] = (gain - 1.0F) * filterOut + rtu_audioIn[q0];

        /* '<S2006>:1:77' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(1,chanIdx); */
        filterOut_tmp = rtu_audioIn[q0 + 32];
        filterOut = filterOut_tmp * bCoeffs_idx_0 + localDW->toneFilterStates[2];

        /* '<S2006>:1:78' toneFilterStates(1,chanIdx) = toneFilterStates(2,chanIdx) - aCoeffs(1) * filterOut; */
        localDW->toneFilterStates[2] = localDW->toneFilterStates[3] -
            aCoeffs_idx_0 * filterOut;

        /* '<S2006>:1:79' toneFilterStates(2,chanIdx) = bCoeffs(3) * audioIn(n,chanIdx) - (aCoeffs(2) * filterOut); */
        localDW->toneFilterStates[3] = filterOut_tmp * bCoeffs_idx_2 -
            aCoeffs_idx_1 * filterOut;

        /* '<S2006>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0 + 32] = (gain - 1.0F) * filterOut + filterOut_tmp;
    }

    /* '<S2006>:1:85' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.PreAmpMidrangeCfgRampers[(int32_T)ramper - 1].
        currentGain = gain;
}

/*
 * Output and update for function-call system:
 *    '<S1977>/SetDsm'
 *    '<S1977>/SetDsm1'
 */
void Model_Target_SetDsm_i(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S2033>/Data Store Write' incorporates:
     *  Constant: '<S2033>/Constant'
     */
    Model_TargetControlDsms.PreAmpTrebleFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1977>/tone control' */
void Model_Target_tonecontrol_f(real32_T rtu_boost_max_db, real32_T
    rtu_cut_max_db, real32_T rtu_normalized_gain_impact, real32_T rtu_db_per_sec,
    real32_T rtu_ramp_time_ms, real32_T rtu_sample_rate_in_hertz, real32_T
    rtu_frame_size)
{
    suFnE4DIYISSjYbtQHPXOwD_Model_Target_T phaseConfig[2];
    real32_T currentGain_tmp;
    real32_T currentImpact_db;
    real32_T db_diff;
    real32_T quantum_ms;
    real32_T targetEffectiveGain;
    real32_T targetImpact_db;
    real32_T x;
    boolean_T currentIsBoost;
    boolean_T targetIsBoost;

    /*  %inputs */
    /*  % inputs % parameters */
    /* parameters */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Treble/tone control': '<S2043>:1' */
    /*  See Control summary at the end: */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step now performed on canvas) */
    /*  Step 2a: IMPACT-TARGET Translate the normalized gain into a dB impact */
    /*  based on the maximum boost or cut values. */
    /*  ("-1" = maximum cut, "1" = maximum boost.) */
    /* '<S2043>:1:16' targetIsBoost = (normalized_gain_impact >= 0); */
    targetIsBoost = (rtu_normalized_gain_impact >= 0.0F);

    /* '<S2043>:1:17' if (targetIsBoost) */
    if (targetIsBoost)
    {
        /* '<S2043>:1:18' targetImpact_db = normalized_gain_impact * boost_max_db; */
        targetImpact_db = rtu_normalized_gain_impact * rtu_boost_max_db;

        /* '<S2043>:1:19' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(targetImpact_db *
            2.30258512F, 20.0F));

        /*  1 or greater */
    }
    else
    {
        /* '<S2043>:1:20' else */
        /* '<S2043>:1:21' targetImpact_db = normalized_gain_impact * cut_max_db; */
        targetImpact_db = rtu_normalized_gain_impact * rtu_cut_max_db;

        /* '<S2043>:1:22' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(targetImpact_db *
            2.30258512F, 20.0F));

        /*  less than 1 */
    }

    /* '<S2043>:1:25' actualTargetGainLinear = targetEffectiveGain; */
    /*  Step 2b: IMPACT-CURRENT Fetch the current gain from the previously */
    /*  active ramper. */
    /* '<S2043>:1:29' currentPhase = Phase; */
    /* '<S2043>:1:30' currentGain = Rampers(currentPhase).currentGain; */
    currentGain_tmp = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
        Model_TargetControlDsms.PreAmpTreblePhase - 1].currentGain;

    /* '<S2043>:1:31' currentIsBoost = (currentGain >= 1); */
    currentIsBoost = (currentGain_tmp >= 1.0F);

    /* '<S2043>:1:32' currentImpact_db = db20(currentGain); */
    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: Model_Target.c 178071 2024-03-05 13:24:46Z ad55945 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    currentImpact_db = qhmath_log_f(qhmath_abs_f(currentGain_tmp)) * 8.68588924F;

    /*  Setup processing to continue on seamlessly while we work here */
    /* '<S2043>:1:35' Rampers(1).currentGain = currentGain; */
    /* '<S2043>:1:36' Phase = uint32(1); */
    Model_TargetControlDsms.PreAmpTreblePhase = 1U;

    /*  reset phase to 1 */
    /*  Now that we have both current and target impacts, find the difference */
    /* '<S2043>:1:38' db_diff = abs(currentImpact_db - targetImpact_db); */
    db_diff = qhmath_abs_f(currentImpact_db - targetImpact_db);

    /*  Step 3a: TIME- If a slope in dB/second is provided, ignore the ramp time */
    /* '<S2043>:1:41' if (db_per_sec) */
    if (rtu_db_per_sec != 0.0F)
    {
        /* '<S2043>:1:42' ramp_ms = db_diff / single(db_per_sec) * 1000; */
        x = qhmath_div_f(db_diff, rtu_db_per_sec) * 1000.0F;
    }
    else
    {
        /* '<S2043>:1:43' else */
        /* '<S2043>:1:44' ramp_ms = single(ramp_time_ms); */
        x = rtu_ramp_time_ms;
    }

    /*  Step 3b: TIME- QUANTIZE the desired ramp time to our FrameSize.  */
    /* '<S2043>:1:48' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);

    /* '<S2043>:1:49' numFrames = ramp_ms / quantum_ms; */
    /* '<S2043>:1:50' numFrames = max (1, ceil(numFrames)); */
    x = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(x, quantum_ms)));

    /*  Step 4a: PHASES- Determine whether ramping from current gain to target */
    /*  gain requires a unity crossing in linear gain. */
    /* '<S2043>:1:54' isTwoPhase = (currentIsBoost ~= targetIsBoost) && ... */
    /* '<S2043>:1:55'              (currentGain ~= 1) && ... % cannot cross if you're already there */
    /* '<S2043>:1:56'              (targetImpact_db ~= 1); */
    /*  % cannot cross if you're already there */
    /*  no crossing needed when impact already nothing */
    /*  Setup a structure to hold information about what the rampers should do */
    /* '<S2043>:1:58' twoSingles = {single(0) single(0)}; */
    /* '<S2043>:1:59' phaseConfig = struct('frames',twoSingles,'target_linear',twoSingles,'current_linear',twoSingles); */
    /* '<S2043>:1:60' phaseConfig = tone_control_split(numFrames,currentImpact_db,db_diff,... */
    /* '<S2043>:1:61'     currentGain,currentIsBoost,rgain_SILENT_GAIN,targetIsBoost,... */
    /* '<S2043>:1:62'     targetEffectiveGain,isTwoPhase,phaseConfig); */
    /* '<S2043>:1:104' if (isTwoPhase) */
    if ((currentIsBoost != targetIsBoost) && (currentGain_tmp != 1.0F) &&
            (targetImpact_db != 1.0F))
    {
        /*  Both boost and cut phases will be required to get where we are going. */
        /*  Make sure we have at least two frames to work with: */
        /* '<S2043>:1:107' numFrames = max (2, round(numFrames)); */
        x = fmaxf(2.0F, x);

        /*  Divide up our ramp time into pieces for each phase to use */
        /* '<S2043>:1:110' phase1Frames = ceil(numFrames * abs(currentImpact_db) / db_diff); */
        targetImpact_db = qhmath_ceil_f(qhmath_div_f(x * qhmath_abs_f
            (currentImpact_db), db_diff));

        /* '<S2043>:1:111' phase2Frames = numFrames - phase1Frames; */
        /*  Make sure phase 2 has at least 1 frame to work with */
        /* '<S2043>:1:114' phase2Frames = max(1, phase2Frames); */
        phaseConfig[1].frames = fmaxf(1.0F, x - targetImpact_db);

        /*  Setup Phase 1 ramper that takes us to zero impact (i.e. unity gain) */
        /* '<S2043>:1:117' phaseConfig(1).current_linear   = currentGain; */
        phaseConfig[0].current_linear = currentGain_tmp;

        /*  we know this is not 1 */
        /* '<S2043>:1:118' phaseConfig(1).target_linear    = NudgeUnity(1,currentIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2043>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S2043>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = 1.00000048F;
        }
        else
        {
            /* '<S2043>:1:96' else */
            /* '<S2043>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = 0.999999523F;
        }

        /* '<S2043>:1:119' phaseConfig(1).frames           = phase1Frames; */
        phaseConfig[0].frames = targetImpact_db;

        /*  Setup Phase 2 ramper that delivers us to target impact */
        /* '<S2043>:1:122' phaseConfig(2).current_linear   = NudgeUnity(1,targetIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2043>:1:94' if (isPositive) */
        if (targetIsBoost)
        {
            /* '<S2043>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].current_linear = 1.00000048F;
        }
        else
        {
            /* '<S2043>:1:96' else */
            /* '<S2043>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].current_linear = 0.999999523F;
        }

        /*  start quiet */
        /* '<S2043>:1:123' phaseConfig(2).target_linear    = targetEffectiveGain; */
        phaseConfig[1].target_linear = targetEffectiveGain;

        /*  we know this is not 0 */
        /* '<S2043>:1:124' phaseConfig(2).frames           = phase2Frames; */
    }
    else
    {
        /* '<S2043>:1:125' else */
        /*  Only one phase is needed to accomplish our goal. We are are the */
        /*  target side of unity... but we must determine which side that is */
        /* '<S2043>:1:128' if (currentGain == 1) */
        if (currentGain_tmp == 1.0F)
        {
            /*  One is in-between sides: use the target to determine the side */
            /* '<S2043>:1:130' isBoost = targetIsBoost; */
            currentIsBoost = targetIsBoost;
        }
        else
        {
            /* '<S2043>:1:131' else */
            /*  Current gain is already on one side of unity so use that */
            /* '<S2043>:1:133' isBoost = currentIsBoost; */
        }

        /* '<S2043>:1:135' phaseConfig(1).current_linear   = NudgeUnity(currentGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2043>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S2043>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].current_linear = fmaxf(currentGain_tmp, 1.00000048F);

            /* '<S2043>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = fmaxf(targetEffectiveGain,
                1.00000048F);
        }
        else
        {
            /* '<S2043>:1:96' else */
            /* '<S2043>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].current_linear = fminf(currentGain_tmp, 0.999999523F);

            /* '<S2043>:1:96' else */
            /* '<S2043>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = fminf(targetEffectiveGain,
                0.999999523F);
        }

        /* '<S2043>:1:136' phaseConfig(1).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2043>:1:94' if (isPositive) */
        /* '<S2043>:1:137' phaseConfig(1).frames           = numFrames; */
        phaseConfig[0].frames = x;

        /*  Setup Phase 2 ramper to sit at the target gain */
        /* '<S2043>:1:140' phaseConfig(2).current_linear   = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2043>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S2043>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            targetImpact_db = fmaxf(targetEffectiveGain, 1.00000048F);
            phaseConfig[1].current_linear = targetImpact_db;

            /* '<S2043>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].target_linear = targetImpact_db;
        }
        else
        {
            /* '<S2043>:1:96' else */
            /* '<S2043>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            targetImpact_db = fminf(targetEffectiveGain, 0.999999523F);
            phaseConfig[1].current_linear = targetImpact_db;

            /* '<S2043>:1:96' else */
            /* '<S2043>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].target_linear = targetImpact_db;
        }

        /* '<S2043>:1:141' phaseConfig(2).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S2043>:1:94' if (isPositive) */
        /* '<S2043>:1:142' phaseConfig(2).frames           = single(0); */
        phaseConfig[1].frames = 0.0F;
    }

    /*  Step 4b: PHASES- Setup rampers for both phases */
    /* '<S2043>:1:65' for currentPhase=1:2 */
    /* '<S2043>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[0].frames != 0.0F)
    {
        /* '<S2043>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S2043>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S2043>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpTrebleRampers[0].rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[0].target_linear,
                phaseConfig[0].current_linear)), qhmath_div_f(quantum_ms *
               phaseConfig[0].frames * rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S2043>:1:70' else */
        /* '<S2043>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpTrebleRampers[0].rampCoeff = 1.0F;
    }

    /* '<S2043>:1:73' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S2043>:1:74' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpTrebleRampers[0].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S2043>:1:75' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpTrebleRampers[0].currentGain = phaseConfig[0].
        current_linear;

    /* '<S2043>:1:76' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpTrebleRampers[0].frameCount = (int32_T)
        phaseConfig[0].frames;

    /* '<S2043>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[1].frames != 0.0F)
    {
        /* '<S2043>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S2043>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S2043>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpTrebleRampers[1].rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[1].target_linear,
                phaseConfig[1].current_linear)), qhmath_div_f(quantum_ms *
               phaseConfig[1].frames * rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S2043>:1:70' else */
        /* '<S2043>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpTrebleRampers[1].rampCoeff = 1.0F;
    }

    /* '<S2043>:1:73' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S2043>:1:74' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpTrebleRampers[1].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S2043>:1:75' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpTrebleRampers[1].currentGain = phaseConfig[1].
        current_linear;

    /* '<S2043>:1:76' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpTrebleRampers[1].frameCount = (int32_T)
        phaseConfig[1].frames;

    /*  unfreeze the gain. (This step now performed on canvas) */
}

/* Output and update for function-call system: '<S2032>/REQ' */
void HandleReqPreAmpTrebleSet(void)
{
    /* MATLAB Function: '<S1977>/index to linear' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2047>:1' */
    /* '<S2047>:1:3' go(); */
    Model_Target_indextolinear(Model_Target_PreAmp0.TrebleScale,
        Model_Target_PreAmp0.TrebleOffset,
        Model_TargetPreAmpTrebleSetRtcOut.REQ_gain_index,
        &Model_Target_PreAmpPart1_B.sf_indextolinear_fx);

    /* MATLAB Function: '<S1977>/ramp parameters' */
    Model_Target_rampparameters_g(Model_Target_PreAmp0.Trebleramptime,
        Model_TargetPreAmpTrebleSetRtcOut.REQ_ramp_milliseconds,
        Model_TargetPreAmpTrebleSetRtcOut.REQ_ramp_db_per_second,
        Model_Target_ConstP.pooled1, Model_Target_ConstP.pooled2,
        &Model_Target_PreAmpPart1_B.sf_rampparameters_lv);

    /* Outputs for Function Call SubSystem: '<S1977>/SetDsm' */
    Model_Target_SetDsm_i(1U);

    /* End of Outputs for SubSystem: '<S1977>/SetDsm' */

    /* MATLAB Function: '<S1977>/tone control' */
    /* MATLAB Function: '<S1977>/tone control' incorporates:
     *  S-Function (AudioStats_MEX): '<S1977>/Audio Stats'
     */
    Model_Target_tonecontrol_f(Model_Target_PreAmp0.TrebleBoostMaximum_dB,
        Model_Target_PreAmp0.TrebleCutMaximum_dB,
        Model_Target_PreAmpPart1_B.sf_indextolinear_fx.linearGain,
        Model_Target_PreAmpPart1_B.sf_rampparameters_lv.rampRate,
        Model_Target_PreAmpPart1_B.sf_rampparameters_lv.ramptime,
        44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S1977>/SetDsm1' */
    Model_Target_SetDsm_i(0U);

    /* End of Outputs for SubSystem: '<S1977>/SetDsm1' */
}

/* Output and update for atomic system: '<S1977>/tone' */
void Model_Target_tone_j(const real32_T rtu_boost_coeffs[3], const real32_T
    rtu_cut_coeffs[3], const real32_T rtu_audioIn[64], B_tone_Model_Target_g_T
    *localB, DW_tone_Model_Target_h_T *localDW)
{
    int32_T q0;
    int32_T qY;
    real32_T aCoeffs;
    real32_T bCoeffs_idx_0;
    real32_T bCoeffs_idx_1;
    real32_T gain;
    real32_T k;
    uint32_T ramper;

    /*     % inputs % parameters */
    /* MATLAB Function 'PreAmp/PreAmpPart1/Treble/tone': '<S2042>:1' */
    /*  Data Store objects (registered in "Edit Data" dialog */
    /*  Keep memory for the filter persistent from frame to frame */
    /*  figure out the frame size and channel count */
    /* '<S2042>:1:15' [frame_size, channel_count] = size(audioIn); */
    /* '<S2042>:1:17' if (isempty(toneFilterStates)) */
    /*  set the size and datatype of the output buffer */
    /* '<S2042>:1:23' audioOut = coder.nullcopy(audioIn); */
    /* '<S2042>:1:25' ramper = Phase; */
    ramper = Model_TargetControlDsms.PreAmpTreblePhase;

    /* '<S2042>:1:26' ramperCount = numel(Rampers); */
    /* '<S2042>:1:28' if (Freeze == false) */
    if (Model_TargetControlDsms.PreAmpTrebleFreeze == 0U)
    {
        /* '<S2042>:1:29' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                Model_TargetControlDsms.PreAmpTreblePhase - 1].frameCount == 0)
        {
            /*  The current ramper is finished. Is there another one? */
            /* '<S2042>:1:31' if (ramper < ramperCount && Rampers(ramper+1).frameCount > 0) */
            if ((Model_TargetControlDsms.PreAmpTreblePhase < 2U) &&
                    (Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                     Model_TargetControlDsms.PreAmpTreblePhase].frameCount > 0))
            {
                /*  Yes - move on to the next phase */
                /* '<S2042>:1:33' ramper = ramper + 1; */
                qY = (int32_T)(Model_TargetControlDsms.PreAmpTreblePhase +
                               /*MW:OvSatOk*/ 1U);
                ramper = Model_TargetControlDsms.PreAmpTreblePhase + 1U;

                /* '<S2042>:1:34' Phase = ramper; */
                Model_TargetControlDsms.PreAmpTreblePhase =
                    Model_TargetControlDsms.PreAmpTreblePhase + 1U;

                /* '<S2042>:1:35' k = Rampers(ramper).rampCoeff; */
                k = Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                    rampCoeff;

                /* '<S2042>:1:36' gain = Rampers(ramper).currentGain; */
                gain = Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                    currentGain;

                /* '<S2042>:1:37' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
                q0 = Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                    frameCount;
                if (q0 < -2147483647)
                {
                    Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                        frameCount = MIN_int32_T;
                }
                else
                {
                    Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                        frameCount = q0 - 1;
                }
            }
            else
            {
                /* '<S2042>:1:38' else */
                /*   Stop ramping and SNAP to the target */
                /* '<S2042>:1:40' k = single(1); */
                k = 1.0F;

                /* '<S2042>:1:41' gain = Rampers(ramper).targetGain; */
                gain = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpTreblePhase - 1].targetGain;

                /*  Update completion flag */
            }
        }
        else
        {
            /* '<S2042>:1:44' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S2042>:1:46' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                Model_TargetControlDsms.PreAmpTreblePhase - 1].rampCoeff;

            /* '<S2042>:1:47' gain = Rampers(ramper).currentGain; */
            gain = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                Model_TargetControlDsms.PreAmpTreblePhase - 1].currentGain;

            /* '<S2042>:1:48' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            q0 = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                Model_TargetControlDsms.PreAmpTreblePhase - 1].frameCount;
            if (q0 < -2147483647)
            {
                Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpTreblePhase - 1].frameCount =
                    MIN_int32_T;
            }
            else
            {
                Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpTreblePhase - 1].frameCount =
                    q0 - 1;
            }
        }
    }
    else
    {
        /* '<S2042>:1:50' else */
        /*  Frozen. Stay at current gain */
        /* '<S2042>:1:52' k = single(1); */
        k = 1.0F;

        /* '<S2042>:1:53' gain = Rampers(ramper).currentGain; */
        gain = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
            Model_TargetControlDsms.PreAmpTreblePhase - 1].currentGain;
    }

    /*  Apply the tone filter */
    /* '<S2042>:1:57' if (gain < 1) */
    if (gain < 1.0F)
    {
        /*  Cut */
        /* '<S2042>:1:59' bCoeffs = cut_coeffs(1:2); */
        bCoeffs_idx_0 = rtu_cut_coeffs[0];
        bCoeffs_idx_1 = rtu_cut_coeffs[1];

        /* '<S2042>:1:60' aCoeffs = cut_coeffs(3); */
        aCoeffs = rtu_cut_coeffs[2];
    }
    else
    {
        /* '<S2042>:1:61' else */
        /*  Boost */
        /* '<S2042>:1:63' bCoeffs = boost_coeffs(1:2); */
        bCoeffs_idx_0 = rtu_boost_coeffs[0];
        bCoeffs_idx_1 = rtu_boost_coeffs[1];

        /* '<S2042>:1:64' aCoeffs = boost_coeffs(3); */
        aCoeffs = rtu_boost_coeffs[2];
    }

    /*  [filtered,toneFilterStates] = filter(bCoeffs, aCoeffs, audioIn, toneFilterStates); */
    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S2042>:1:70' for n=1:frame_size */
    for (q0 = 0; q0 < 32; q0++)
    {
        real32_T filterOut;
        real32_T filterOut_tmp;

        /*  Update the gain and then subtract one before applying it to the */
        /*  filtered signal. Disregarding phase shifting  */
        /* '<S2042>:1:73' gain = gain * k; */
        gain *= k;

        /* '<S2042>:1:74' filterGain = gain - 1; */
        /*  Loop through channels adding in gain-adjusted filtered samples */
        /* '<S2042>:1:76' for chanIdx = 1:channel_count */
        /* '<S2042>:1:78' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(chanIdx); */
        filterOut = bCoeffs_idx_0 * rtu_audioIn[q0] + localDW->toneFilterStates
            [0];

        /* '<S2042>:1:79' toneFilterStates(chanIdx) = (bCoeffs(2) * audioIn(n,chanIdx)) + (aCoeffs(1) * filterOut); */
        localDW->toneFilterStates[0] = bCoeffs_idx_1 * rtu_audioIn[q0] + aCoeffs
            * filterOut;

        /* '<S2042>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0] = (gain - 1.0F) * filterOut + rtu_audioIn[q0];

        /* '<S2042>:1:78' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(chanIdx); */
        filterOut_tmp = rtu_audioIn[q0 + 32];
        filterOut = filterOut_tmp * bCoeffs_idx_0 + localDW->toneFilterStates[1];

        /* '<S2042>:1:79' toneFilterStates(chanIdx) = (bCoeffs(2) * audioIn(n,chanIdx)) + (aCoeffs(1) * filterOut); */
        localDW->toneFilterStates[1] = filterOut_tmp * bCoeffs_idx_1 + aCoeffs *
            filterOut;

        /* '<S2042>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0 + 32] = (gain - 1.0F) * filterOut + filterOut_tmp;
    }

    /* '<S2042>:1:85' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)ramper - 1].currentGain
        = gain;
}

/* System initialize for atomic system: '<S7>/PreAmpPart1' */
void Model_Target_PreAmpPart1_Init(void)
{
    /* SystemInitialize for MATLAB Function: '<S2027>/MATLAB Function' */
    /* '<S2018>:1:10' currentFadeInd = 0; */
    /* '<S2018>:1:11' currentSig = uint32(0); */
    /* '<S2031>:1:11' state = single(1 * ones(1,channelCount)); */
    Model_Target_PreAmpPart1_DW.state[0] = 1.0F;
    Model_Target_PreAmpPart1_DW.state[1] = 1.0F;
}

/* Outputs for atomic system: '<S7>/PreAmpPart1' */
void Model_Target_PreAmpPart1(void)
{
    int32_T i;
    int32_T s;
    real32_T rtb_y_ba[64];
    real32_T rtb_out_d[32];
    real32_T rtb_thresh[32];
    real32_T musicVolumeLimited;
    real32_T musicVolumeLimited_tmp_0;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1978>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1978>/NTF Trigger' */
    for (i = 0; i < 64; i++)
    {
        /* Product: '<S2015>/Product' incorporates:
         *  S-Function (SampleRateConverter_sfunc): '<S2050>/S-Function'
         */
        Model_Target_PreAmpPart1_B.AttenuatedOutput[i] =
            Model_Target_B.SFunction_g[i] * Model_Target_PreAmp0.A;
    }

    /* MATLAB Function: '<S2017>/MaxAnnVolume' */
    /* MATLAB Function 'PreAmp/PreAmpPart1/NEARPreAmp/MusicLimiter/MaxAnnVolume': '<S2024>:1' */
    /* '<S2024>:1:3' out = single(ones(1,32)); */
    for (i = 0; i < 32; i++)
    {
        rtb_out_d[i] = 1.0F;
    }

    /* '<S2024>:1:4' for idx = 1:size(in, 2) */
    /* '<S2024>:1:5' out(idx) = max(in(:, idx)); */
    rtb_out_d[0] = Model_Target_B.Downsample[0];

    /* '<S2024>:1:5' out(idx) = max(in(:, idx)); */
    rtb_out_d[1] = Model_Target_B.Downsample[1];

    /* End of MATLAB Function: '<S2017>/MaxAnnVolume' */
    /* MATLAB Function: '<S2017>/Threshold Logic' incorporates:
     *  Constant: '<S2017>/MaxGain'
     *  Constant: '<S2017>/MinGain'
     *  Delay: '<S656>/Delay'
     *  MATLAB Function: '<S2027>/CalcThreshold'
     *  S-Function (TOP_MEX): '<S2027>/attack'
     */
    /*  Keep the music limited to the minimum of the specifed music threshold or */
    /*  the current level of the phone minus a tuned offset */
    /* MATLAB Function 'PreAmp/PreAmpPart1/NEARPreAmp/MusicLimiter/Threshold Logic': '<S2025>:1' */
    /* '<S2025>:1:5' thresh = single(annVolume); */
    /*  Limit announcement and entertainment volumes to 1 or less */
    /* '<S2025>:1:8' annVolumeLimited = min(1.0, annVolume); */
    /* '<S2025>:1:9' musicVolumeLimited = min(1.0, musicVolume); */
    musicVolumeLimited = fminf(1.0F, Model_Target_PreAmpPart1_DW.Delay_DSTATE);

    /*  Calculate target threshold */
    /* '<S2025>:1:12' annTargetLevel = predAnn * annVolumeLimited / (phoneOffsetLinear + eps); */
    /* '<S2025>:1:13' targetLevel = min(musicThreshLinear, annTargetLevel); */
    /* '<S2025>:1:14' musicVolumeSamp = musicVolumeLimited(floor((0:(numel(targetLevel)-1)) / frameSize) + 1); */
    /* '<S2025>:1:15' thresh = targetLevel ./ (musicVolumeSamp + eps); */
    /*  Check limits */
    /* '<S2025>:1:18' thresh = thresh / musicThreshLinear; */
    /* '<S2025>:1:19' thresh = min(maxGain, thresh); */
    /* '<S2025>:1:20' thresh = max(minGain, thresh); */
    /* MATLAB Function 'PreAmp/PreAmpPart1/NEARPreAmp/MusicLimiter/limiter/CalcThreshold': '<S2030>:1' */
    /* '<S2030>:1:3' thresholdOut = attack ./ single(thresholdIn); */
    for (i = 0; i < 32; i++)
    {
        rtb_thresh[i] = qhmath_div_f(Model_Target_PreAmp0.Limiterattack[i],
            fmaxf(9.99999902E-5F, fminf(1.0F, qhmath_div_f(qhmath_div_f(fminf
            (Model_Target_PreAmp0.UpperThreshold, qhmath_div_f
             (Model_Target_PreAmp0.AnnPred * fminf(1.0F, rtb_out_d[i]),
              Model_Target_PreAmp0.Offset + 2.22044605E-16F)),
            musicVolumeLimited + 2.22044605E-16F),
            Model_Target_PreAmp0.UpperThreshold))));
    }

    /* End of MATLAB Function: '<S2017>/Threshold Logic' */
    /* MATLAB Function: '<S2027>/MATLAB Function' incorporates:
     *  Product: '<S2015>/Product'
     *  S-Function (TOP_MEX): '<S2027>/attack'
     *  S-Function (TOP_MEX): '<S2027>/decay'
     *  S-Function (TOP_MEX): '<S2027>/maxAttack'
     */
    /*  Grab data from input */
    /* MATLAB Function 'PreAmp/PreAmpPart1/NEARPreAmp/MusicLimiter/limiter/MATLAB Function': '<S2031>:1' */
    /* '<S2031>:1:4' y = coder.nullcopy(u); */
    /* '<S2031>:1:5' [frameSize, channelCount] = size(u); */
    /* '<S2031>:1:7' maxGain = single(1); */
    /* '<S2031>:1:10' if isempty(state) */
    /*  Process the audio */
    /* '<S2031>:1:15' for i = 1:channelCount */
    for (i = 0; i < 2; i++)
    {
        /* '<S2031>:1:16' k0 = 1 + attack(i); */
        /* '<S2031>:1:17' g1 = state(i); */
        musicVolumeLimited = Model_Target_PreAmpPart1_DW.state[i];

        /* '<S2031>:1:19' for s = 1:frameSize */
        for (s = 0; s < 32; s++)
        {
            int32_T musicVolumeLimited_tmp;

            /*  Compute the gain for this sample. Implementation copied from BDSP */
            /* '<S2031>:1:21' p1 = k1(i) * g1; */
            /* '<S2031>:1:22' p2 = u(s, i); */
            /* '<S2031>:1:23' p2 = abs(p2); */
            /* '<S2031>:1:24' g1 = g1 * decay(i); */
            /* '<S2031>:1:25' p2 = p2 * p1; */
            /* '<S2031>:1:26' p2 = max(p2, attack(i)); */
            /* '<S2031>:1:27' p2 = k0 - p2; */
            /* '<S2031>:1:28' p2 = max(p2, maxAttack(i)); */
            /* '<S2031>:1:29' g1 = g1 * p2; */
            /* '<S2031>:1:30' g1 = min(g1, maxGain); */
            musicVolumeLimited_tmp = (i << 5) + s;
            musicVolumeLimited_tmp_0 =
                Model_Target_PreAmpPart1_B.AttenuatedOutput[musicVolumeLimited_tmp];
            musicVolumeLimited = fminf(fmaxf
                ((Model_Target_PreAmp0.Limiterattack[i] + 1.0F) - fmaxf
                 (rtb_thresh[i] * musicVolumeLimited * qhmath_abs_f
                  (musicVolumeLimited_tmp_0),
                  Model_Target_PreAmp0.Limiterattack[i]),
                 Model_Target_PreAmp0.LimitermaxAttack[i]) * (musicVolumeLimited
                * Model_Target_PreAmp0.Limiterdecay[i]), 1.0F);

            /*  Apply the gain */
            /* '<S2031>:1:33' y(s, i) = u(s, i) * g1; */
            rtb_y_ba[musicVolumeLimited_tmp] = musicVolumeLimited_tmp_0 *
                musicVolumeLimited;
        }

        /* '<S2031>:1:36' state(i) = g1; */
        Model_Target_PreAmpPart1_DW.state[i] = musicVolumeLimited;
    }

    /* End of MATLAB Function: '<S2027>/MATLAB Function' */

    /* Product: '<S2022>/Divide' incorporates:
     *  Constant: '<S2022>/Constant3'
     *  Selector: '<S2022>/Selector1'
     *  Selector: '<S2022>/Selector6'
     *  Sum: '<S2022>/Add'
     */
    for (i = 0; i < 32; i++)
    {
        rtb_out_d[i] = qhmath_div_f(rtb_y_ba[i + 32] + rtb_y_ba[i], 2.0F);
    }

    /* End of Product: '<S2022>/Divide' */
    for (i = 0; i < 32; i++)
    {
        /* Product: '<S2022>/Multiply' incorporates:
         *  Constant: '<S2022>/Constant4'
         *  Constant: '<S2022>/Constant5'
         *  Product: '<S2022>/Divide1'
         *  Selector: '<S2022>/Selector1'
         *  Selector: '<S2022>/Selector6'
         *  Sum: '<S2022>/Subtract'
         *  Sum: '<S2022>/Subtract1'
         */
        musicVolumeLimited = qhmath_div_f(rtb_y_ba[i] - rtb_y_ba[i + 32], 2.0F) *
            (1.0F - Model_Target_PreAmp0.G);

        /* Sum: '<S2022>/Add1' incorporates:
         *  Product: '<S2022>/Divide'
         */
        musicVolumeLimited_tmp_0 = rtb_out_d[i];
        rtb_y_ba[i] = musicVolumeLimited_tmp_0 + musicVolumeLimited;

        /* Sum: '<S2022>/Subtract2' incorporates:
         *  Product: '<S2022>/Divide'
         */
        rtb_y_ba[i + 32] = musicVolumeLimited_tmp_0 - musicVolumeLimited;
    }

    /* MATLAB Function: '<S2014>/Crossfade ' incorporates:
     *  Concatenate: '<S2022>/Matrix Concatenate'
     *  S-Function (SampleRateConverter_sfunc): '<S2050>/S-Function'
     */
    /*  fadetime in ms */
    /*  sigSelect = 0 passes normalEnt, sigSelect = 1 passes monoEnt */
    /* MATLAB Function 'CrossFader/Crossfade ': '<S2018>:1' */
    /*  first run init */
    /* '<S2018>:1:9' if (isempty(currentFadeInd)) */
    /*  Selection changed */
    /* '<S2018>:1:15' startFade = 0; */
    i = 0;

    /* '<S2018>:1:16' if (currentSig ~= sigSelect) */
    if (Model_Target_PreAmpPart1_DW.currentSig != Model_Target_B.y)
    {
        /*     currentSig = sigSelect; */
        /* '<S2018>:1:18' currentSig = uint32(sigSelect); */
        Model_Target_PreAmpPart1_DW.currentSig = Model_Target_B.y;

        /* '<S2018>:1:19' currentFadeInd = 0; */
        Model_Target_PreAmpPart1_DW.currentFadeInd = 0.0;

        /* '<S2018>:1:20' startFade = 1; */
        i = 1;
    }

    /* '<S2018>:1:23' crossfadedOutput = single(zeros(size(normalEnt))); */
    /* '<S2018>:1:24' normalEntOutput = single(zeros(size(normalEnt))); */
    /* '<S2018>:1:25' monoEntOutput = single(zeros(size(normalEnt))); */
    /*  Process the audio */
    /* '<S2018>:1:28' if ((currentFadeInd ~= 0)||(startFade)) */
    if ((Model_Target_PreAmpPart1_DW.currentFadeInd != 0.0) || (i != 0))
    {
        /*  Apply the cross fade gains, either because we're mid-ramp or we're */
        /*  starting over */
        /* '<S2018>:1:31' for (samp = 1:size(normalEnt, 1) */
        for (i = 0; i < 32; i++)
        {
            real_T monoEntGain;
            real_T normalEntGain;

            /* '<S2018>:1:32' currentFadeInd = currentFadeInd + 1; */
            Model_Target_PreAmpPart1_DW.currentFadeInd++;

            /*  lookup gains for this sample */
            /* '<S2018>:1:34' if (currentFadeInd > fadeSamples) */
            if (Model_Target_PreAmpPart1_DW.currentFadeInd >
                    Model_Target_PreAmpPart1_ConstB.Product)
            {
                /*  we hit the end of the ramp, but we're still working */
                /*  a frame that was ramping */
                /* '<S2018>:1:37' if (currentSig) */
                if (Model_Target_PreAmpPart1_DW.currentSig != 0U)
                {
                    /* '<S2018>:1:38' normalEntGain = 0; */
                    normalEntGain = 0.0;

                    /* '<S2018>:1:39' monoEntGain = 1; */
                    monoEntGain = 1.0;
                }
                else
                {
                    /* '<S2018>:1:40' else */
                    /* '<S2018>:1:41' normalEntGain = 1; */
                    normalEntGain = 1.0;

                    /* '<S2018>:1:42' monoEntGain = 0; */
                    monoEntGain = 0.0;
                }

                /* '<S2018>:1:44' else */
                /*  actively ramping */
                /* '<S2018>:1:46' if (currentSig) */
            }
            else if (Model_Target_PreAmpPart1_DW.currentSig != 0U)
            {
                /*                  sig1Gain = fadeDownGain(currentFadeInd); */
                /* '<S2018>:1:48' normalEntGain = 1-(currentFadeInd/fadeSamples); */
                monoEntGain = Model_Target_PreAmpPart1_DW.currentFadeInd /
                    Model_Target_PreAmpPart1_ConstB.Product;
                normalEntGain = 1.0 - monoEntGain;

                /*                  sig2Gain = fadeUpGain(currentFadeInd); */
                /* '<S2018>:1:50' monoEntGain = (currentFadeInd/fadeSamples); */
            }
            else
            {
                /* '<S2018>:1:51' else */
                /*                  sig1Gain = fadeUpGain(currentFadeInd); */
                /* '<S2018>:1:53' normalEntGain = (currentFadeInd/fadeSamples); */
                normalEntGain = Model_Target_PreAmpPart1_DW.currentFadeInd /
                    Model_Target_PreAmpPart1_ConstB.Product;

                /*                  sig2Gain = fadeDownGain(currentFadeInd); */
                /* '<S2018>:1:55' monoEntGain = 1-(currentFadeInd/fadeSamples); */
                monoEntGain = 1.0 - Model_Target_PreAmpPart1_DW.currentFadeInd /
                    Model_Target_PreAmpPart1_ConstB.Product;
            }

            /*  apply gains */
            /* '<S2018>:1:59' normalEntOutput(samp,:) = (normalEnt(samp,:)*normalEntGain); */
            /* '<S2018>:1:60' monoEntOutput(samp,:) = (monoEnt(samp,:)*monoEntGain); */
            /* '<S2018>:1:61' crossfadedOutput(samp,:) = single(normalEnt(samp,:)*normalEntGain + monoEnt(samp,:)*monoEntGain); */
            Model_Target_PreAmpPart1_B.crossfadedOutput[i] =
                Model_Target_B.SFunction_g[i] * (real32_T)normalEntGain +
                rtb_y_ba[i] * (real32_T)monoEntGain;
            Model_Target_PreAmpPart1_B.crossfadedOutput[i + 32] =
                Model_Target_B.SFunction_g[i + 32] * (real32_T)normalEntGain +
                rtb_y_ba[i + 32] * (real32_T)monoEntGain;
        }

        /*  reset fade if finished */
        /* '<S2018>:1:64' if (currentFadeInd > fadeSamples) */
        if (Model_Target_PreAmpPart1_DW.currentFadeInd >
                Model_Target_PreAmpPart1_ConstB.Product)
        {
            /* '<S2018>:1:65' currentFadeInd = 0; */
            Model_Target_PreAmpPart1_DW.currentFadeInd = 0.0;
        }

        /* '<S2018>:1:67' else */
        /*  Just pass selected signal */
        /* '<S2018>:1:69' if (currentSig) */
    }
    else if (Model_Target_PreAmpPart1_DW.currentSig != 0U)
    {
        /* '<S2018>:1:70' crossfadedOutput = single(monoEnt(1:size(normalEnt,1),1:size(normalEnt,2))); */
        memcpy(&Model_Target_PreAmpPart1_B.crossfadedOutput[0], &rtb_y_ba[0],
               sizeof(real32_T) << 6U);
    }
    else
    {
        /* '<S2018>:1:71' else */
        /* '<S2018>:1:72' crossfadedOutput = single(normalEnt); */
        memcpy(&Model_Target_PreAmpPart1_B.crossfadedOutput[0],
               &Model_Target_B.SFunction_g[0], sizeof(real32_T) << 6U);
    }

    /* End of MATLAB Function: '<S2014>/Crossfade ' */

    /* MATLAB Function: '<S1974>/tone' */
    Model_Target_tone(&(Model_Target_PreAmp0.BassBoostCoeffs[0]),
                      &(Model_Target_PreAmp0.BassCutCoeffs[0]),
                      Model_Target_PreAmpPart1_B.crossfadedOutput,
                      &Model_Target_PreAmpPart1_B.sf_tone,
                      &Model_Target_PreAmpPart1_DW.sf_tone);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1996>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1996>/NTF Trigger' */
    /* MATLAB Function: '<S1977>/tone' */
    Model_Target_tone_j(&(Model_Target_PreAmp0.TrebleBoostCoeffs[0]),
                        &(Model_Target_PreAmp0.TrebleCutCoeffs[0]),
                        Model_Target_PreAmpPart1_B.sf_tone.audioOut,
                        &Model_Target_PreAmpPart1_B.sf_tone_j,
                        &Model_Target_PreAmpPart1_DW.sf_tone_j);

    /* MATLAB Function: '<S1975>/tone' */
    Model_Target_tone_k(&(Model_Target_PreAmp0.MidrangeCfgBoostCoeffs[0]),
                        &(Model_Target_PreAmp0.MidrangeCfgCutCoeffs[0]),
                        Model_Target_PreAmpPart1_B.sf_tone_j.audioOut,
                        &Model_Target_PreAmpPart1_B.sf_tone_k,
                        &Model_Target_PreAmpPart1_DW.sf_tone_k);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2032>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2032>/NTF Trigger' */
}

/* Update for atomic system: '<S7>/PreAmpPart1' */
void Model_Target_PreAmpPart1_Update(void)
{
    /* Update for Delay: '<S656>/Delay' */
    Model_Target_PreAmpPart1_DW.Delay_DSTATE = Model_Target_B.gainSingleChannel;
}

/* System initialize for atomic system: '<S7>/SrcDownEnt' */
void Model_Target_SrcDownEnt_Init(void)
{
    int32_T i;

    /* Start for Constant: '<S2050>/coeffs' */
    memcpy(&Model_Target_B.coeffs_m[0], &Model_Target_ConstP.pooled56[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Start for Constant: '<S2050>/advance' */
        Model_Target_B.advance_a[i] = Model_Target_ConstP.pooled36[i];
    }

    /* InitializeConditions for S-Function (SampleRateConverter_sfunc): '<S2050>/S-Function' */

    // S-Function Block: <S2050>/S-Function (SampleRateConverter_sfunc)
    {
        // Temporary values/pointers
        int idx;
        int nCh = 2;
        int nFrameIn = 32;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = nFrameIn;
        else
            nFrameOut = (-1);

        // Pointer to filter coefficient blocks
        float *pFilter, *pFilterEnd, *pFilterCurr;
        int *pAdvance, *pAdvanceEnd, *pAdvanceCurr;
        int nBuffer;                   // Number of input samples

        // Pointer to input circular buffers and read/write pointers
        float **pInputBuffer, **pInputBufferEnd, **pInputWrite, **pInputRead;

        /*
         * Save filter and advance sample pointers
         */
        pFilter = (float*)(&Model_Target_B.coeffs_m[0]);
        pFilterEnd = pFilter + (240);
        pFilterCurr = pFilter;
        pAdvance = (int*)(&Model_Target_B.advance_a[0]);
        pAdvanceEnd = pAdvance + (12);
        pAdvanceCurr = pAdvance;

        /*
         * Allocate input buffers and pointers
         */

        // Calculate the number of input samples needed to produce output per input frame
        nBuffer = 2 * ceil(nFrameOut * (13) / (12)) + (20);

        // Quantize to input frame size
        nBuffer = (int)(ceil((float)nBuffer / (float)nFrameIn));//Number of frames
        if (nBuffer < 2)
            nBuffer = 2;               //Min num of frames = 2
        nBuffer = nBuffer * nFrameIn;

        // Allocate the circular buffers along with end/read/write pointers
        pInputBuffer = (float**)&Model_Target_DW.SFunction_pInputBuffer_p[0];
        pInputBufferEnd = (float**)&Model_Target_DW.SFunction_pInputBufferEnd_k
            [0];
        pInputWrite = (float**)&Model_Target_DW.SFunction_pInputWrite_j[0];
        pInputRead = (float**)&Model_Target_DW.SFunction_pInputRead_e[0];
        for (idx = 0; idx < nCh; idx++)
        {
            // Allocate twice what is needed ("double buffer")
            pInputBuffer[idx] = (float*)
                &Model_Target_DW.SFunction_InputBuffer_im[0] + (idx * nBuffer);
            pInputBufferEnd[idx] = pInputBuffer[idx] + nBuffer;
            pInputWrite[idx] = pInputBuffer[idx] ;
            pInputRead[idx] = pInputBuffer[idx] + (nBuffer >> 1) - 1;
        }

#if defined (__HEXAGON_ARCH__)
#ifdef MULITITHREAD

        Src_t* src = (Src_t*)&Model_Target_DW.SFunction_ThreadBuffer_c[0];
        int maxNumberOfThreads = MAX_THREAD_NUM;
        unsigned int tLoad = roundf((float) nCh / (float) maxNumberOfThreads);
        for (int i = 0; i < MAX_THREAD_NUM - 1; i++)
        {
            src->thread_arg[i].numChannels = tLoad;
            src->thread_arg[i].startChannel = i * tLoad;
        }

        //sum of number of channels processed by previous threads
        unsigned int lastTLoad = src->thread_arg[maxNumberOfThreads - 2].
            startChannel + src->thread_arg[maxNumberOfThreads - 2].numChannels;
        src->thread_arg[maxNumberOfThreads - 1].numChannels = nCh - lastTLoad;
        src->thread_arg[maxNumberOfThreads - 1].startChannel = lastTLoad;
        src->numThreadsToRun = maxNumberOfThreads;

        //calculation of filter output offset
        src->thread_arg[0].outOffset= 0;
        for (int i = 1 ;i < src->numThreadsToRun; i++)
        {
            src->thread_arg[i].outOffset = src->thread_arg[i - 1].outOffset +
                nFrameOut*src->thread_arg[i - 1].numChannels;
        }

        real32_T* pThreadStack = &Model_Target_DW.SFunction_ThreadStack_l[0];
        for (int i = 0; i < src->numThreadsToRun; i++)
        {
            qurt_sem_init_val(&src->thread_arg[i].semaWork, 0);
            qurt_sem_init_val(&src->thread_arg[i].semaDone, 0);
            src->thread_stack_addr[i] = pThreadStack+STACK_SIZE*i;
            qurt_thread_attr_init(&src->attr[i]);
            char threadName[THREAD_NAME_LEN];
            snprintf(threadName, THREAD_NAME_LEN, "SRC_%x", (unsigned int)
                     src->thread_stack_addr[i]);
            qurt_thread_attr_set_name(&src->attr[i], threadName);
            qurt_thread_attr_set_stack_addr(&src->attr[i],
                src->thread_stack_addr[i]);
            qurt_thread_attr_set_stack_size(&src->attr[i], STACK_SIZE);
            qurt_thread_attr_set_priority(&src->attr[i], 0);
            qurt_thread_create(&src->threads[i], &src->attr[i], src_thread,
                               (void *) &src->thread_arg[i]);
        }

#endif
#endif

        // Save pointers
        Model_Target_DW.SFunction_PWORK_h[0] = (void*)pInputBuffer;
        Model_Target_DW.SFunction_PWORK_h[1] = (void*)pInputBufferEnd;
        Model_Target_DW.SFunction_PWORK_h[2] = (void*)pInputWrite;
        Model_Target_DW.SFunction_PWORK_h[3] = (void*)pInputRead;
        Model_Target_DW.SFunction_PWORK_h[4] = (void*)pFilter;
        Model_Target_DW.SFunction_PWORK_h[5] = (void*)pFilterEnd;
        Model_Target_DW.SFunction_PWORK_h[6] = (void*)pFilterCurr;
        Model_Target_DW.SFunction_PWORK_h[7] = (void*)pAdvance;
        Model_Target_DW.SFunction_PWORK_h[8] = (void*)pAdvanceEnd;
        Model_Target_DW.SFunction_PWORK_h[9] = (void*)pAdvanceCurr;
        Model_Target_DW.SFunction_IWORK_f = nBuffer;
    }
}

/* Output and update for atomic system: '<S7>/SrcDownEnt' */
void Model_Target_SrcDownEntTID1(void)
{
    int_T tid = 1;

    /* S-Function (SampleRateConverter_sfunc): '<S2050>/S-Function' */
    /* Because the Outputs function of multirate block
       <S2050>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S2050>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 2;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction_g[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_h[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_h[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_h[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_h[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_h[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_h[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_h[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_h[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_h[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_h[9]);

#ifdef MULITITHREAD

            Src_t *src = (Src_t*)&(Model_Target_DW.SFunction_ThreadBuffer_c[0]);
            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                src->thread_arg[i].out = out;
                src->thread_arg[i].pInputBuffer = pInputBuffer;
                src->thread_arg[i].pInputBufferEnd = pInputBufferEnd;
                src->thread_arg[i].pInputWrite = pInputWrite;
                src->thread_arg[i].pInputRead = pInputRead;
                src->thread_arg[i].pFilter = pFilter;
                src->thread_arg[i].pFilterEnd = pFilterEnd;
                src->thread_arg[i].pFilterCurr = pFilterCurr;
                src->thread_arg[i].pAdvance = pAdvance;
                src->thread_arg[i].pAdvanceEnd = pAdvanceEnd;
                src->thread_arg[i].pAdvanceCurr = pAdvanceCurr;
                src->thread_arg[i].nFrameOut = nFrameOut;
                src->thread_arg[i].nFilterBlocks = 20;
                src->thread_arg[i].nBuffer = Model_Target_DW.SFunction_IWORK_f ;
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_up( &src->thread_arg[i].semaWork );
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_down( &src->thread_arg[i].semaDone );
            }

            Model_Target_DW.SFunction_PWORK_h[6] = (void*)src->thread_arg[0].
                pFilterCurr;
            Model_Target_DW.SFunction_PWORK_h[9] = (void*)src->thread_arg[0].
                pAdvanceCurr;

#else

            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh >> 1) << 1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_f;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_f * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_f;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_f;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_f *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_f *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_f;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_f * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_f;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_f * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_h[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_h[9] = (void*)pAdvanceCurr;

#endif

        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S2050>/S-Function' */
    /* Because the Update function of multirate block
       <S2050>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S2050>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 2;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector1[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_h[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_h[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_h[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_f) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Output and update for atomic system: '<S7>/SrcDownEnt' */
void Model_Target_SrcDownEntTID2(void)
{
    int_T tid = 2;
    int32_T i;

    /* Constant: '<S2050>/coeffs' */
    memcpy(&Model_Target_B.coeffs_m[0], &Model_Target_ConstP.pooled56[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Constant: '<S2050>/advance' */
        Model_Target_B.advance_a[i] = Model_Target_ConstP.pooled36[i];
    }

    /* S-Function (SampleRateConverter_sfunc): '<S2050>/S-Function' */
    /* Because the Outputs function of multirate block
       <S2050>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S2050>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 2;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction_g[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_h[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_h[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_h[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_h[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_h[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_h[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_h[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_h[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_h[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_h[9]);

#ifdef MULITITHREAD

            Src_t *src = (Src_t*)&(Model_Target_DW.SFunction_ThreadBuffer_c[0]);
            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                src->thread_arg[i].out = out;
                src->thread_arg[i].pInputBuffer = pInputBuffer;
                src->thread_arg[i].pInputBufferEnd = pInputBufferEnd;
                src->thread_arg[i].pInputWrite = pInputWrite;
                src->thread_arg[i].pInputRead = pInputRead;
                src->thread_arg[i].pFilter = pFilter;
                src->thread_arg[i].pFilterEnd = pFilterEnd;
                src->thread_arg[i].pFilterCurr = pFilterCurr;
                src->thread_arg[i].pAdvance = pAdvance;
                src->thread_arg[i].pAdvanceEnd = pAdvanceEnd;
                src->thread_arg[i].pAdvanceCurr = pAdvanceCurr;
                src->thread_arg[i].nFrameOut = nFrameOut;
                src->thread_arg[i].nFilterBlocks = 20;
                src->thread_arg[i].nBuffer = Model_Target_DW.SFunction_IWORK_f ;
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_up( &src->thread_arg[i].semaWork );
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_down( &src->thread_arg[i].semaDone );
            }

            Model_Target_DW.SFunction_PWORK_h[6] = (void*)src->thread_arg[0].
                pFilterCurr;
            Model_Target_DW.SFunction_PWORK_h[9] = (void*)src->thread_arg[0].
                pAdvanceCurr;

#else

            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh >> 1) << 1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_f;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_f * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_f;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_f;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_f *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_f *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_f;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_f * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_f;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_f * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_h[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_h[9] = (void*)pAdvanceCurr;

#endif

        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S2050>/S-Function' */
    /* Because the Update function of multirate block
       <S2050>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S2050>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 2;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector1[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_h[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_h[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_h[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_f) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Termination for atomic system: '<S7>/SrcDownEnt' */
void Model_Target_SrcDownEnt_Term(void)
{
    /* Terminate for S-Function (SampleRateConverter_sfunc): '<S2050>/S-Function' */

    /* S-Function Block: <S2050>/S-Function (SampleRateConverter_sfunc) */
    {
    }
}

/* System initialize for atomic system: '<S7>/SrcDownMic' */
void Model_Target_SrcDownMic_Init(void)
{
    int32_T i;

    /* Start for Constant: '<S2051>/coeffs' */
    memcpy(&Model_Target_B.coeffs[0], &Model_Target_ConstP.pooled56[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Start for Constant: '<S2051>/advance' */
        Model_Target_B.advance[i] = Model_Target_ConstP.pooled36[i];
    }

    /* InitializeConditions for S-Function (SampleRateConverter_sfunc): '<S2051>/S-Function' */

    // S-Function Block: <S2051>/S-Function (SampleRateConverter_sfunc)
    {
        // Temporary values/pointers
        int idx;
        int nCh = 1;
        int nFrameIn = 32;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = nFrameIn;
        else
            nFrameOut = (-1);

        // Pointer to filter coefficient blocks
        float *pFilter, *pFilterEnd, *pFilterCurr;
        int *pAdvance, *pAdvanceEnd, *pAdvanceCurr;
        int nBuffer;                   // Number of input samples

        // Pointer to input circular buffers and read/write pointers
        float **pInputBuffer, **pInputBufferEnd, **pInputWrite, **pInputRead;

        /*
         * Save filter and advance sample pointers
         */
        pFilter = (float*)(&Model_Target_B.coeffs[0]);
        pFilterEnd = pFilter + (240);
        pFilterCurr = pFilter;
        pAdvance = (int*)(&Model_Target_B.advance[0]);
        pAdvanceEnd = pAdvance + (12);
        pAdvanceCurr = pAdvance;

        /*
         * Allocate input buffers and pointers
         */

        // Calculate the number of input samples needed to produce output per input frame
        nBuffer = 2 * ceil(nFrameOut * (13) / (12)) + (20);

        // Quantize to input frame size
        nBuffer = (int)(ceil((float)nBuffer / (float)nFrameIn));//Number of frames
        if (nBuffer < 2)
            nBuffer = 2;               //Min num of frames = 2
        nBuffer = nBuffer * nFrameIn;

        // Allocate the circular buffers along with end/read/write pointers
        pInputBuffer = (float**)&Model_Target_DW.SFunction_pInputBuffer_d[0];
        pInputBufferEnd = (float**)&Model_Target_DW.SFunction_pInputBufferEnd_j
            [0];
        pInputWrite = (float**)&Model_Target_DW.SFunction_pInputWrite_f[0];
        pInputRead = (float**)&Model_Target_DW.SFunction_pInputRead_d[0];
        for (idx = 0; idx < nCh; idx++)
        {
            // Allocate twice what is needed ("double buffer")
            pInputBuffer[idx] = (float*)
                &Model_Target_DW.SFunction_InputBuffer_i[0] + (idx * nBuffer);
            pInputBufferEnd[idx] = pInputBuffer[idx] + nBuffer;
            pInputWrite[idx] = pInputBuffer[idx] ;
            pInputRead[idx] = pInputBuffer[idx] + (nBuffer >> 1) - 1;
        }

#if defined (__HEXAGON_ARCH__)
#ifdef MULITITHREAD

        Src_t* src = (Src_t*)&Model_Target_DW.SFunction_ThreadBuffer_o[0];
        int maxNumberOfThreads = MAX_THREAD_NUM;
        unsigned int tLoad = roundf((float) nCh / (float) maxNumberOfThreads);
        for (int i = 0; i < MAX_THREAD_NUM - 1; i++)
        {
            src->thread_arg[i].numChannels = tLoad;
            src->thread_arg[i].startChannel = i * tLoad;
        }

        //sum of number of channels processed by previous threads
        unsigned int lastTLoad = src->thread_arg[maxNumberOfThreads - 2].
            startChannel + src->thread_arg[maxNumberOfThreads - 2].numChannels;
        src->thread_arg[maxNumberOfThreads - 1].numChannels = nCh - lastTLoad;
        src->thread_arg[maxNumberOfThreads - 1].startChannel = lastTLoad;
        src->numThreadsToRun = maxNumberOfThreads;

        //calculation of filter output offset
        src->thread_arg[0].outOffset= 0;
        for (int i = 1 ;i < src->numThreadsToRun; i++)
        {
            src->thread_arg[i].outOffset = src->thread_arg[i - 1].outOffset +
                nFrameOut*src->thread_arg[i - 1].numChannels;
        }

        real32_T* pThreadStack = &Model_Target_DW.SFunction_ThreadStack_c[0];
        for (int i = 0; i < src->numThreadsToRun; i++)
        {
            qurt_sem_init_val(&src->thread_arg[i].semaWork, 0);
            qurt_sem_init_val(&src->thread_arg[i].semaDone, 0);
            src->thread_stack_addr[i] = pThreadStack+STACK_SIZE*i;
            qurt_thread_attr_init(&src->attr[i]);
            char threadName[THREAD_NAME_LEN];
            snprintf(threadName, THREAD_NAME_LEN, "SRC_%x", (unsigned int)
                     src->thread_stack_addr[i]);
            qurt_thread_attr_set_name(&src->attr[i], threadName);
            qurt_thread_attr_set_stack_addr(&src->attr[i],
                src->thread_stack_addr[i]);
            qurt_thread_attr_set_stack_size(&src->attr[i], STACK_SIZE);
            qurt_thread_attr_set_priority(&src->attr[i], 0);
            qurt_thread_create(&src->threads[i], &src->attr[i], src_thread,
                               (void *) &src->thread_arg[i]);
        }

#endif
#endif

        // Save pointers
        Model_Target_DW.SFunction_PWORK_n[0] = (void*)pInputBuffer;
        Model_Target_DW.SFunction_PWORK_n[1] = (void*)pInputBufferEnd;
        Model_Target_DW.SFunction_PWORK_n[2] = (void*)pInputWrite;
        Model_Target_DW.SFunction_PWORK_n[3] = (void*)pInputRead;
        Model_Target_DW.SFunction_PWORK_n[4] = (void*)pFilter;
        Model_Target_DW.SFunction_PWORK_n[5] = (void*)pFilterEnd;
        Model_Target_DW.SFunction_PWORK_n[6] = (void*)pFilterCurr;
        Model_Target_DW.SFunction_PWORK_n[7] = (void*)pAdvance;
        Model_Target_DW.SFunction_PWORK_n[8] = (void*)pAdvanceEnd;
        Model_Target_DW.SFunction_PWORK_n[9] = (void*)pAdvanceCurr;
        Model_Target_DW.SFunction_IWORK_m = nBuffer;
    }
}

/* Output and update for atomic system: '<S7>/SrcDownMic' */
void Model_Target_SrcDownMicTID1(void)
{
    int_T tid = 1;

    /* S-Function (SampleRateConverter_sfunc): '<S2051>/S-Function' */
    /* Because the Outputs function of multirate block
       <S2051>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S2051>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 1;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_n[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_n[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_n[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_n[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_n[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_n[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_n[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_n[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_n[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_n[9]);

#ifdef MULITITHREAD

            Src_t *src = (Src_t*)&(Model_Target_DW.SFunction_ThreadBuffer_o[0]);
            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                src->thread_arg[i].out = out;
                src->thread_arg[i].pInputBuffer = pInputBuffer;
                src->thread_arg[i].pInputBufferEnd = pInputBufferEnd;
                src->thread_arg[i].pInputWrite = pInputWrite;
                src->thread_arg[i].pInputRead = pInputRead;
                src->thread_arg[i].pFilter = pFilter;
                src->thread_arg[i].pFilterEnd = pFilterEnd;
                src->thread_arg[i].pFilterCurr = pFilterCurr;
                src->thread_arg[i].pAdvance = pAdvance;
                src->thread_arg[i].pAdvanceEnd = pAdvanceEnd;
                src->thread_arg[i].pAdvanceCurr = pAdvanceCurr;
                src->thread_arg[i].nFrameOut = nFrameOut;
                src->thread_arg[i].nFilterBlocks = 20;
                src->thread_arg[i].nBuffer = Model_Target_DW.SFunction_IWORK_m ;
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_up( &src->thread_arg[i].semaWork );
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_down( &src->thread_arg[i].semaDone );
            }

            Model_Target_DW.SFunction_PWORK_n[6] = (void*)src->thread_arg[0].
                pFilterCurr;
            Model_Target_DW.SFunction_PWORK_n[9] = (void*)src->thread_arg[0].
                pAdvanceCurr;

#else

            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh >> 1) << 1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_m;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_m * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_m;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_m;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_m *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_m *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_m;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_m * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_m;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_m * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_n[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_n[9] = (void*)pAdvanceCurr;

#endif

        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S2051>/S-Function' */
    /* Because the Update function of multirate block
       <S2051>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S2051>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 1;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector3[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_n[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_n[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_n[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_m) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Output and update for atomic system: '<S7>/SrcDownMic' */
void Model_Target_SrcDownMicTID2(void)
{
    int_T tid = 2;
    int32_T i;

    /* Constant: '<S2051>/coeffs' */
    memcpy(&Model_Target_B.coeffs[0], &Model_Target_ConstP.pooled56[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Constant: '<S2051>/advance' */
        Model_Target_B.advance[i] = Model_Target_ConstP.pooled36[i];
    }

    /* S-Function (SampleRateConverter_sfunc): '<S2051>/S-Function' */
    /* Because the Outputs function of multirate block
       <S2051>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S2051>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 1;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_n[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_n[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_n[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_n[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_n[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_n[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_n[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_n[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_n[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_n[9]);

#ifdef MULITITHREAD

            Src_t *src = (Src_t*)&(Model_Target_DW.SFunction_ThreadBuffer_o[0]);
            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                src->thread_arg[i].out = out;
                src->thread_arg[i].pInputBuffer = pInputBuffer;
                src->thread_arg[i].pInputBufferEnd = pInputBufferEnd;
                src->thread_arg[i].pInputWrite = pInputWrite;
                src->thread_arg[i].pInputRead = pInputRead;
                src->thread_arg[i].pFilter = pFilter;
                src->thread_arg[i].pFilterEnd = pFilterEnd;
                src->thread_arg[i].pFilterCurr = pFilterCurr;
                src->thread_arg[i].pAdvance = pAdvance;
                src->thread_arg[i].pAdvanceEnd = pAdvanceEnd;
                src->thread_arg[i].pAdvanceCurr = pAdvanceCurr;
                src->thread_arg[i].nFrameOut = nFrameOut;
                src->thread_arg[i].nFilterBlocks = 20;
                src->thread_arg[i].nBuffer = Model_Target_DW.SFunction_IWORK_m ;
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_up( &src->thread_arg[i].semaWork );
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_down( &src->thread_arg[i].semaDone );
            }

            Model_Target_DW.SFunction_PWORK_n[6] = (void*)src->thread_arg[0].
                pFilterCurr;
            Model_Target_DW.SFunction_PWORK_n[9] = (void*)src->thread_arg[0].
                pAdvanceCurr;

#else

            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh >> 1) << 1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_m;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_m * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_m;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_m;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_m *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_m *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_m;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_m * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_m;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_m * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_n[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_n[9] = (void*)pAdvanceCurr;

#endif

        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S2051>/S-Function' */
    /* Because the Update function of multirate block
       <S2051>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S2051>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 1;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector3[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_n[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_n[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_n[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_m) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Termination for atomic system: '<S7>/SrcDownMic' */
void Model_Target_SrcDownMic_Term(void)
{
    /* Terminate for S-Function (SampleRateConverter_sfunc): '<S2051>/S-Function' */

    /* S-Function Block: <S2051>/S-Function (SampleRateConverter_sfunc) */
    {
    }
}

/* System initialize for atomic system: '<S7>/SrcUp' */
void Model_Target_SrcUp_Init(void)
{
    /* InitializeConditions for S-Function (SampleRateConverter_sfunc): '<S2052>/S-Function' incorporates:
     *  Constant: '<S2052>/advance'
     *  Constant: '<S2052>/coeffs'
     */

    // S-Function Block: <S2052>/S-Function (SampleRateConverter_sfunc)
    {
        // Temporary values/pointers
        int idx;
        int nCh = 24;
        int nFrameIn = 32;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = nFrameIn;
        else
            nFrameOut = (-1);

        // Pointer to filter coefficient blocks
        float *pFilter, *pFilterEnd, *pFilterCurr;
        int *pAdvance, *pAdvanceEnd, *pAdvanceCurr;
        int nBuffer;                   // Number of input samples

        // Pointer to input circular buffers and read/write pointers
        float **pInputBuffer, **pInputBufferEnd, **pInputWrite, **pInputRead;

        /*
         * Save filter and advance sample pointers
         */
        pFilter = (float*)(Model_Target_ConstP.coeffs_Value);
        pFilterEnd = pFilter + (143);
        pFilterCurr = pFilter;
        pAdvance = (int*)(Model_Target_ConstP.advance_Value);
        pAdvanceEnd = pAdvance + (13);
        pAdvanceCurr = pAdvance;

        /*
         * Allocate input buffers and pointers
         */

        // Calculate the number of input samples needed to produce output per input frame
        nBuffer = 2 * ceil(nFrameOut * (12) / (13)) + (11);

        // Quantize to input frame size
        nBuffer = (int)(ceil((float)nBuffer / (float)nFrameIn));//Number of frames
        if (nBuffer < 2)
            nBuffer = 2;               //Min num of frames = 2
        nBuffer = nBuffer * nFrameIn;

        // Allocate the circular buffers along with end/read/write pointers
        pInputBuffer = (float**)&Model_Target_DW.SFunction_pInputBuffer[0];
        pInputBufferEnd = (float**)&Model_Target_DW.SFunction_pInputBufferEnd[0];
        pInputWrite = (float**)&Model_Target_DW.SFunction_pInputWrite[0];
        pInputRead = (float**)&Model_Target_DW.SFunction_pInputRead[0];
        for (idx = 0; idx < nCh; idx++)
        {
            // Allocate twice what is needed ("double buffer")
            pInputBuffer[idx] = (float*)&Model_Target_DW.SFunction_InputBuffer[0]
                + (idx * nBuffer);
            pInputBufferEnd[idx] = pInputBuffer[idx] + nBuffer;
            pInputWrite[idx] = pInputBuffer[idx] ;
            pInputRead[idx] = pInputBuffer[idx] + (nBuffer >> 1) - 1;
        }

#if defined (__HEXAGON_ARCH__)
#ifdef MULITITHREAD

        Src_t* src = (Src_t*)&Model_Target_DW.SFunction_ThreadBuffer[0];
        int maxNumberOfThreads = MAX_THREAD_NUM;
        unsigned int tLoad = roundf((float) nCh / (float) maxNumberOfThreads);
        for (int i = 0; i < MAX_THREAD_NUM - 1; i++)
        {
            src->thread_arg[i].numChannels = tLoad;
            src->thread_arg[i].startChannel = i * tLoad;
        }

        //sum of number of channels processed by previous threads
        unsigned int lastTLoad = src->thread_arg[maxNumberOfThreads - 2].
            startChannel + src->thread_arg[maxNumberOfThreads - 2].numChannels;
        src->thread_arg[maxNumberOfThreads - 1].numChannels = nCh - lastTLoad;
        src->thread_arg[maxNumberOfThreads - 1].startChannel = lastTLoad;
        src->numThreadsToRun = maxNumberOfThreads;

        //calculation of filter output offset
        src->thread_arg[0].outOffset= 0;
        for (int i = 1 ;i < src->numThreadsToRun; i++)
        {
            src->thread_arg[i].outOffset = src->thread_arg[i - 1].outOffset +
                nFrameOut*src->thread_arg[i - 1].numChannels;
        }

        real32_T* pThreadStack = &Model_Target_DW.SFunction_ThreadStack[0];
        for (int i = 0; i < src->numThreadsToRun; i++)
        {
            qurt_sem_init_val(&src->thread_arg[i].semaWork, 0);
            qurt_sem_init_val(&src->thread_arg[i].semaDone, 0);
            src->thread_stack_addr[i] = pThreadStack+STACK_SIZE*i;
            qurt_thread_attr_init(&src->attr[i]);
            char threadName[THREAD_NAME_LEN];
            snprintf(threadName, THREAD_NAME_LEN, "SRC_%x", (unsigned int)
                     src->thread_stack_addr[i]);
            qurt_thread_attr_set_name(&src->attr[i], threadName);
            qurt_thread_attr_set_stack_addr(&src->attr[i],
                src->thread_stack_addr[i]);
            qurt_thread_attr_set_stack_size(&src->attr[i], STACK_SIZE);
            qurt_thread_attr_set_priority(&src->attr[i], 0);
            qurt_thread_create(&src->threads[i], &src->attr[i], src_thread,
                               (void *) &src->thread_arg[i]);
        }

#endif
#endif

        // Save pointers
        Model_Target_DW.SFunction_PWORK[0] = (void*)pInputBuffer;
        Model_Target_DW.SFunction_PWORK[1] = (void*)pInputBufferEnd;
        Model_Target_DW.SFunction_PWORK[2] = (void*)pInputWrite;
        Model_Target_DW.SFunction_PWORK[3] = (void*)pInputRead;
        Model_Target_DW.SFunction_PWORK[4] = (void*)pFilter;
        Model_Target_DW.SFunction_PWORK[5] = (void*)pFilterEnd;
        Model_Target_DW.SFunction_PWORK[6] = (void*)pFilterCurr;
        Model_Target_DW.SFunction_PWORK[7] = (void*)pAdvance;
        Model_Target_DW.SFunction_PWORK[8] = (void*)pAdvanceEnd;
        Model_Target_DW.SFunction_PWORK[9] = (void*)pAdvanceCurr;
        Model_Target_DW.SFunction_IWORK = nBuffer;
    }
}

/* Output and update for atomic system: '<S7>/SrcUp' */
void Model_Target_SrcUpTID1(void)
{
    int_T tid = 1;

    /* S-Function (SampleRateConverter_sfunc): '<S2052>/S-Function' incorporates:
     *  Constant: '<S2052>/advance'
     *  Constant: '<S2052>/coeffs'
     */
    /* Because the Outputs function of multirate block
       <S2052>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S2052>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 24;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 1)
        {
            float *out = (float*)(&Model_Target_B.MatrixConcatenate[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK[0]);
            float **pInputBufferEnd = (float**)(Model_Target_DW.SFunction_PWORK
                [1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK[9]);

#ifdef MULITITHREAD

            Src_t *src = (Src_t*)&(Model_Target_DW.SFunction_ThreadBuffer[0]);
            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                src->thread_arg[i].out = out;
                src->thread_arg[i].pInputBuffer = pInputBuffer;
                src->thread_arg[i].pInputBufferEnd = pInputBufferEnd;
                src->thread_arg[i].pInputWrite = pInputWrite;
                src->thread_arg[i].pInputRead = pInputRead;
                src->thread_arg[i].pFilter = pFilter;
                src->thread_arg[i].pFilterEnd = pFilterEnd;
                src->thread_arg[i].pFilterCurr = pFilterCurr;
                src->thread_arg[i].pAdvance = pAdvance;
                src->thread_arg[i].pAdvanceEnd = pAdvanceEnd;
                src->thread_arg[i].pAdvanceCurr = pAdvanceCurr;
                src->thread_arg[i].nFrameOut = nFrameOut;
                src->thread_arg[i].nFilterBlocks = 11;
                src->thread_arg[i].nBuffer = Model_Target_DW.SFunction_IWORK ;
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_up( &src->thread_arg[i].semaWork );
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_down( &src->thread_arg[i].semaDone );
            }

            Model_Target_DW.SFunction_PWORK[6] = (void*)src->thread_arg[0].
                pFilterCurr;
            Model_Target_DW.SFunction_PWORK[9] = (void*)src->thread_arg[0].
                pAdvanceCurr;

#else

            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh >> 1) << 1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK * sizeof
                                      (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK;
                            pIn2 -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK * sizeof
                                       (float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK * sizeof
                                       (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK * sizeof
                                      (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK[9] = (void*)pAdvanceCurr;

#endif

        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S2052>/S-Function' incorporates:
     *  Constant: '<S2052>/advance'
     *  Constant: '<S2052>/coeffs'
     */
    /* Because the Update function of multirate block
       <S2052>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S2052>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 24;
        int nFrameIn = 32;
        if (tid == 2)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_MedusaPostHoligram_B.Merge[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)(Model_Target_DW.SFunction_PWORK
                [1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch], (Model_Target_DW.SFunction_IWORK)
                    * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Output and update for atomic system: '<S7>/SrcUp' */
void Model_Target_SrcUpTID2(void)
{
    int_T tid = 2;

    /* S-Function (SampleRateConverter_sfunc): '<S2052>/S-Function' incorporates:
     *  Constant: '<S2052>/advance'
     *  Constant: '<S2052>/coeffs'
     */
    /* Because the Outputs function of multirate block
       <S2052>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S2052>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 24;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 1)
        {
            float *out = (float*)(&Model_Target_B.MatrixConcatenate[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK[0]);
            float **pInputBufferEnd = (float**)(Model_Target_DW.SFunction_PWORK
                [1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK[9]);

#ifdef MULITITHREAD

            Src_t *src = (Src_t*)&(Model_Target_DW.SFunction_ThreadBuffer[0]);
            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                src->thread_arg[i].out = out;
                src->thread_arg[i].pInputBuffer = pInputBuffer;
                src->thread_arg[i].pInputBufferEnd = pInputBufferEnd;
                src->thread_arg[i].pInputWrite = pInputWrite;
                src->thread_arg[i].pInputRead = pInputRead;
                src->thread_arg[i].pFilter = pFilter;
                src->thread_arg[i].pFilterEnd = pFilterEnd;
                src->thread_arg[i].pFilterCurr = pFilterCurr;
                src->thread_arg[i].pAdvance = pAdvance;
                src->thread_arg[i].pAdvanceEnd = pAdvanceEnd;
                src->thread_arg[i].pAdvanceCurr = pAdvanceCurr;
                src->thread_arg[i].nFrameOut = nFrameOut;
                src->thread_arg[i].nFilterBlocks = 11;
                src->thread_arg[i].nBuffer = Model_Target_DW.SFunction_IWORK ;
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_up( &src->thread_arg[i].semaWork );
            }

            for (int i = 0; i < MAX_THREAD_NUM; i++)
            {
                qurt_sem_down( &src->thread_arg[i].semaDone );
            }

            Model_Target_DW.SFunction_PWORK[6] = (void*)src->thread_arg[0].
                pFilterCurr;
            Model_Target_DW.SFunction_PWORK[9] = (void*)src->thread_arg[0].
                pAdvanceCurr;

#else

            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh >> 1) << 1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK * sizeof
                                      (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK;
                            pIn2 -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK * sizeof
                                       (float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK * sizeof
                                       (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK * sizeof
                                      (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK[9] = (void*)pAdvanceCurr;

#endif

        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S2052>/S-Function' incorporates:
     *  Constant: '<S2052>/advance'
     *  Constant: '<S2052>/coeffs'
     */
    /* Because the Update function of multirate block
       <S2052>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S2052>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 24;
        int nFrameIn = 32;
        if (tid == 2)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_MedusaPostHoligram_B.Merge[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)(Model_Target_DW.SFunction_PWORK
                [1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch], (Model_Target_DW.SFunction_IWORK)
                    * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Termination for atomic system: '<S7>/SrcUp' */
void Model_Target_SrcUp_Term(void)
{
    /* Terminate for S-Function (SampleRateConverter_sfunc): '<S2052>/S-Function' incorporates:
     *  Constant: '<S2052>/advance'
     *  Constant: '<S2052>/coeffs'
     */

    /* S-Function Block: <S2052>/S-Function (SampleRateConverter_sfunc) */
    {
    }
}

/*
 * Function for MATLAB Function: '<S38>/MATLAB Function'
 * function mixOut = Mixer(audioIn, loc, gainMatrix, interp)
 */
static void Model_Target_Mixer(const real32_T audioIn[8], const real32_T loc[2],
    const real32_T gainMatrix[25], real_T interp, real32_T mixOut[8])
{
    int32_T x1;
    real32_T x;
    real32_T y;

    /*   */
    /* '<S75>:1:29' s = size(gainMatrix); */
    /* '<S75>:1:30' x = min(s(1), max(1, loc(1)*(s(1)-1)+1)); */
    x = fminf(5.0F, fmaxf(1.0F, loc[0] * 4.0F + 1.0F));

    /* '<S75>:1:31' y = min(s(2), max(1, loc(2)*(s(2)-1)+1)); */
    y = fminf(5.0F, fmaxf(1.0F, loc[1] * 4.0F + 1.0F));

    /* '<S75>:1:33' if interp == 1 */
    if (interp == 1.0)
    {
        int32_T b_y1;
        int8_T c_idx_0;
        int8_T d_idx_0;
        int8_T e_idx_0;
        int8_T f_idx_0;

        /* '<S75>:1:34' x1 =  floor(x); */
        x1 = (int32_T)qhmath_floor_f(x);

        /* '<S75>:1:35' x2 = x1 + 1; */
        /* '<S75>:1:36' y1 =  floor(y); */
        b_y1 = (int32_T)qhmath_floor_f(y);

        /* '<S75>:1:37' y2 = y1+1; */
        /* '<S75>:1:38' overIdx = (x2 > s(1)); */
        /* '<S75>:1:39' x1(overIdx) = x1(overIdx) - 1; */
        c_idx_0 = (int8_T)x1;

        /* '<S75>:1:40' x2(overIdx) = x2(overIdx) - 1; */
        d_idx_0 = (int8_T)(x1 + 1);
        if (x1 + 1 > 5)
        {
            c_idx_0 = (int8_T)(x1 - 1);
            d_idx_0 = (int8_T)x1;
        }

        /* '<S75>:1:41' overIdy = (y2 > s(2)); */
        /* '<S75>:1:42' y1(overIdy) = y1(overIdy) - 1; */
        e_idx_0 = (int8_T)b_y1;

        /* '<S75>:1:43' y2(overIdy) = y2(overIdy) - 1; */
        f_idx_0 = (int8_T)(b_y1 + 1);
        if (b_y1 + 1 > 5)
        {
            e_idx_0 = (int8_T)(b_y1 - 1);
            f_idx_0 = (int8_T)b_y1;
        }

        /* '<S75>:1:44' a = x-x1; */
        x -= (real32_T)c_idx_0;

        /* '<S75>:1:45' b = y-y1; */
        y -= (real32_T)e_idx_0;

        /* '<S75>:1:46' gmp = gainMatrix; */
        /* '<S75>:1:47' g00 = gmp(x1,y1); */
        /* '<S75>:1:48' g01 = gmp(x1,y2); */
        /* '<S75>:1:49' g10 = gmp(x2,y1); */
        /* '<S75>:1:50' g11 = gmp(x2,y2); */
        /* '<S75>:1:52' g = g00*(1-a)*(1-b) + g01*(1-a)*(b) + g10*(1-b)*(a) + g11*(a)*(b); */
        x1 = (e_idx_0 - 1) * 5;
        b_y1 = (f_idx_0 - 1) * 5;
        y = ((gainMatrix[(x1 + c_idx_0) - 1] * (1.0F - x) * (1.0F - y) +
              gainMatrix[(b_y1 + c_idx_0) - 1] * (1.0F - x) * y) + gainMatrix
             [(x1 + d_idx_0) - 1] * (1.0F - y) * x) + gainMatrix[(b_y1 + d_idx_0)
            - 1] * x * y;
    }
    else
    {
        /* '<S75>:1:53' else */
        /* '<S75>:1:54' g = gainMatrix(floor(x),floor(y)); */
        y = gainMatrix[(int32_T)((qhmath_floor_f(y) - 1.0F) * 5.0F +
            qhmath_floor_f(x)) - 1];
    }

    /* '<S75>:1:57' mixOut = g*audioIn; */
    for (x1 = 0; x1 < 8; x1++)
    {
        mixOut[x1] = y * audioIn[x1];
    }
}

/*
 * Function for MATLAB Function: '<S82>/MATLAB Function'
 * function mixOut = Mixer(audioIn, loc, gainMatrix, interp)
 */
static void Model_Target_Mixer_l(const real32_T audioIn[32], const real32_T loc
    [2], const real32_T gainMatrix[25], real_T interp, real32_T mixOut[32])
{
    int32_T x1;
    real32_T x;
    real32_T y;

    /*   */
    /* '<S119>:1:29' s = size(gainMatrix); */
    /* '<S119>:1:30' x = min(s(1), max(1, loc(1)*(s(1)-1)+1)); */
    x = fminf(5.0F, fmaxf(1.0F, loc[0] * 4.0F + 1.0F));

    /* '<S119>:1:31' y = min(s(2), max(1, loc(2)*(s(2)-1)+1)); */
    y = fminf(5.0F, fmaxf(1.0F, loc[1] * 4.0F + 1.0F));

    /* '<S119>:1:33' if interp == 1 */
    if (interp == 1.0)
    {
        int32_T b_y1;
        int8_T c_idx_0;
        int8_T d_idx_0;
        int8_T e_idx_0;
        int8_T f_idx_0;

        /* '<S119>:1:34' x1 =  floor(x); */
        x1 = (int32_T)qhmath_floor_f(x);

        /* '<S119>:1:35' x2 = x1 + 1; */
        /* '<S119>:1:36' y1 =  floor(y); */
        b_y1 = (int32_T)qhmath_floor_f(y);

        /* '<S119>:1:37' y2 = y1+1; */
        /* '<S119>:1:38' overIdx = (x2 > s(1)); */
        /* '<S119>:1:39' x1(overIdx) = x1(overIdx) - 1; */
        c_idx_0 = (int8_T)x1;

        /* '<S119>:1:40' x2(overIdx) = x2(overIdx) - 1; */
        d_idx_0 = (int8_T)(x1 + 1);
        if (x1 + 1 > 5)
        {
            c_idx_0 = (int8_T)(x1 - 1);
            d_idx_0 = (int8_T)x1;
        }

        /* '<S119>:1:41' overIdy = (y2 > s(2)); */
        /* '<S119>:1:42' y1(overIdy) = y1(overIdy) - 1; */
        e_idx_0 = (int8_T)b_y1;

        /* '<S119>:1:43' y2(overIdy) = y2(overIdy) - 1; */
        f_idx_0 = (int8_T)(b_y1 + 1);
        if (b_y1 + 1 > 5)
        {
            e_idx_0 = (int8_T)(b_y1 - 1);
            f_idx_0 = (int8_T)b_y1;
        }

        /* '<S119>:1:44' a = x-x1; */
        x -= (real32_T)c_idx_0;

        /* '<S119>:1:45' b = y-y1; */
        y -= (real32_T)e_idx_0;

        /* '<S119>:1:46' gmp = gainMatrix; */
        /* '<S119>:1:47' g00 = gmp(x1,y1); */
        /* '<S119>:1:48' g01 = gmp(x1,y2); */
        /* '<S119>:1:49' g10 = gmp(x2,y1); */
        /* '<S119>:1:50' g11 = gmp(x2,y2); */
        /* '<S119>:1:52' g = g00*(1-a)*(1-b) + g01*(1-a)*(b) + g10*(1-b)*(a) + g11*(a)*(b); */
        x1 = (e_idx_0 - 1) * 5;
        b_y1 = (f_idx_0 - 1) * 5;
        y = ((gainMatrix[(x1 + c_idx_0) - 1] * (1.0F - x) * (1.0F - y) +
              gainMatrix[(b_y1 + c_idx_0) - 1] * (1.0F - x) * y) + gainMatrix
             [(x1 + d_idx_0) - 1] * (1.0F - y) * x) + gainMatrix[(b_y1 + d_idx_0)
            - 1] * x * y;
    }
    else
    {
        /* '<S119>:1:53' else */
        /* '<S119>:1:54' g = gainMatrix(floor(x),floor(y)); */
        y = gainMatrix[(int32_T)((qhmath_floor_f(y) - 1.0F) * 5.0F +
            qhmath_floor_f(x)) - 1];
    }

    /* '<S119>:1:57' mixOut = g*audioIn; */
    for (x1 = 0; x1 < 32; x1++)
    {
        mixOut[x1] = y * audioIn[x1];
    }
}

/* Function for MATLAB Function: '<S735>/BoostMapAdjustments' */
static real32_T Model_Target_interp1(const real32_T varargin_1[2], const
    real32_T varargin_2[2], real32_T varargin_3)
{
    real32_T Vq;
    real32_T r;
    real32_T x_idx_1;
    real32_T y_idx_0;
    real32_T y_idx_1;
    y_idx_0 = varargin_2[0];
    r = varargin_1[0];
    y_idx_1 = varargin_2[1];
    x_idx_1 = varargin_1[1];
    if (varargin_1[1] < varargin_1[0])
    {
        r = varargin_1[1];
        x_idx_1 = varargin_1[0];
        y_idx_0 = varargin_2[1];
        y_idx_1 = varargin_2[0];
    }

    Vq = 0.0F;
    if ((varargin_3 <= x_idx_1) && (varargin_3 >= r))
    {
        r = qhmath_div_f(varargin_3 - r, x_idx_1 - r);
        if (r == 0.0F)
        {
            Vq = y_idx_0;
        }
        else if (r == 1.0F)
        {
            Vq = y_idx_1;
        }
        else if (y_idx_0 == y_idx_1)
        {
            Vq = y_idx_0;
        }
        else
        {
            Vq = (1.0F - r) * y_idx_0 + r * y_idx_1;
        }
    }

    return Vq;
}

/* Function for MATLAB Function: '<S1142>/balanceProcess' */
static void Model_Target_eml_find_a(const boolean_T x[2], int32_T i_data[],
    int32_T i_size[2])
{
    int32_T idx;
    int32_T ii;
    boolean_T exitg1;
    idx = 0;
    i_size[0] = 1;
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii < 2))
    {
        if (x[ii])
        {
            idx++;
            i_data[idx - 1] = ii + 1;
            if (idx >= 2)
            {
                exitg1 = true;
            }
            else
            {
                ii++;
            }
        }
        else
        {
            ii++;
        }
    }

    if (idx < 1)
    {
        i_size[1] = 0;
    }
    else
    {
        i_size[1] = idx;
    }
}

/* Function for MATLAB Function: '<S918>/ComputePmin' */
static real32_T Model_Target_mod(real32_T x, real32_T y)
{
    real32_T r;
    r = x;
    if (y == 0.0F)
    {
        if (x == 0.0F)
        {
            r = y;
        }
    }
    else if (x == 0.0F)
    {
        r = qhmath_div_f(0.0F, y);
    }
    else
    {
        boolean_T rEQ0;
        r = fmodf(x, y);
        rEQ0 = (r == 0.0F);
        if ((!rEQ0) && (y > qhmath_floor_f(y)))
        {
            real32_T q;
            q = qhmath_abs_f(qhmath_div_f(x, y));
            rEQ0 = (qhmath_abs_f(q - qhmath_floor_f(q + 0.5F)) <= 1.1920929E-7F *
                    q);
        }

        if (rEQ0)
        {
            r = 0.0F;
        }
        else if ((x < 0.0F) != (y < 0.0F))
        {
            r += y;
        }
    }

    return r;
}

/* Function for MATLAB Function: '<S1022>/SpeedBounds' */
static real32_T Model_Target_interp1_m(const real32_T varargin_1[128], const
    real32_T varargin_2[128], real32_T varargin_3)
{
    int32_T i;
    real32_T x[128];
    real32_T y[128];
    real32_T Vq;
    real32_T xtmp;
    memcpy(&y[0], &varargin_2[0], sizeof(real32_T) << 7U);
    memcpy(&x[0], &varargin_1[0], sizeof(real32_T) << 7U);
    if (varargin_1[1] < varargin_1[0])
    {
        for (i = 0; i < 64; i++)
        {
            xtmp = x[i];
            x[i] = x[127 - i];
            x[127 - i] = xtmp;
            xtmp = y[i];
            y[i] = y[127 - i];
            y[127 - i] = xtmp;
        }
    }

    Vq = 0.0F;
    if ((varargin_3 <= x[127]) && (varargin_3 >= x[0]))
    {
        int32_T low_i;
        int32_T low_ip1;
        i = 128;
        low_i = 1;
        low_ip1 = 2;
        while (i > low_ip1)
        {
            int32_T mid_i;
            mid_i = (low_i + i) >> 1;
            if (varargin_3 >= x[mid_i - 1])
            {
                low_i = mid_i;
                low_ip1 = mid_i + 1;
            }
            else
            {
                i = mid_i;
            }
        }

        xtmp = x[low_i - 1];
        xtmp = qhmath_div_f(varargin_3 - xtmp, x[low_i] - xtmp);
        if (xtmp == 0.0F)
        {
            Vq = y[low_i - 1];
        }
        else if (xtmp == 1.0F)
        {
            Vq = y[low_i];
        }
        else
        {
            Vq = y[low_i - 1];
            if (Vq != y[low_i])
            {
                Vq = (1.0F - xtmp) * Vq + xtmp * y[low_i];
            }
        }
    }

    return Vq;
}

/* Model step function for TID0 */
void Model_Target_step0(void)  /* Sample time: [5.5555555555555551E-5s, 0.0s] */
{
    {                          /* Sample time: [5.5555555555555551E-5s, 0.0s] */
        rate_monotonic_scheduler();
    }
}

/* Model step function for TID1 */
void Model_Target_step1(void) /* Sample time: [0.00066666666666666664s, 0.0s] */
{
    /* local scratch DWork variables */
    int32_T ForEach_itr;
    int32_T mainSelect[24];
    int32_T i;
    int32_T i_0;
    int32_T rtb_enableAuxFlag;
    real32_T tmp;

    /* Outputs for Atomic SubSystem: '<S7>/SrcUp' */
    Model_Target_SrcUpTID1();

    /* End of Outputs for SubSystem: '<S7>/SrcUp' */

    /* Outputs for Atomic SubSystem: '<Root>/TestRouter' */
    /* SignalConversion generated from: '<S9>/Matrix Concatenate' */
    memset(&Model_Target_B.MatrixConcatenate[768], 0, 768U * sizeof(real32_T));

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2062>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S2060>/get_mainCh_parameters' incorporates:
     *  S-Function (TOP_MEX): '<S2085>/TOP'
     */
    /*  % RTC message parameter */
    /*  Tune parameter */
    /* MATLAB Function 'TestRouter/ASDRouter/InnerLink/MainChannelSystem/get_mainCh_parameters': '<S2086>:1' */
    /*  Main Select is provided to the block through Tune variables. However  */
    /*  if parameters are provided through RTC, the block will use the values  */
    /*  given in the RTC messages.     */
    /* '<S2086>:1:7' mainSelect = int32(mainSelectTune); */
    /* '<S2086>:1:8' for ind=1:size(mainSelectRTC,1) */
    for (i = 0; i < 24; i++)
    {
        mainSelect[i] = Model_Target_TestRouter0.ASDRouterMainSelect[i];

        /*  If MSB of mainSelectRTC is set to '1', it means Tune values are to be used and not RTC value */
        /* '<S2086>:1:10' if (~bitget(mainSelectRTC(ind),32)) */
        if ((Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_mainSelect[i] &
             MIN_int32_T) == 0)
        {
            /* '<S2086>:1:11' mainSelect(ind) = mainSelectRTC(ind); */
            mainSelect[i] =
                Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_mainSelect[i];
        }
    }

    /* End of MATLAB Function: '<S2060>/get_mainCh_parameters' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2061>/RTC Request Response Trigger' */

    /* Outputs for Iterator SubSystem: '<S2060>/MainChannelSubSystem' incorporates:
     *  ForEach: '<S2084>/For Each'
     */
    for (ForEach_itr = 0; ForEach_itr < 24; ForEach_itr++)
    {
        /* Outputs for IfAction SubSystem: '<S2087>/If Action Subsystem' incorporates:
         *  ActionPort: '<S2088>/Action Port'
         */
        /* If: '<S2087>/If1' incorporates:
         *  ForEachSliceSelector generated from: '<S2084>/pMainSelect_in'
         *  S-Function (sdspperm2): '<S2088>/Variable Selector1'
         */
        i = mainSelect[ForEach_itr] - 1;

        /* End of Outputs for SubSystem: '<S2087>/If Action Subsystem' */
        if (mainSelect[ForEach_itr] > 0)
        {
            /* Outputs for IfAction SubSystem: '<S2087>/If Action Subsystem' incorporates:
             *  ActionPort: '<S2088>/Action Port'
             */
            if (i < 0)
            {
                i = 0;
            }
            else if (i >= 48)
            {
                i = 47;
            }

            /* End of Outputs for SubSystem: '<S2087>/If Action Subsystem' */

            /* ForEachSliceSelector generated from: '<S2084>/pMainGain_in' */
            tmp =
                Model_TargetTestRouterASDRouterMainGainRtcOut.REQ_mainGain[ForEach_itr];

            /* Outputs for IfAction SubSystem: '<S2087>/If Action Subsystem' incorporates:
             *  ActionPort: '<S2088>/Action Port'
             */
            for (rtb_enableAuxFlag = 0; rtb_enableAuxFlag < 32;
                    rtb_enableAuxFlag++)
            {
                /* ForEachSliceAssignment generated from: '<S2084>/Out1' incorporates:
                 *  Concatenate: '<S9>/Matrix Concatenate'
                 *  Product: '<S2088>/Multiply'
                 */
                Model_Target_B.ImpAsg_InsertedFor_Out1_at_inport_0_m[rtb_enableAuxFlag
                    + (ForEach_itr << 5)] = Model_Target_B.MatrixConcatenate[(i <<
                    5) + rtb_enableAuxFlag] * tmp;
            }

            /* End of Outputs for SubSystem: '<S2087>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2087>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S2089>/Action Port'
             */
            for (i_0 = 0; i_0 < 32; i_0++)
            {
                /* ForEachSliceAssignment generated from: '<S2084>/Out1' incorporates:
                 *  Constant: '<S2089>/Constant'
                 *  SignalConversion generated from: '<S2089>/Out1'
                 */
                Model_Target_B.ImpAsg_InsertedFor_Out1_at_inport_0_m[i_0 +
                    (ForEach_itr << 5)] = 0.0F;
            }

            /* End of Outputs for SubSystem: '<S2087>/If Action Subsystem1' */
        }

        /* End of If: '<S2087>/If1' */
    }

    /* End of Outputs for SubSystem: '<S2060>/MainChannelSubSystem' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2057>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2059>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S2056>/get_auxCh_parameters' incorporates:
     *  S-Function (TOP_MEX): '<S2054>/TOP'
     */
    rtb_enableAuxFlag = Model_Target_TestRouter0.ASDRouterEnableAux;

    /*  % RTC message parameters */
    /*  Tune parameters */
    /* MATLAB Function 'TestRouter/ASDRouter/InnerLink/AuxChannel_with_MATLAB_function/get_auxCh_parameters': '<S2065>:1' */
    /*  Aux Select and Enable Aux are provided to the block through Tune variables. However  */
    /*  if parameters are provided through RTC, the block will use the values  */
    /*  given in the RTC messages.     */
    /* '<S2065>:1:8' enableAuxFlag = int32(enableAuxFlagTune); */
    /* '<S2065>:1:9' auxSelect = int32(auxSelectTune); */
    /*  If MSB of auxSelectRTC/enableAuxFlagRTC is set to '1', it means Tune */
    /*  values are to be used and not RTC values */
    /* '<S2065>:1:13' for ind=1:size(auxSelectRTC,1) */
    for (i = 0; i < 24; i++)
    {
        mainSelect[i] = Model_Target_TestRouter0.AuxSelect[i];

        /* '<S2065>:1:14' if (~bitget(auxSelectRTC(ind),32)) */
        if ((Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_AuxSelect[i] &
                MIN_int32_T) == 0)
        {
            /* '<S2065>:1:15' auxSelect(ind) = auxSelectRTC(ind); */
            mainSelect[i] =
                Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_AuxSelect[i];
        }
    }

    /* '<S2065>:1:19' for ind=1:length(enableAuxFlagRTC) */
    /* '<S2065>:1:20' if(~bitget(enableAuxFlagRTC(ind),32)) */
    if ((Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_EnableAuxFlag &
            MIN_int32_T) == 0)
    {
        /* '<S2065>:1:21' enableAuxFlag(ind) = enableAuxFlagRTC(ind); */
        rtb_enableAuxFlag =
            Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_EnableAuxFlag;
    }

    /* End of MATLAB Function: '<S2056>/get_auxCh_parameters' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2058>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S2056>/AuxChannelSubSystem' incorporates:
     *  Concatenate: '<S9>/Matrix Concatenate'
     *  Constant: '<S2056>/inputOffset'
     *  Constant: '<S2056>/numAux'
     *  ForEachSliceAssignment generated from: '<S2084>/Out1'
     */
    memcpy(&Model_Target_B.out[0],
           &Model_Target_B.ImpAsg_InsertedFor_Out1_at_inport_0_m[0], 768U *
           sizeof(real32_T));

    /*  initial inputOffset is the number of ENT inputs */
    /* MATLAB Function 'TestRouter/ASDRouter/InnerLink/AuxChannel_with_MATLAB_function/AuxChannelSubSystem': '<S2063>:1' */
    /* '<S2063>:1:4' for i=1:length(numAux) */
    /* '<S2063>:1:5' if(enableAux(i)) */
    if (rtb_enableAuxFlag != 0)
    {
        /* '<S2063>:1:6' tempSelect = inputOffset + pAuxSelect((i-1)*nChanOut+1:i*nChanOut); */
        /*  Account for Matlab 1 index */
        /* '<S2063>:1:7' tempGain = pAuxGain((i-1)*nChanOut+1:i*nChanOut); */
        /*  Account for Matlab 1 index */
        /* '<S2063>:1:8' for ch = 1:1:nChanOut */
        for (i = 0; i < 24; i++)
        {
            rtb_enableAuxFlag = mainSelect[i];
            if (rtb_enableAuxFlag > 2147483623)
            {
                rtb_enableAuxFlag = MAX_int32_T;
            }
            else
            {
                rtb_enableAuxFlag += 24;
            }

            /* '<S2063>:1:9' if (tempSelect(ch) > inputOffset) */
            if ((rtb_enableAuxFlag > 24) && (rtb_enableAuxFlag <= 56))
            {
                /*  This channel is part of AUX, not MAIN */
                /* '<S2063>:1:11' if(tempSelect(ch) > (numAux(i)+inputOffset)) */
                /* '<S2063>:1:14' else */
                /* '<S2063>:1:15' y(:,ch)=y(:,ch) + x(:, tempSelect(ch)) * tempGain(ch); */
                tmp = Model_TargetTestRouterASDRouterAuxGainRtcOut.REQ_AuxGain[i];
                for (i_0 = 0; i_0 < 32; i_0++)
                {
                    int32_T out_tmp;
                    out_tmp = (i << 5) + i_0;
                    Model_Target_B.out[out_tmp] +=
                        Model_Target_B.MatrixConcatenate[((rtb_enableAuxFlag - 1)
                        << 5) + i_0] * tmp;
                }
            }
            else
            {
                /*  aux select index exceeds number of aux inputs of that bank */
                /* '<S2063>:1:13' y(:,ch)=y(:,ch) + x(:, tempSelect(ch)) * 0; */
            }
        }
    }

    /* End of MATLAB Function: '<S2056>/AuxChannelSubSystem' */

    /* S-Function (RTC_NTF): '<S2057>/NTF Trigger' */
    /* '<S2063>:1:20' inputOffset = inputOffset + numAux(i); */
    /* '<S2063>:1:22' out = y; */
    /* End of Outputs for S-Function (RTC_NTF): '<S2057>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2058>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2059>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2061>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2062>/NTF Trigger' */

    /* Outputs for Atomic SubSystem: '<Root>/PostProcess' */
    /* Outputs for Atomic SubSystem: '<S6>/PostProcess' */
    Model_Target_PostProcess();

    /* End of Outputs for SubSystem: '<S6>/PostProcess' */

    /* Outputs for Atomic SubSystem: '<Root>/SimIn' */
    /* SignalConversion generated from: '<S8>/In' incorporates:
     *  Inport: '<Root>/BoseAudioIn'
     */
    memcpy(&Model_Target_B.In[0], (&(UnitTest_Target_AudioIn[0])), 160U * sizeof
           (real32_T));

    /* End of Outputs for SubSystem: '<Root>/SimIn' */

    /* Outputs for Atomic SubSystem: '<Root>/InputSelect' */
    Model_Target_InputSelect();

    /* End of Outputs for SubSystem: '<Root>/InputSelect' */

    /* End of Outputs for S-Function (RTC_NTF): '<S240>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S291>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S291>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S320>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S371>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S371>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S400>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S451>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S451>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S480>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S531>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S531>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S176>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S65>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S130>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S131>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S132>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S133>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S27>/NTF Trigger' */

    /* Outputs for Atomic SubSystem: '<S4>/SrcDownAnn' */
    Model_Target_SrcDownAnnTID1();

    /* End of Outputs for SubSystem: '<S4>/SrcDownAnn' */

    /* Outputs for Atomic SubSystem: '<S7>/SrcDownEnt' */
    Model_Target_SrcDownEntTID1();

    /* End of Outputs for SubSystem: '<S7>/SrcDownEnt' */

    /* Outputs for Atomic SubSystem: '<S7>/SrcDownMic' */
    Model_Target_SrcDownMicTID1();

    /* End of Outputs for SubSystem: '<S7>/SrcDownMic' */
}

/* Model step function for TID2 */
void Model_Target_step2(void) /* Sample time: [0.00072222222222222219s, 0.0s] */
{
    int32_T c;
    int32_T m;
    int32_T sample;
    int32_T stateLen;
    int32_T writeIndex;
    int32_T xpageoffset;
    int32_T yIdx;
    real32_T a2;
    real32_T q;
    real32_T rtb_Delay3;
    real32_T rtb_Max_h;
    real32_T rtb_TrebleSlope;
    real32_T rtb_alpha;
    real32_T rtb_max_j;
    real32_T w2;
    real32_T xx;
    real32_T yy;
    real32_T *rtb_DriverSelector_0;
    real32_T *rtb_PassengerSelector_0;
    uint32_T b;
    uint32_T st;
    int8_T rtPrevAction;
    boolean_T tmp[2];
    boolean_T rtb_Merge;

    /* Delay: '<S660>/Delay3' */
    rtb_Delay3 = Model_Target_DW.Delay3_DSTATE;

    /* Outputs for Atomic SubSystem: '<S4>/SrcDownAnn' */
    Model_Target_SrcDownAnnTID2();

    /* End of Outputs for SubSystem: '<S4>/SrcDownAnn' */

    /* Selector: '<S177>/Selector5' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S561>/S-Function'
     */
    memcpy(&Model_Target_B.Selector5[0], &Model_Target_B.SFunction_d[0], sizeof
           (real32_T) << 5U);

    /* MATLAB Function: '<S307>/rgainy process' */
    Model_Target_rgainyprocess(Model_Target_ConstB.AudioStatsFunc_l,
        Model_Target_B.Selector5, &Model_Target_B.sf_rgainyprocess);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S240>/RTC Request Response Trigger' */

    /* Switch: '<S235>/Switch1' incorporates:
     *  Constant: '<S235>/Constant'
     */
    if (Model_Target_B.sf_MATLABFunction_iu.vncEnableOut > 0U)
    {
        Model_Target_B.Switch1 =
            Model_Target_Near0.Ann1Ann1NonEntGainCalcVncEnableTuneVar;
    }
    else
    {
        Model_Target_B.Switch1 = 0.0;
    }

    /* End of Switch: '<S235>/Switch1' */
    /* DiscreteFilter: '<S235>/DiscreteFilter' incorporates:
     *  DataTypeConversion: '<S235>/Data Type Conversion1'
     *  DataTypeConversion: '<S235>/Data Type Conversion2'
     *  S-Function (TOP_MEX): '<S249>/den'
     *  S-Function (TOP_MEX): '<S249>/num'
     */
    Model_Target_B.vncBoostGain = Model_Target_Near0.Ann1Ann1NonEntGainCalcNum[0]
        * Model_Target_B.Switch1 + Model_Target_DW.DiscreteFilter_states;
    Model_Target_DW.DiscreteFilter_states =
        Model_Target_Near0.Ann1Ann1NonEntGainCalcNum[1] * Model_Target_B.Switch1
        - Model_Target_Near0.Ann1Ann1NonEntGainCalcDen[1] *
        Model_Target_B.vncBoostGain;

    /* Switch: '<S250>/Switch' incorporates:
     *  Switch: '<S235>/Switch'
     */
    if (Model_Target_Near0.Ann1Ann1NonEntGainCalcBoostOverRideFlag > 0.0F)
    {
        /* Switch: '<S250>/Switch' */
        Model_Target_B.Switch =
            Model_Target_Near0.Ann1Ann1NonEntGainCalcBoostOverRide;
    }
    else
    {
        if (Model_Target_Near0.Ann1Ann1NonEntGainCalcNoiseOverRideFlag > 0.0F)
        {
            /* Switch: '<S235>/Switch' */
            rtb_alpha = Model_Target_Near0.Ann1Ann1NonEntGainCalcNoiseOverRide;
        }
        else
        {
            /* Switch: '<S235>/Switch' */
            rtb_alpha = rtb_Delay3;
        }

        /* Switch: '<S250>/Switch' incorporates:
         *  Constant: '<S250>/Constant2'
         *  Constant: '<S252>/Constant'
         *  DataTypeConversion: '<S235>/Cast To Single'
         *  Gain: '<S252>/Gain'
         *  Math: '<S252>/Magsq'
         *  Math: '<S252>/log10'
         *  MinMax: '<S250>/max'
         *  MinMax: '<S250>/min'
         *  MinMax: '<S251>/max'
         *  Product: '<S250>/Multiply'
         *  Product: '<S250>/Multiply1'
         *  Sum: '<S250>/Add1'
         *  Sum: '<S251>/Add'
         *  Sum: '<S252>/Sum1'
         *  Switch: '<S235>/Switch'
         *
         * About '<S252>/Magsq':
         *  Operator: magnitude^2
         *
         * About '<S252>/log10':
         *  Operator: log10
         */
        Model_Target_B.Switch = fminf(fmaxf(((rtb_alpha +
            Model_Target_Near0.Ann1Ann1NonEntGainCalcVncThresh) - fmaxf
            (Model_Target_Near0.Ann1Ann1NonEntGainCalcMinVncSignal,
             qhmath_log10_f((Model_Target_B.sf_rgainyprocess.gainOut +
                             2.22044605E-16F) *
                            (Model_Target_B.sf_rgainyprocess.gainOut +
                             2.22044605E-16F)) * 10.0F +
             Model_Target_Near0.Ann1Ann1NonEntGainCalcMaxSpl)) *
            Model_Target_Near0.Ann1Ann1NonEntGainCalcVncSlope, 0.0F),
            Model_Target_Near0.Ann1Ann1NonEntGainCalcMaxBoost) * (real32_T)
            Model_Target_B.vncBoostGain;
    }

    /* End of Switch: '<S250>/Switch' */

    /* Math: '<S260>/Math Function' incorporates:
     *  Constant: '<S260>/Constant3'
     *  Product: '<S260>/Divide'
     */
    rtb_max_j = qhmath_pow_f(10.0F, qhmath_div_f(Model_Target_B.Switch, 20.0F));

    /* DiscreteFilter: '<S265>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S266>/num'
     */
    Model_Target_B.Discrete_Filter =
        Model_Target_Near0.Ann1Ann1NonEntVncAppliedNum[0] * rtb_max_j +
        Model_Target_DW.Discrete_Filter_states;

    /* DiscreteFilter: '<S265>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S266>/den'
     *  S-Function (TOP_MEX): '<S266>/num'
     */
    Model_Target_DW.Discrete_Filter_states =
        Model_Target_Near0.Ann1Ann1NonEntVncAppliedNum[1] * rtb_max_j -
        Model_Target_Near0.Ann1Ann1NonEntVncAppliedden[1] *
        Model_Target_B.Discrete_Filter;

    /* S-Function (sdspupsamp2): '<S265>/Repeat' incorporates:
     *  Concatenate: '<S36>/Headrest Matrix Concatenate'
     */
    yIdx = 0;
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_i[yIdx] =
            Model_Target_B.Discrete_Filter;
        yIdx++;
    }

    /* End of S-Function (sdspupsamp2): '<S265>/Repeat' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        /* Product: '<S265>/Product' incorporates:
         *  Concatenate: '<S36>/Headrest Matrix Concatenate'
         */
        Model_Target_B.Product_o[xpageoffset] =
            Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] *
            Model_Target_B.sf_rgainyprocess.audioOut[xpageoffset];
    }

    /* DataStoreRead: '<S268>/Data Store Read1' */
    rtb_max_j = Model_TargetControlDsms.NearAnn1MuteTargetLinearGain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S269>/RTC Request Response Trigger' */

    /* Outputs for Atomic SubSystem: '<S268>/Ramping_Subsystem' */
    /* MinMax: '<S282>/Max' incorporates:
     *  Constant: '<S282>/minGain'
     *  DataStoreRead: '<S268>/Data Store Read'
     */
    rtb_Max_h = fmaxf(Model_TargetControlDsms.NearAnn1MuteCurrentGain,
                      4.7315126E-7F);

    /* If: '<S282>/If' incorporates:
     *  Abs: '<S282>/Abs3'
     *  Constant: '<S268>/snapThresh'
     *  DataStoreRead: '<S282>/frames'
     *  Sum: '<S282>/Add'
     */
    if ((qhmath_abs_f(rtb_max_j - rtb_Max_h) > 1.0E-9F) &&
            (Model_TargetControlDsms.NearAnn1MuteNframes > 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S282>/ifActionSubsystem' incorporates:
         *  ActionPort: '<S285>/Action Port'
         */
        /* DataStoreWrite: '<S285>/Data Store Write' incorporates:
         *  Constant: '<S285>/Constant1'
         *  Sum: '<S285>/Add'
         */
        Model_TargetControlDsms.NearAnn1MuteNframes =
            Model_TargetControlDsms.NearAnn1MuteNframes - 1.0F;

        /* If: '<S287>/If' incorporates:
         *  Delay: '<S287>/Delay'
         *  Sum: '<S287>/Add2'
         */
        if (rtb_max_j - Model_Target_DW.Delay_DSTATE_f == 0.0F)
        {
            /* Outputs for IfAction SubSystem: '<S287>/If Action Subsystem' incorporates:
             *  ActionPort: '<S288>/Action Port'
             */
            Model_Target_IfActionSubsystem(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S287>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S287>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S289>/Action Port'
             */
            Model_Target_IfActionSubsystem1(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S287>/If Action Subsystem1' */
        }

        /* End of If: '<S287>/If' */

        /* DiscreteFilter: '<S285>/ramping_filter' incorporates:
         *  Merge: '<S282>/Merge'
         *  Product: '<S285>/Matrix Multiply'
         *  Product: '<S286>/Multiply'
         */
        if (rtb_Merge)
        {
            Model_Target_DW.ramping_filter_icLoad_n = 1U;
        }

        if (Model_Target_DW.ramping_filter_icLoad_n != 0)
        {
            Model_Target_DW.ramping_filter_states_a =
                Model_Target_B.ramping_coeff_h * rtb_Max_h;
        }

        yIdx = 0;
        for (stateLen = 0; stateLen < 32; stateLen++)
        {
            Model_Target_B.Merge_f[yIdx] =
                Model_Target_DW.ramping_filter_states_a;
            Model_Target_DW.ramping_filter_states_a = 0.0F -
                -Model_Target_B.ramping_coeff_h * Model_Target_B.Merge_f[yIdx];
            yIdx++;
        }

        /* End of DiscreteFilter: '<S285>/ramping_filter' */

        /* Update for Delay: '<S287>/Delay' */
        Model_Target_DW.Delay_DSTATE_f = rtb_max_j;

        /* Update for DiscreteFilter: '<S285>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_n = 0U;

        /* End of Outputs for SubSystem: '<S282>/ifActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S282>/elseActionSubsystem' incorporates:
         *  ActionPort: '<S284>/Action Port'
         */
        Model_Target_elseActionSubsystem(rtb_max_j, Model_Target_B.Merge_f);

        /* End of Outputs for SubSystem: '<S282>/elseActionSubsystem' */
    }

    /* End of If: '<S282>/If' */

    /* S-Function (sdspperm2): '<S279>/Variable Selector' incorporates:
     *  DataStoreWrite: '<S268>/Data Store Write'
     *  Merge: '<S282>/Merge'
     */
    Model_TargetControlDsms.NearAnn1MuteCurrentGain = Model_Target_B.Merge_f[31];

    /* Outputs for Iterator SubSystem: '<S283>/For Each Subsystem' */
    Model_Target_ForEachSubsystem(32, Model_Target_B.Merge_f,
        Model_Target_B.Product_o, &Model_Target_B.VectorConcatenate1[0]);

    /* End of Outputs for SubSystem: '<S283>/For Each Subsystem' */
    /* End of Outputs for SubSystem: '<S268>/Ramping_Subsystem' */

    /* End of Outputs for S-Function (RTC_NTF): '<S269>/NTF Trigger' */
    /* Selector: '<S178>/Selector5' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S561>/S-Function'
     */
    memcpy(&Model_Target_B.Selector5_h[0], &Model_Target_B.SFunction_d[32],
           sizeof(real32_T) << 5U);

    /* MATLAB Function: '<S387>/rgainy process' */
    Model_Target_rgainyprocess_e(Model_Target_ConstB.AudioStatsFunc_a,
        Model_Target_B.Selector5_h, &Model_Target_B.sf_rgainyprocess_e);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S320>/RTC Request Response Trigger' */

    /* Switch: '<S315>/Switch1' incorporates:
     *  Constant: '<S315>/Constant'
     */
    if (Model_Target_B.sf_MATLABFunction_fm.vncEnableOut > 0U)
    {
        Model_Target_B.Switch1 =
            Model_Target_Near0.Ann2Ann2NonEntGainCalcVncEnableTuneVar;
    }
    else
    {
        Model_Target_B.Switch1 = 0.0;
    }

    /* End of Switch: '<S315>/Switch1' */
    /* DiscreteFilter: '<S315>/DiscreteFilter' incorporates:
     *  DataTypeConversion: '<S315>/Data Type Conversion1'
     *  DataTypeConversion: '<S315>/Data Type Conversion2'
     *  S-Function (TOP_MEX): '<S329>/den'
     *  S-Function (TOP_MEX): '<S329>/num'
     */
    Model_Target_B.vncBoostGain_o =
        Model_Target_Near0.Ann2Ann2NonEntGainCalcNum[0] * Model_Target_B.Switch1
        + Model_Target_DW.DiscreteFilter_states_j;
    Model_Target_DW.DiscreteFilter_states_j =
        Model_Target_Near0.Ann2Ann2NonEntGainCalcNum[1] * Model_Target_B.Switch1
        - Model_Target_Near0.Ann2Ann2NonEntGainCalcDen[1] *
        Model_Target_B.vncBoostGain_o;

    /* Switch: '<S330>/Switch' incorporates:
     *  Switch: '<S315>/Switch'
     */
    if (Model_Target_Near0.Ann2Ann2NonEntGainCalcBoostOverRideFlag > 0.0F)
    {
        /* Switch: '<S330>/Switch' */
        Model_Target_B.Switch_j =
            Model_Target_Near0.Ann2Ann2NonEntGainCalcBoostOverRide;
    }
    else
    {
        if (Model_Target_Near0.Ann2Ann2NonEntGainCalcNoiseOverRideFlag > 0.0F)
        {
            /* Switch: '<S315>/Switch' */
            rtb_alpha = Model_Target_Near0.Ann2Ann2NonEntGainCalcNoiseOverRide;
        }
        else
        {
            /* Switch: '<S315>/Switch' */
            rtb_alpha = rtb_Delay3;
        }

        /* Switch: '<S330>/Switch' incorporates:
         *  Constant: '<S330>/Constant2'
         *  Constant: '<S332>/Constant'
         *  DataTypeConversion: '<S315>/Cast To Single'
         *  Gain: '<S332>/Gain'
         *  Math: '<S332>/Magsq'
         *  Math: '<S332>/log10'
         *  MinMax: '<S330>/max'
         *  MinMax: '<S330>/min'
         *  MinMax: '<S331>/max'
         *  Product: '<S330>/Multiply'
         *  Product: '<S330>/Multiply1'
         *  Sum: '<S330>/Add1'
         *  Sum: '<S331>/Add'
         *  Sum: '<S332>/Sum1'
         *  Switch: '<S315>/Switch'
         *
         * About '<S332>/Magsq':
         *  Operator: magnitude^2
         *
         * About '<S332>/log10':
         *  Operator: log10
         */
        Model_Target_B.Switch_j = fminf(fmaxf(((rtb_alpha +
            Model_Target_Near0.Ann2Ann2NonEntGainCalcVncThresh) - fmaxf
            (Model_Target_Near0.Ann2Ann2NonEntGainCalcMinVncSignal,
             qhmath_log10_f((Model_Target_B.sf_rgainyprocess_e.gainOut +
                             2.22044605E-16F) *
                            (Model_Target_B.sf_rgainyprocess_e.gainOut +
                             2.22044605E-16F)) * 10.0F +
             Model_Target_Near0.Ann2Ann2NonEntGainCalcMaxSpl)) *
            Model_Target_Near0.Ann2Ann2NonEntGainCalcVncSlope, 0.0F),
            Model_Target_Near0.Ann2Ann2NonEntGainCalcMaxBoost) * (real32_T)
            Model_Target_B.vncBoostGain_o;
    }

    /* End of Switch: '<S330>/Switch' */

    /* Math: '<S340>/Math Function' incorporates:
     *  Constant: '<S340>/Constant3'
     *  Product: '<S340>/Divide'
     */
    rtb_max_j = qhmath_pow_f(10.0F, qhmath_div_f(Model_Target_B.Switch_j, 20.0F));

    /* DiscreteFilter: '<S345>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S346>/num'
     */
    Model_Target_B.Discrete_Filter_n =
        Model_Target_Near0.Ann2Ann2NonEntVncAppliedNum[0] * rtb_max_j +
        Model_Target_DW.Discrete_Filter_states_p;

    /* DiscreteFilter: '<S345>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S346>/den'
     *  S-Function (TOP_MEX): '<S346>/num'
     */
    Model_Target_DW.Discrete_Filter_states_p =
        Model_Target_Near0.Ann2Ann2NonEntVncAppliedNum[1] * rtb_max_j -
        Model_Target_Near0.Ann2Ann2NonEntVncAppliedden[1] *
        Model_Target_B.Discrete_Filter_n;

    /* S-Function (sdspupsamp2): '<S345>/Repeat' incorporates:
     *  Concatenate: '<S36>/Headrest Matrix Concatenate'
     */
    yIdx = 0;
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_i[yIdx] =
            Model_Target_B.Discrete_Filter_n;
        yIdx++;
    }

    /* End of S-Function (sdspupsamp2): '<S345>/Repeat' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        /* Product: '<S345>/Product' incorporates:
         *  Concatenate: '<S36>/Headrest Matrix Concatenate'
         */
        Model_Target_B.Product_a[xpageoffset] =
            Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] *
            Model_Target_B.sf_rgainyprocess_e.audioOut[xpageoffset];
    }

    /* DataStoreRead: '<S348>/Data Store Read1' */
    rtb_max_j = Model_TargetControlDsms.NearAnn2MuteTargetLinearGain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S349>/RTC Request Response Trigger' */

    /* Outputs for Atomic SubSystem: '<S348>/Ramping_Subsystem' */
    /* MinMax: '<S362>/Max' incorporates:
     *  Constant: '<S362>/minGain'
     *  DataStoreRead: '<S348>/Data Store Read'
     */
    rtb_Max_h = fmaxf(Model_TargetControlDsms.NearAnn2MuteCurrentGain,
                      4.7315126E-7F);

    /* If: '<S362>/If' incorporates:
     *  Abs: '<S362>/Abs3'
     *  Constant: '<S348>/snapThresh'
     *  DataStoreRead: '<S362>/frames'
     *  Sum: '<S362>/Add'
     */
    if ((qhmath_abs_f(rtb_max_j - rtb_Max_h) > 1.0E-9F) &&
            (Model_TargetControlDsms.NearAnn2MuteNframes > 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S362>/ifActionSubsystem' incorporates:
         *  ActionPort: '<S365>/Action Port'
         */
        /* DataStoreWrite: '<S365>/Data Store Write' incorporates:
         *  Constant: '<S365>/Constant1'
         *  Sum: '<S365>/Add'
         */
        Model_TargetControlDsms.NearAnn2MuteNframes =
            Model_TargetControlDsms.NearAnn2MuteNframes - 1.0F;

        /* If: '<S367>/If' incorporates:
         *  Delay: '<S367>/Delay'
         *  Sum: '<S367>/Add2'
         */
        if (rtb_max_j - Model_Target_DW.Delay_DSTATE_nt == 0.0F)
        {
            /* Outputs for IfAction SubSystem: '<S367>/If Action Subsystem' incorporates:
             *  ActionPort: '<S368>/Action Port'
             */
            Model_Target_IfActionSubsystem(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S367>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S367>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S369>/Action Port'
             */
            Model_Target_IfActionSubsystem1(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S367>/If Action Subsystem1' */
        }

        /* End of If: '<S367>/If' */

        /* DiscreteFilter: '<S365>/ramping_filter' incorporates:
         *  Merge: '<S362>/Merge'
         *  Product: '<S365>/Matrix Multiply'
         *  Product: '<S366>/Multiply'
         */
        if (rtb_Merge)
        {
            Model_Target_DW.ramping_filter_icLoad_d = 1U;
        }

        if (Model_Target_DW.ramping_filter_icLoad_d != 0)
        {
            Model_Target_DW.ramping_filter_states_h =
                Model_Target_B.ramping_coeff_a * rtb_Max_h;
        }

        yIdx = 0;
        for (stateLen = 0; stateLen < 32; stateLen++)
        {
            Model_Target_B.Merge_e[yIdx] =
                Model_Target_DW.ramping_filter_states_h;
            Model_Target_DW.ramping_filter_states_h = 0.0F -
                -Model_Target_B.ramping_coeff_a * Model_Target_B.Merge_e[yIdx];
            yIdx++;
        }

        /* End of DiscreteFilter: '<S365>/ramping_filter' */

        /* Update for Delay: '<S367>/Delay' */
        Model_Target_DW.Delay_DSTATE_nt = rtb_max_j;

        /* Update for DiscreteFilter: '<S365>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_d = 0U;

        /* End of Outputs for SubSystem: '<S362>/ifActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S362>/elseActionSubsystem' incorporates:
         *  ActionPort: '<S364>/Action Port'
         */
        Model_Target_elseActionSubsystem(rtb_max_j, Model_Target_B.Merge_e);

        /* End of Outputs for SubSystem: '<S362>/elseActionSubsystem' */
    }

    /* End of If: '<S362>/If' */

    /* S-Function (sdspperm2): '<S359>/Variable Selector' incorporates:
     *  DataStoreWrite: '<S348>/Data Store Write'
     *  Merge: '<S362>/Merge'
     */
    Model_TargetControlDsms.NearAnn2MuteCurrentGain = Model_Target_B.Merge_e[31];

    /* Outputs for Iterator SubSystem: '<S363>/For Each Subsystem' */
    Model_Target_ForEachSubsystem(32, Model_Target_B.Merge_e,
        Model_Target_B.Product_a, &Model_Target_B.VectorConcatenate1[32]);

    /* End of Outputs for SubSystem: '<S363>/For Each Subsystem' */
    /* End of Outputs for SubSystem: '<S348>/Ramping_Subsystem' */

    /* End of Outputs for S-Function (RTC_NTF): '<S349>/NTF Trigger' */
    /* Selector: '<S179>/Selector5' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S561>/S-Function'
     */
    memcpy(&Model_Target_B.Selector5_m[0], &Model_Target_B.SFunction_d[32],
           sizeof(real32_T) << 5U);

    /* MATLAB Function: '<S467>/rgainy process' */
    Model_Target_rgainyprocess_a(Model_Target_ConstB.AudioStatsFunc_k,
        Model_Target_B.Selector5_m, &Model_Target_B.sf_rgainyprocess_a);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S400>/RTC Request Response Trigger' */

    /* Switch: '<S395>/Switch1' incorporates:
     *  Constant: '<S395>/Constant'
     */
    if (Model_Target_B.sf_MATLABFunction_ho.vncEnableOut > 0U)
    {
        Model_Target_B.vncBoostGain_o =
            Model_Target_Near0.Ann3Ann3NonEntGainCalcVncEnableTuneVar;
    }
    else
    {
        Model_Target_B.vncBoostGain_o = 0.0;
    }

    /* End of Switch: '<S395>/Switch1' */
    /* DiscreteFilter: '<S395>/DiscreteFilter' incorporates:
     *  DataTypeConversion: '<S395>/Data Type Conversion1'
     *  DataTypeConversion: '<S395>/Data Type Conversion2'
     *  S-Function (TOP_MEX): '<S409>/den'
     *  S-Function (TOP_MEX): '<S409>/num'
     */
    Model_Target_B.Switch1 = Model_Target_Near0.Ann3Ann3NonEntGainCalcNum[0] *
        Model_Target_B.vncBoostGain_o + Model_Target_DW.DiscreteFilter_states_e;
    Model_Target_DW.DiscreteFilter_states_e =
        Model_Target_Near0.Ann3Ann3NonEntGainCalcNum[1] *
        Model_Target_B.vncBoostGain_o -
        Model_Target_Near0.Ann3Ann3NonEntGainCalcDen[1] * Model_Target_B.Switch1;

    /* Switch: '<S410>/Switch' incorporates:
     *  Switch: '<S395>/Switch'
     */
    if (Model_Target_Near0.Ann3Ann3NonEntGainCalcBoostOverRideFlag > 0.0F)
    {
        /* Switch: '<S410>/Switch' */
        Model_Target_B.Switch_g =
            Model_Target_Near0.Ann3Ann3NonEntGainCalcBoostOverRide;
    }
    else
    {
        if (Model_Target_Near0.Ann3Ann3NonEntGainCalcNoiseOverRideFlag > 0.0F)
        {
            /* Switch: '<S395>/Switch' */
            rtb_alpha = Model_Target_Near0.Ann3Ann3NonEntGainCalcNoiseOverRide;
        }
        else
        {
            /* Switch: '<S395>/Switch' */
            rtb_alpha = rtb_Delay3;
        }

        /* Switch: '<S410>/Switch' incorporates:
         *  Constant: '<S410>/Constant2'
         *  Constant: '<S412>/Constant'
         *  DataTypeConversion: '<S395>/Cast To Single'
         *  Gain: '<S412>/Gain'
         *  Math: '<S412>/Magsq'
         *  Math: '<S412>/log10'
         *  MinMax: '<S410>/max'
         *  MinMax: '<S410>/min'
         *  MinMax: '<S411>/max'
         *  Product: '<S410>/Multiply'
         *  Product: '<S410>/Multiply1'
         *  Sum: '<S410>/Add1'
         *  Sum: '<S411>/Add'
         *  Sum: '<S412>/Sum1'
         *  Switch: '<S395>/Switch'
         *
         * About '<S412>/Magsq':
         *  Operator: magnitude^2
         *
         * About '<S412>/log10':
         *  Operator: log10
         */
        Model_Target_B.Switch_g = fminf(fmaxf(((rtb_alpha +
            Model_Target_Near0.Ann3Ann3NonEntGainCalcVncThresh) - fmaxf
            (Model_Target_Near0.Ann3Ann3NonEntGainCalcMinVncSignal,
             qhmath_log10_f((Model_Target_B.sf_rgainyprocess_a.gainOut +
                             2.22044605E-16F) *
                            (Model_Target_B.sf_rgainyprocess_a.gainOut +
                             2.22044605E-16F)) * 10.0F +
             Model_Target_Near0.Ann3Ann3NonEntGainCalcMaxSpl)) *
            Model_Target_Near0.Ann3Ann3NonEntGainCalcVncSlope, 0.0F),
            Model_Target_Near0.Ann3Ann3NonEntGainCalcMaxBoost) * (real32_T)
            Model_Target_B.Switch1;
    }

    /* End of Switch: '<S410>/Switch' */

    /* Math: '<S420>/Math Function' incorporates:
     *  Constant: '<S420>/Constant3'
     *  Product: '<S420>/Divide'
     */
    rtb_max_j = qhmath_pow_f(10.0F, qhmath_div_f(Model_Target_B.Switch_g, 20.0F));

    /* DiscreteFilter: '<S425>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S426>/num'
     */
    Model_Target_B.Discrete_Filter_m =
        Model_Target_Near0.Ann3Ann3NonEntVncAppliedNum[0] * rtb_max_j +
        Model_Target_DW.Discrete_Filter_states_pt;

    /* DiscreteFilter: '<S425>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S426>/den'
     *  S-Function (TOP_MEX): '<S426>/num'
     */
    Model_Target_DW.Discrete_Filter_states_pt =
        Model_Target_Near0.Ann3Ann3NonEntVncAppliedNum[1] * rtb_max_j -
        Model_Target_Near0.Ann3Ann3NonEntVncAppliedden[1] *
        Model_Target_B.Discrete_Filter_m;

    /* S-Function (sdspupsamp2): '<S425>/Repeat' incorporates:
     *  Concatenate: '<S36>/Headrest Matrix Concatenate'
     */
    yIdx = 0;
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_i[yIdx] =
            Model_Target_B.Discrete_Filter_m;
        yIdx++;
    }

    /* End of S-Function (sdspupsamp2): '<S425>/Repeat' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        /* Product: '<S425>/Product' incorporates:
         *  Concatenate: '<S36>/Headrest Matrix Concatenate'
         */
        Model_Target_B.Product_i[xpageoffset] =
            Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] *
            Model_Target_B.sf_rgainyprocess_a.audioOut[xpageoffset];
    }

    /* DataStoreRead: '<S428>/Data Store Read1' */
    rtb_max_j = Model_TargetControlDsms.NearAnn3MuteTargetLinearGain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S429>/RTC Request Response Trigger' */

    /* Outputs for Atomic SubSystem: '<S428>/Ramping_Subsystem' */
    /* MinMax: '<S442>/Max' incorporates:
     *  Constant: '<S442>/minGain'
     *  DataStoreRead: '<S428>/Data Store Read'
     */
    rtb_Max_h = fmaxf(Model_TargetControlDsms.NearAnn3MuteCurrentGain,
                      4.7315126E-7F);

    /* If: '<S442>/If' incorporates:
     *  Abs: '<S442>/Abs3'
     *  Constant: '<S428>/snapThresh'
     *  DataStoreRead: '<S442>/frames'
     *  Sum: '<S442>/Add'
     */
    if ((qhmath_abs_f(rtb_max_j - rtb_Max_h) > 1.0E-9F) &&
            (Model_TargetControlDsms.NearAnn3MuteNframes > 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S442>/ifActionSubsystem' incorporates:
         *  ActionPort: '<S445>/Action Port'
         */
        /* DataStoreWrite: '<S445>/Data Store Write' incorporates:
         *  Constant: '<S445>/Constant1'
         *  Sum: '<S445>/Add'
         */
        Model_TargetControlDsms.NearAnn3MuteNframes =
            Model_TargetControlDsms.NearAnn3MuteNframes - 1.0F;

        /* If: '<S447>/If' incorporates:
         *  Delay: '<S447>/Delay'
         *  Sum: '<S447>/Add2'
         */
        if (rtb_max_j - Model_Target_DW.Delay_DSTATE_kg == 0.0F)
        {
            /* Outputs for IfAction SubSystem: '<S447>/If Action Subsystem' incorporates:
             *  ActionPort: '<S448>/Action Port'
             */
            Model_Target_IfActionSubsystem(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S447>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S447>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S449>/Action Port'
             */
            Model_Target_IfActionSubsystem1(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S447>/If Action Subsystem1' */
        }

        /* End of If: '<S447>/If' */

        /* DiscreteFilter: '<S445>/ramping_filter' incorporates:
         *  Merge: '<S442>/Merge'
         *  Product: '<S445>/Matrix Multiply'
         *  Product: '<S446>/Multiply'
         */
        if (rtb_Merge)
        {
            Model_Target_DW.ramping_filter_icLoad_p = 1U;
        }

        if (Model_Target_DW.ramping_filter_icLoad_p != 0)
        {
            Model_Target_DW.ramping_filter_states_b =
                Model_Target_B.ramping_coeff_p * rtb_Max_h;
        }

        yIdx = 0;
        for (stateLen = 0; stateLen < 32; stateLen++)
        {
            Model_Target_B.Merge_kg[yIdx] =
                Model_Target_DW.ramping_filter_states_b;
            Model_Target_DW.ramping_filter_states_b = 0.0F -
                -Model_Target_B.ramping_coeff_p * Model_Target_B.Merge_kg[yIdx];
            yIdx++;
        }

        /* End of DiscreteFilter: '<S445>/ramping_filter' */

        /* Update for Delay: '<S447>/Delay' */
        Model_Target_DW.Delay_DSTATE_kg = rtb_max_j;

        /* Update for DiscreteFilter: '<S445>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_p = 0U;

        /* End of Outputs for SubSystem: '<S442>/ifActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S442>/elseActionSubsystem' incorporates:
         *  ActionPort: '<S444>/Action Port'
         */
        Model_Target_elseActionSubsystem(rtb_max_j, Model_Target_B.Merge_kg);

        /* End of Outputs for SubSystem: '<S442>/elseActionSubsystem' */
    }

    /* End of If: '<S442>/If' */

    /* S-Function (sdspperm2): '<S439>/Variable Selector' incorporates:
     *  DataStoreWrite: '<S428>/Data Store Write'
     *  Merge: '<S442>/Merge'
     */
    Model_TargetControlDsms.NearAnn3MuteCurrentGain = Model_Target_B.Merge_kg[31];

    /* Outputs for Iterator SubSystem: '<S443>/For Each Subsystem' */
    Model_Target_ForEachSubsystem(32, Model_Target_B.Merge_kg,
        Model_Target_B.Product_i, &Model_Target_B.VectorConcatenate1[64]);

    /* End of Outputs for SubSystem: '<S443>/For Each Subsystem' */
    /* End of Outputs for SubSystem: '<S428>/Ramping_Subsystem' */

    /* End of Outputs for S-Function (RTC_NTF): '<S429>/NTF Trigger' */
    /* Selector: '<S180>/Selector5' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S561>/S-Function'
     */
    memcpy(&Model_Target_B.Selector5_o[0], &Model_Target_B.SFunction_d[32],
           sizeof(real32_T) << 5U);

    /* MATLAB Function: '<S547>/rgainy process' */
    Model_Target_rgainyprocess_i(Model_Target_ConstB.AudioStatsFunc_d,
        Model_Target_B.Selector5_o, &Model_Target_B.sf_rgainyprocess_i);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S480>/RTC Request Response Trigger' */

    /* Switch: '<S475>/Switch1' incorporates:
     *  Constant: '<S475>/Constant'
     */
    if (Model_Target_B.sf_MATLABFunction_fsi.vncEnableOut > 0U)
    {
        Model_Target_B.Switch1 =
            Model_Target_Near0.Ann4Ann4NonEntGainCalcVncEnableTuneVar;
    }
    else
    {
        Model_Target_B.Switch1 = 0.0;
    }

    /* End of Switch: '<S475>/Switch1' */
    /* DiscreteFilter: '<S475>/DiscreteFilter' incorporates:
     *  DataTypeConversion: '<S475>/Data Type Conversion1'
     *  DataTypeConversion: '<S475>/Data Type Conversion2'
     *  S-Function (TOP_MEX): '<S489>/den'
     *  S-Function (TOP_MEX): '<S489>/num'
     */
    Model_Target_B.vncBoostGain_j =
        Model_Target_Near0.Ann4Ann4NonEntGainCalcNum[0] * Model_Target_B.Switch1
        + Model_Target_DW.DiscreteFilter_states_ja;
    Model_Target_DW.DiscreteFilter_states_ja =
        Model_Target_Near0.Ann4Ann4NonEntGainCalcNum[1] * Model_Target_B.Switch1
        - Model_Target_Near0.Ann4Ann4NonEntGainCalcDen[1] *
        Model_Target_B.vncBoostGain_j;

    /* Switch: '<S490>/Switch' incorporates:
     *  Switch: '<S475>/Switch'
     */
    if (Model_Target_Near0.Ann4Ann4NonEntGainCalcBoostOverRideFlag > 0.0F)
    {
        /* Switch: '<S490>/Switch' */
        Model_Target_B.Switch_c =
            Model_Target_Near0.Ann4Ann4NonEntGainCalcBoostOverRide;
    }
    else
    {
        if (Model_Target_Near0.Ann4Ann4NonEntGainCalcNoiseOverRideFlag > 0.0F)
        {
            /* Switch: '<S475>/Switch' */
            rtb_Delay3 = Model_Target_Near0.Ann4Ann4NonEntGainCalcNoiseOverRide;
        }

        /* Switch: '<S490>/Switch' incorporates:
         *  Constant: '<S490>/Constant2'
         *  Constant: '<S492>/Constant'
         *  DataTypeConversion: '<S475>/Cast To Single'
         *  Gain: '<S492>/Gain'
         *  Math: '<S492>/Magsq'
         *  Math: '<S492>/log10'
         *  MinMax: '<S490>/max'
         *  MinMax: '<S490>/min'
         *  MinMax: '<S491>/max'
         *  Product: '<S490>/Multiply'
         *  Product: '<S490>/Multiply1'
         *  Sum: '<S490>/Add1'
         *  Sum: '<S491>/Add'
         *  Sum: '<S492>/Sum1'
         *  Switch: '<S475>/Switch'
         *
         * About '<S492>/Magsq':
         *  Operator: magnitude^2
         *
         * About '<S492>/log10':
         *  Operator: log10
         */
        Model_Target_B.Switch_c = fminf(fmaxf(((rtb_Delay3 +
            Model_Target_Near0.Ann4Ann4NonEntGainCalcVncThresh) - fmaxf
            (Model_Target_Near0.Ann4Ann4NonEntGainCalcMinVncSignal,
             qhmath_log10_f((Model_Target_B.sf_rgainyprocess_i.gainOut +
                             2.22044605E-16F) *
                            (Model_Target_B.sf_rgainyprocess_i.gainOut +
                             2.22044605E-16F)) * 10.0F +
             Model_Target_Near0.Ann4Ann4NonEntGainCalcMaxSpl)) *
            Model_Target_Near0.Ann4Ann4NonEntGainCalcVncSlope, 0.0F),
            Model_Target_Near0.Ann4Ann4NonEntGainCalcMaxBoost) * (real32_T)
            Model_Target_B.vncBoostGain_j;
    }

    /* End of Switch: '<S490>/Switch' */

    /* Math: '<S500>/Math Function' incorporates:
     *  Constant: '<S500>/Constant3'
     *  Product: '<S500>/Divide'
     */
    rtb_Delay3 = qhmath_pow_f(10.0F, qhmath_div_f(Model_Target_B.Switch_c, 20.0F));

    /* DiscreteFilter: '<S505>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S506>/num'
     */
    Model_Target_B.Discrete_Filter_i =
        Model_Target_Near0.Ann4Ann4NonEntVncAppliedNum[0] * rtb_Delay3 +
        Model_Target_DW.Discrete_Filter_states_pl;

    /* DiscreteFilter: '<S505>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S506>/den'
     *  S-Function (TOP_MEX): '<S506>/num'
     */
    Model_Target_DW.Discrete_Filter_states_pl =
        Model_Target_Near0.Ann4Ann4NonEntVncAppliedNum[1] * rtb_Delay3 -
        Model_Target_Near0.Ann4Ann4NonEntVncAppliedden[1] *
        Model_Target_B.Discrete_Filter_i;

    /* S-Function (sdspupsamp2): '<S505>/Repeat' incorporates:
     *  Concatenate: '<S36>/Headrest Matrix Concatenate'
     */
    yIdx = 0;
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_i[yIdx] =
            Model_Target_B.Discrete_Filter_i;
        yIdx++;
    }

    /* End of S-Function (sdspupsamp2): '<S505>/Repeat' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        /* Product: '<S505>/Product' incorporates:
         *  Concatenate: '<S36>/Headrest Matrix Concatenate'
         */
        Model_Target_B.Product_g[xpageoffset] =
            Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] *
            Model_Target_B.sf_rgainyprocess_i.audioOut[xpageoffset];
    }

    /* DataStoreRead: '<S508>/Data Store Read1' */
    rtb_Delay3 = Model_TargetControlDsms.NearAnn4MuteTargetLinearGain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S509>/RTC Request Response Trigger' */

    /* Outputs for Atomic SubSystem: '<S508>/Ramping_Subsystem' */
    /* MinMax: '<S522>/Max' incorporates:
     *  Constant: '<S522>/minGain'
     *  DataStoreRead: '<S508>/Data Store Read'
     */
    rtb_max_j = fmaxf(Model_TargetControlDsms.NearAnn4MuteCurrentGain,
                      4.7315126E-7F);

    /* If: '<S522>/If' incorporates:
     *  Abs: '<S522>/Abs3'
     *  Constant: '<S508>/snapThresh'
     *  DataStoreRead: '<S522>/frames'
     *  Sum: '<S522>/Add'
     */
    if ((qhmath_abs_f(rtb_Delay3 - rtb_max_j) > 1.0E-9F) &&
            (Model_TargetControlDsms.NearAnn4MuteNframes > 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S522>/ifActionSubsystem' incorporates:
         *  ActionPort: '<S525>/Action Port'
         */
        /* DataStoreWrite: '<S525>/Data Store Write' incorporates:
         *  Constant: '<S525>/Constant1'
         *  Sum: '<S525>/Add'
         */
        Model_TargetControlDsms.NearAnn4MuteNframes =
            Model_TargetControlDsms.NearAnn4MuteNframes - 1.0F;

        /* If: '<S527>/If' incorporates:
         *  Delay: '<S527>/Delay'
         *  Sum: '<S527>/Add2'
         */
        if (rtb_Delay3 - Model_Target_DW.Delay_DSTATE_o == 0.0F)
        {
            /* Outputs for IfAction SubSystem: '<S527>/If Action Subsystem' incorporates:
             *  ActionPort: '<S528>/Action Port'
             */
            Model_Target_IfActionSubsystem(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S527>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S527>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S529>/Action Port'
             */
            Model_Target_IfActionSubsystem1(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S527>/If Action Subsystem1' */
        }

        /* End of If: '<S527>/If' */

        /* DiscreteFilter: '<S525>/ramping_filter' incorporates:
         *  Merge: '<S522>/Merge'
         *  Product: '<S525>/Matrix Multiply'
         *  Product: '<S526>/Multiply'
         */
        if (rtb_Merge)
        {
            Model_Target_DW.ramping_filter_icLoad_m = 1U;
        }

        if (Model_Target_DW.ramping_filter_icLoad_m != 0)
        {
            Model_Target_DW.ramping_filter_states_d =
                Model_Target_B.ramping_coeff_l * rtb_max_j;
        }

        yIdx = 0;
        for (stateLen = 0; stateLen < 32; stateLen++)
        {
            Model_Target_B.Merge_h[yIdx] =
                Model_Target_DW.ramping_filter_states_d;
            Model_Target_DW.ramping_filter_states_d = 0.0F -
                -Model_Target_B.ramping_coeff_l * Model_Target_B.Merge_h[yIdx];
            yIdx++;
        }

        /* End of DiscreteFilter: '<S525>/ramping_filter' */

        /* Update for Delay: '<S527>/Delay' */
        Model_Target_DW.Delay_DSTATE_o = rtb_Delay3;

        /* Update for DiscreteFilter: '<S525>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_m = 0U;

        /* End of Outputs for SubSystem: '<S522>/ifActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S522>/elseActionSubsystem' incorporates:
         *  ActionPort: '<S524>/Action Port'
         */
        Model_Target_elseActionSubsystem(rtb_Delay3, Model_Target_B.Merge_h);

        /* End of Outputs for SubSystem: '<S522>/elseActionSubsystem' */
    }

    /* End of If: '<S522>/If' */

    /* S-Function (sdspperm2): '<S519>/Variable Selector' incorporates:
     *  DataStoreWrite: '<S508>/Data Store Write'
     *  Merge: '<S522>/Merge'
     */
    Model_TargetControlDsms.NearAnn4MuteCurrentGain = Model_Target_B.Merge_h[31];

    /* Outputs for Iterator SubSystem: '<S523>/For Each Subsystem' */
    Model_Target_ForEachSubsystem(32, Model_Target_B.Merge_h,
        Model_Target_B.Product_g, &Model_Target_B.VectorConcatenate1[96]);

    /* End of Outputs for SubSystem: '<S523>/For Each Subsystem' */
    /* End of Outputs for SubSystem: '<S508>/Ramping_Subsystem' */

    /* End of Outputs for S-Function (RTC_NTF): '<S509>/NTF Trigger' */
    /* MATLAB Function: '<S194>/PoolIirProcess' */
    Model_Target_PoolIirProcess(Model_Target_B.SFunction_d,
        &(Model_Target_Near0.LevelDetectPreEmphasisShelfFilterPooliirNumStages[0]),
        &(Model_Target_Near0.LevelDetectPreEmphasisShelfFilterpooliirCoeffs[0]),
        Model_Target_DW.states_on, &Model_Target_B.sf_PoolIirProcess_k);

    /* MATLAB Function: '<S182>/Preprocessing for Level Detector' incorporates:
     *  Reshape: '<S194>/Reshape'
     */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/AnnouncementLevelDetector/PreProcessing/Preprocessing for Level Detector': '<S189>:1' */
    /* '<S189>:1:4' curr = 10 * log10(max(mean(signal .* signal, 1)) + eps); */
    for (xpageoffset = 0; xpageoffset < 64; xpageoffset++)
    {
        Model_Target_B.Selector2_e[xpageoffset] =
            Model_Target_B.sf_PoolIirProcess_k.y[xpageoffset] *
            Model_Target_B.sf_PoolIirProcess_k.y[xpageoffset];
    }

    for (stateLen = 0; stateLen < 2; stateLen++)
    {
        xpageoffset = stateLen << 5;
        Model_Target_B.MatrixConcatenate_j2[stateLen] =
            Model_Target_B.Selector2_e[xpageoffset];
        for (c = 0; c < 31; c++)
        {
            Model_Target_B.MatrixConcatenate_j2[stateLen] +=
                Model_Target_B.Selector2_e[(xpageoffset + c) + 1];
        }

        Model_Target_B.MatrixConcatenate_j2[stateLen] = qhmath_div_f
            (Model_Target_B.MatrixConcatenate_j2[stateLen], 32.0F);
    }

    if (Model_Target_B.MatrixConcatenate_j2[0] <
            Model_Target_B.MatrixConcatenate_j2[1])
    {
        rtb_alpha = Model_Target_B.MatrixConcatenate_j2[1];
    }
    else
    {
        rtb_alpha = Model_Target_B.MatrixConcatenate_j2[0];
    }

    rtb_Delay3 = qhmath_log10_f(rtb_alpha + 2.22044605E-16F) * 10.0F;

    /* '<S189>:1:6' rms_output = max(curr); */
    /* '<S189>:1:8' if (peak_enable) */
    if (Model_Target_ConstB.Compare_h)
    {
        /* '<S189>:1:9' curr = 20 * log10(max(max(abs(signal))) + eps); */
        for (stateLen = 0; stateLen < 64; stateLen++)
        {
            Model_Target_B.Selector2_e[stateLen] = qhmath_abs_f
                (Model_Target_B.sf_PoolIirProcess_k.y[stateLen]);
        }

        for (xpageoffset = 0; xpageoffset < 2; xpageoffset++)
        {
            c = xpageoffset << 5;
            Model_Target_B.MatrixConcatenate_j2[xpageoffset] =
                Model_Target_B.Selector2_e[c];
            for (stateLen = 0; stateLen < 31; stateLen++)
            {
                w2 = Model_Target_B.MatrixConcatenate_j2[xpageoffset];
                rtb_alpha = Model_Target_B.Selector2_e[(c + stateLen) + 1];
                if (w2 < rtb_alpha)
                {
                    w2 = rtb_alpha;
                }

                Model_Target_B.MatrixConcatenate_j2[xpageoffset] = w2;
            }
        }

        if (Model_Target_B.MatrixConcatenate_j2[0] <
                Model_Target_B.MatrixConcatenate_j2[1])
        {
            rtb_alpha = Model_Target_B.MatrixConcatenate_j2[1];
        }
        else
        {
            rtb_alpha = Model_Target_B.MatrixConcatenate_j2[0];
        }

        rtb_max_j = qhmath_log10_f(rtb_alpha + 2.22044605E-16F) * 20.0F;

        /* '<S189>:1:10' peak_output = max(curr); */
    }
    else
    {
        /* '<S189>:1:11' else */
        /* '<S189>:1:12' peak_output = rms_output; */
        rtb_max_j = rtb_Delay3;
    }

    /* Selector: '<S34>/Selector1' incorporates:
     *  SignalConversion generated from: '<S34>/Vector Concatenate2'
     * */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/AnnouncementLevelDetector/linear2dB': '<S187>:1' */
    /* '<S187>:1:3' voldB = single(20 * log10(volume + eps)); */
    Model_Target_B.Downsample[0] = Model_Target_B.sf_rgainyprocess.gainOut;
    Model_Target_B.Downsample[1] = Model_Target_B.sf_rgainyprocess_e.gainOut;

    /* MATLAB Function: '<S175>/linear2dB' */
    w2 = qhmath_log10_f(Model_Target_B.Downsample[1] + 2.22044605E-16F) * 20.0F;

    /* MATLAB Function: '<S197>/InnerLink' incorporates:
     *  Constant: '<S175>/ch1_mode'
     *  Constant: '<S34>/Constant'
     *  MATLAB Function: '<S175>/linear2dB'
     *  MATLAB Function: '<S182>/Preprocessing for Level Detector'
     */
    Model_Target_InnerLink(rtb_Delay3, rtb_max_j,
                           Model_Target_Near0.Ann1LevelDetectSlowDecayDbPerSample,
                           Model_Target_Near0.Ann1LevelDetecthold_margin_db,
                           Model_Target_Near0.Ann1LevelDetectHoldTimeSamples,
                           Model_Target_Near0.Ann1LevelDetectFastDecayDbPerSample,
                           Model_Target_Near0.Ann1LevelDetectMinVolumeDb,
                           Model_Target_Near0.Ann1LevelDetectMaxVolumeDb, 0.0,
                           0.0F, &Model_Target_DW.sf_InnerLink);

    /* MATLAB Function: '<S205>/InnerLink' incorporates:
     *  Constant: '<S175>/ch2_mode'
     *  Constant: '<S34>/Constant'
     *  MATLAB Function: '<S182>/Preprocessing for Level Detector'
     */
    Model_Target_InnerLink(rtb_Delay3, rtb_max_j,
                           Model_Target_Near0.Ann2LevelDetectSlowDecayDbPerSample,
                           Model_Target_Near0.Ann2LevelDetectHoldMarginDb,
                           Model_Target_Near0.Ann2LevelDetectHoldTimeSamples,
                           Model_Target_Near0.Ann2LevelDetectFastDecayDbPerSample,
                           Model_Target_Near0.Ann2LevelDetectMinVolumeDb,
                           Model_Target_Near0.Ann2LevelDetectMaxVolumeDb, 0.0,
                           0.0F, &Model_Target_DW.sf_InnerLink_g);

    /* MATLAB Function: '<S213>/InnerLink' incorporates:
     *  Constant: '<S175>/ch3_mode'
     *  Constant: '<S34>/Constant'
     *  MATLAB Function: '<S182>/Preprocessing for Level Detector'
     */
    Model_Target_InnerLink(rtb_Delay3, rtb_max_j,
                           Model_Target_Near0.Ann3LevelDetectSlowDecayDbPerSample,
                           Model_Target_Near0.Ann3LevelDetectHoldMarginDb,
                           Model_Target_Near0.Ann3LevelDetectHoldTimeSamples,
                           Model_Target_Near0.Ann3LevelDetectFastDecayDbPerSample,
                           Model_Target_Near0.Ann3LevelDetectMinVolumeDb,
                           Model_Target_Near0.Ann3LevelDetectMaxVolumeDb, 0.0,
                           0.0F, &Model_Target_DW.sf_InnerLink_d);

    /* MATLAB Function: '<S221>/InnerLink' incorporates:
     *  Constant: '<S175>/ch4_mode'
     *  Constant: '<S34>/Constant'
     *  MATLAB Function: '<S182>/Preprocessing for Level Detector'
     */
    Model_Target_InnerLink(rtb_Delay3, rtb_max_j,
                           Model_Target_Near0.Ann4LevelDetectSlowDecayDbPerSample,
                           Model_Target_Near0.Ann4LevelDetectHoldMarginDb,
                           Model_Target_Near0.Ann4LevelDetectHoldTimeSamples,
                           Model_Target_Near0.Ann4LevelDetectFastDecayDbPerSample,
                           Model_Target_Near0.Ann4LevelDetectMinVolumeDb,
                           Model_Target_Near0.Ann4LevelDetectMaxVolumeDb, 0.0,
                           1.0F, &Model_Target_DW.sf_InnerLink_o);

    /* Selector: '<S34>/Selector2' incorporates:
     *  Concatenate: '<S34>/Vector Concatenate1'
     */
    memcpy(&Model_Target_B.Selector2_e[0], &Model_Target_B.VectorConcatenate1[0],
           sizeof(real32_T) << 6U);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S176>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S172>/PoolIirProcess' incorporates:
     *  S-Function (TOP_MEX): '<S159>/TOP'
     *  S-Function (TOP_MEX): '<S159>/TOP1'
     *  Selector: '<S34>/Selector2'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/PoolIirProcess': '<S173>:1' */
    /* '<S173>:1:5' [frame_size, num_channels] = size(x); */
    /*  Initialize variables */
    /*  Typecast the variables */
    /* '<S173>:1:11' frame_size = uint32(frame_size); */
    /* '<S173>:1:12' num_channels = uint32(num_channels); */
    /* Compute the filter coefficients */
    /* '<S173>:1:15' y = pooliir(x, frame_size, num_channels, numStages, coeffs, states); */
    /*  We have to use a different state buffer than the one passed in.  Matlab */
    /*  value objects are passed by value, not by reference, so the saving of */
    /*  states here does not work.  The state buffer is still necessary to pass */
    /*  allocate in the calling function and pass here in order to trigger CRL. */
    /*  This double buffering is annoying, however only happens during */
    /*  simulation, not code generation. */
    /*  num_states = (length(coeffs) - numChannels) / 2; */
    /*  persistent states; */
    /*  if isempty(states) */
    /*      states = single(zeros(1, num_states)); */
    /*  end */
    /* 'pooliir:15' stateIdx = 1; */
    Model_Target_B.vncBoostGain_j = 1.0;

    /* 'pooliir:16' coeffIdx = 1; */
    Model_Target_B.Switch1 = 1.0;

    /* 'pooliir:18' frameMinus1  = frameSize-1; */
    /*  number of samples minus one */
    /* 'pooliir:19' y     = coder.nullcopy(x); */
    /*  output matrix */
    /*  OUTER LOOP over all channels                  */
    /* 'pooliir:22' for cha = 1:numChannels */
    for (c = 0; c < 2; c++)
    {
        /*  FIRST STAGE */
        /*  prologue: get coefficients, states and input vector  */
        /*  and perform some computations */
        /* 'pooliir:28' w1 = states(stateIdx); */
        rtb_Delay3 = Model_Target_DW.states_b[(int32_T)
            Model_Target_B.vncBoostGain_j - 1];

        /* 'pooliir:28' stateIdx = stateIdx+1; */
        Model_Target_B.vncBoostGain_o = Model_Target_B.vncBoostGain_j + 1.0;

        /* S-Function (TOP_MEX): '<S159>/TOP' */
        /* 'pooliir:29' gain = coeffs(coeffIdx); */
        rtb_max_j = Model_Target_Near0.Coefficients[(int32_T)
            Model_Target_B.Switch1 - 1];

        /* 'pooliir:29' coeffIdx = coeffIdx+1; */
        /* 'pooliir:30' w2 = states(stateIdx); */
        w2 = Model_Target_DW.states_b[(int32_T)(Model_Target_B.vncBoostGain_j +
            1.0) - 1];

        /* 'pooliir:30' stateIdx = stateIdx-1; */
        Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0) -
            1.0;

        /* S-Function (TOP_MEX): '<S159>/TOP' */
        /* 'pooliir:31' a2   = coeffs(coeffIdx); */
        rtb_Max_h = Model_Target_Near0.Coefficients[(int32_T)
            (Model_Target_B.Switch1 + 1.0) - 1];

        /* 'pooliir:31' coeffIdx = coeffIdx+1; */
        /* 'pooliir:32' xx  = x(1,cha); */
        /* 'pooliir:32' a1   = coeffs(coeffIdx); */
        /* 'pooliir:32' coeffIdx = coeffIdx+1; */
        /* 'pooliir:33' xx  = xx*gain; */
        xpageoffset = c << 5;
        xx = Model_Target_B.Selector2_e[xpageoffset] * rtb_max_j;

        /* 'pooliir:33' b2   = coeffs(coeffIdx); */
        /* 'pooliir:33' coeffIdx = coeffIdx+1; */
        /* 'pooliir:34' yy  = w1+xx; */
        yy = rtb_Delay3 + xx;

        /* S-Function (TOP_MEX): '<S159>/TOP' incorporates:
         *  Selector: '<S34>/Selector2'
         */
        /* 'pooliir:34' b1   = coeffs(coeffIdx); */
        /* 'pooliir:34' coeffIdx = coeffIdx+1; */
        /* 'pooliir:35' w1  = b1*xx; */
        rtb_alpha = Model_Target_Near0.Coefficients[(int32_T)
            ((((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) + 1.0) - 1];
        rtb_Delay3 = rtb_alpha * xx;

        /*  main loop: 5 ops/sample */
        /* 'pooliir:38' i = 1; */
        /* 'pooliir:39' while i <= frameMinus1 */
        for (stateLen = 0; stateLen < 31; stateLen++)
        {
            /* 'pooliir:40' r  = a1*yy; */
            /* 'pooliir:40' w1 = w1+w2; */
            rtb_Delay3 += w2;

            /* 'pooliir:40' y(i,cha) = yy; */
            yIdx = stateLen + xpageoffset;
            Model_Target_B.y_ic[yIdx] = yy;

            /* 'pooliir:41' q  = b2*xx; */
            q = Model_Target_Near0.Coefficients[(int32_T)
                (((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) - 1] * xx;

            /* 'pooliir:41' w1 = w1-r; */
            /* 'pooliir:41' xx = x(i+1,cha); */
            /* 'pooliir:42' xx = xx*gain; */
            xx = Model_Target_B.Selector2_e[yIdx + 1] * rtb_max_j;

            /* 'pooliir:43' w2 = a2*yy; */
            w2 = rtb_Max_h * yy;

            /* 'pooliir:43' yy = w1+xx; */
            yy = (rtb_Delay3 - Model_Target_Near0.Coefficients[(int32_T)
                  ((Model_Target_B.Switch1 + 1.0) + 1.0) - 1] * yy) + xx;

            /* 'pooliir:44' w1 = b1*xx; */
            rtb_Delay3 = rtb_alpha * xx;

            /* 'pooliir:44' w2 = q-w2; */
            w2 = q - w2;

            /* 'pooliir:44' i = i + 1; */
        }

        /*  epilogue: drain pipe and write states */
        /* 'pooliir:48' r  = a1*yy; */
        /* 'pooliir:48' w1 = w1+w2; */
        /* 'pooliir:48' y(frameMinus1+1,cha) = yy; */
        Model_Target_B.y_ic[xpageoffset + 31] = yy;

        /* 'pooliir:49' q  = b2*xx; */
        /* 'pooliir:49' w1 = w1-r; */
        Model_Target_DW.states_b[(int32_T)(Model_Target_B.vncBoostGain_o - 1.0)
            - 1] = (rtb_Delay3 + w2) - Model_Target_Near0.Coefficients[(int32_T)
            ((Model_Target_B.Switch1 + 1.0) + 1.0) - 1] * yy;

        /* 'pooliir:50' w2 = a2*yy; */
        /* 'pooliir:50' states(stateIdx) = w1; */
        /* 'pooliir:50' stateIdx = stateIdx+1; */
        /* 'pooliir:51' w2 = q-w2; */
        Model_Target_DW.states_b[(int32_T)(Model_Target_B.vncBoostGain_j + 1.0)
            - 1] = Model_Target_Near0.Coefficients[(int32_T)
            (((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) - 1] * xx - rtb_Max_h
            * yy;

        /* 'pooliir:51' states(stateIdx) = w2; */
        /* 'pooliir:51' stateIdx = stateIdx+1; */
        Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0) +
            1.0;

        /*  NOTE: asm implementation needs to exit here if it's only */
        /*  one stage, NOTE: all subsequent stages work in-place */
        /* 'pooliir:55' for st = 2:numStages(cha) */
        b = Model_Target_Near0.NumStages[c];
        for (st = 2U; st <= b; st++)
        {
            /*  prologue: get coefficients, states and input vector,  */
            /*  and perform some computations */
            /* 'pooliir:58' w1 = states(stateIdx); */
            rtb_Delay3 = Model_Target_DW.states_b[(int32_T)
                Model_Target_B.vncBoostGain_j - 1];

            /* 'pooliir:58' stateIdx = stateIdx+1; */
            Model_Target_B.vncBoostGain_o = Model_Target_B.vncBoostGain_j + 1.0;

            /* 'pooliir:59' a2 = coeffs(coeffIdx); */
            Model_Target_B.vncBoostGain = (((((Model_Target_B.Switch1 + 1.0) +
                1.0) + 1.0) + 1.0) + 1.0) + ((real_T)st - 2.0) * 4.0;
            a2 = Model_Target_Near0.Coefficients[(int32_T)
                Model_Target_B.vncBoostGain - 1];

            /* 'pooliir:59' coeffIdx = coeffIdx+1; */
            /* 'pooliir:60' w2 = states(stateIdx); */
            w2 = Model_Target_DW.states_b[(int32_T)
                (Model_Target_B.vncBoostGain_j + 1.0) - 1];

            /* 'pooliir:60' stateIdx = stateIdx-1; */
            Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0)
                - 1.0;

            /* 'pooliir:61' a1 = coeffs(coeffIdx); */
            rtb_max_j = Model_Target_Near0.Coefficients[(int32_T)
                (Model_Target_B.vncBoostGain + 1.0) - 1];

            /* 'pooliir:61' coeffIdx = coeffIdx+1; */
            /* 'pooliir:62' xx = y(1,cha); */
            xx = Model_Target_B.y_ic[xpageoffset];

            /* 'pooliir:62' b2 = coeffs(coeffIdx); */
            /* 'pooliir:62' coeffIdx = coeffIdx+1; */
            /* 'pooliir:63' yy = w1+xx; */
            yy = xx + rtb_Delay3;

            /* 'pooliir:63' b1 = coeffs(coeffIdx); */
            /* 'pooliir:63' coeffIdx = coeffIdx+1; */
            /* 'pooliir:64' w1 = b1*xx; */
            rtb_alpha = Model_Target_Near0.Coefficients[(int32_T)
                (((Model_Target_B.vncBoostGain + 1.0) + 1.0) + 1.0) - 1];
            rtb_Delay3 = rtb_alpha * xx;

            /*  main loop: 4 ops/sample */
            /* 'pooliir:67' i = 1; */
            /* 'pooliir:68' while i <= frameMinus1 */
            for (stateLen = 0; stateLen < 31; stateLen++)
            {
                /* 'pooliir:69' r  = a1*yy; */
                /* 'pooliir:69' w1 = w1+w2; */
                rtb_Delay3 += w2;

                /* 'pooliir:69' y(i,cha) = yy; */
                yIdx = stateLen + xpageoffset;
                Model_Target_B.y_ic[yIdx] = yy;

                /* 'pooliir:70' q  = b2*xx; */
                q = Model_Target_Near0.Coefficients[(int32_T)
                    ((Model_Target_B.vncBoostGain + 1.0) + 1.0) - 1] * xx;

                /* 'pooliir:70' w1 = w1-r ; */
                /* 'pooliir:70' xx = y(i+1,cha); */
                xx = Model_Target_B.y_ic[yIdx + 1];

                /* 'pooliir:71' w2 = a2*yy; */
                w2 = a2 * yy;

                /* 'pooliir:71' yy = w1+xx; */
                yy = (rtb_Delay3 - rtb_max_j * yy) + xx;

                /* 'pooliir:72' w1 = b1*xx; */
                rtb_Delay3 = xx * rtb_alpha;

                /* 'pooliir:72' w2 = q-w2; */
                w2 = q - w2;

                /* 'pooliir:72' i = i + 1; */
            }

            /*  epilogue: drain pipe and write states */
            /* 'pooliir:76' r  = a1*yy; */
            /* 'pooliir:76' w1 = w1+w2; */
            /* 'pooliir:76' y(frameMinus1+1,cha) = yy; */
            Model_Target_B.y_ic[xpageoffset + 31] = yy;

            /* 'pooliir:77' q  = b2*xx; */
            /* 'pooliir:77' w1 = w1-r; */
            Model_Target_DW.states_b[(int32_T)(Model_Target_B.vncBoostGain_o -
                1.0) - 1] = (rtb_Delay3 + w2) - rtb_max_j * yy;

            /* 'pooliir:78' w2 = a2*yy; */
            /* 'pooliir:78' states(stateIdx) = w1; */
            /* 'pooliir:78' stateIdx = stateIdx+1; */
            /* 'pooliir:79' w2 = q-w2; */
            Model_Target_DW.states_b[(int32_T)(Model_Target_B.vncBoostGain_j +
                1.0) - 1] = Model_Target_Near0.Coefficients[(int32_T)
                ((Model_Target_B.vncBoostGain + 1.0) + 1.0) - 1] * xx - a2 * yy;

            /* 'pooliir:79' states(stateIdx) = w2; */
            /* 'pooliir:79' stateIdx = stateIdx+1; */
            Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0)
                + 1.0;
        }

        Model_Target_B.Switch1 = (((((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0)
            + 1.0) + 1.0) + (((real_T)b - 2.0) + 1.0) * 4.0;
    }

    /* End of MATLAB Function: '<S172>/PoolIirProcess' */

    /* Reshape: '<S172>/Reshape' */
    memcpy(&Model_Target_B.audioOut_ni[0], &Model_Target_B.y_ic[0], sizeof
           (real32_T) << 6U);

    /* Outputs for Atomic SubSystem: '<S158>/Ifir' */
    Model_Target_Ifir();

    /* End of Outputs for SubSystem: '<S158>/Ifir' */

    /* MATLAB Function: '<S163>/FirEvenProcess' incorporates:
     *  Constant: '<S158>/Constant'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenProcess': '<S165>:1' */
    /* '<S165>:1:4' [FilterLength, ~] = size(FlippedCoeffs); */
    /* '<S165>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Initialize variables */
    /* '<S165>:1:11' if isempty(States) */
    /*  Set correct data types */
    /* '<S165>:1:16' FilterLength = uint32(FilterLength); */
    /* '<S165>:1:17' FrameSize = uint32(FrameSize); */
    /* '<S165>:1:18' ActiveCoeffSet = uint32(ActiveCoeffSet); */
    /* '<S165>:1:21' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S165>:1:24' else */
    /*  FIR EVEN HEXAGON */
    /* '<S165>:1:26' if (FilterLength > FrameSize) */
    /* '<S165>:1:28' else */
    /* '<S165>:1:29' y = fireven_hexagon_process_lt(single(u), uint32(ActiveCoeffSet), single(States), uint32(CodeWorkMemory)); */
    fireven_process_lt(&Model_Target_B.Selector2_e[0],
                       &Model_Target_B.audioOut_p[0],
                       &Model_Target_ConstP.pooled102[0],
                       &Model_Target_DW.States_b[0],
                       &NearBandSplitCodeWorkMemory[0]);
    for (stateLen = 0; stateLen < 16; stateLen++)
    {
        /* DownSample: '<S158>/Downsample' */
        rtb_Delay3 = Model_Target_B.Selector2_e[stateLen << 2];

        /* SignalConversion generated from: '<S36>/Headrest Matrix Concatenate' */
        Model_Target_B.HeadrestMatrixConcatenate_i[stateLen] = rtb_Delay3;

        /* SignalConversion generated from: '<S36>/Headrest Matrix Concatenate' */
        Model_Target_B.HeadrestMatrixConcatenate_i[stateLen + 16] = rtb_Delay3;

        /* DownSample: '<S158>/Downsample' */
        Model_Target_B.Downsample_b[stateLen] = rtb_Delay3;
    }

    /* MATLAB Function: '<S51>/MATLAB Function' incorporates:
     *  Concatenate: '<S36>/Headrest Matrix Concatenate'
     *  S-Function (TOP_MEX): '<S53>/TOP'
     *  Selector: '<S36>/HeadrestSelector'
     */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'DelayPerChannel/MATLAB Function': '<S54>:1' */
    /*  figure out the frame size and channel count */
    /* '<S54>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S54>:1:8' frameSize = int32(frameSize); */
    /* '<S54>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S54>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S54>:1:11' delayTime = int32(delayTime); */
    /* '<S54>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S54>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S54>:1:23' bufferIndex = delayIndex; */
    xpageoffset = Model_Target_DW.delayIndex_o4;

    /* '<S54>:1:25' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 4; yIdx++)
    {
        Model_Target_B.delayTime[yIdx] = (int32_T)roundf
            (Model_Target_Near0.Dr_eqdelays[yIdx]);

        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S54>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(xpageoffset, 0, 2080);

        /* '<S54>:1:32' for sample = 1:frameSize */
        for (sample = 0; sample < 8; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S54>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_e[writeIndex] =
                Model_Target_B.HeadrestMatrixConcatenate_i[(yIdx << 3) + sample];

            /*  increment write pointer */
            /* '<S54>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 2080);
        }

        /*  Advance buffer index for next channel */
        /* '<S54>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 520, 2080);
    }

    /*  Reset */
    /* '<S54>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    xpageoffset = circindex(Model_Target_DW.delayIndex_o4, 8, 2080);

    /* '<S54>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_o4 = xpageoffset;

    /*  Read samples from delay line */
    /* '<S54>:1:50' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 4; yIdx++)
    {
        /*  Setup read pointer */
        /* '<S54>:1:53' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        writeIndex = circindex(xpageoffset, -(Model_Target_B.delayTime[yIdx] + 8),
                               2080);

        /* '<S54>:1:55' for sample = 1:frameSize */
        for (sample = 0; sample < 8; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S54>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.audioOut_o[sample + (yIdx << 3)] =
                Model_Target_DW.delayBuffer_e[writeIndex];

            /*  increment write pointer */
            /* '<S54>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 2080);
        }

        /*  Advance buffer index for next channel */
        /* '<S54>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 520, 2080);
    }

    /* End of MATLAB Function: '<S51>/MATLAB Function' */
    /* MATLAB Function: '<S58>/PoolIirProcess' */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S61>:1' */
    /*  Extract configuration information from inputs */
    /* '<S61>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S61>:1:20' VariantStr = char(VariantUint8); */
    /* '<S61>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S61>:1:29' else */
    /* '<S61>:1:30' switch(VariantStr) */
    /* '<S61>:1:31' case{"Hexagon"} */
    /* '<S61>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&Model_Target_B.HeadrestMatrixConcatenate_i[0],
                    &Model_Target_B.audioOut_o[0], &NearHrEqDr25031states[0]);

    /* Selector: '<S36>/DriverSelector' */
    rtb_DriverSelector_0 = &Model_Target_B.HeadrestMatrixConcatenate_i[0];

    /* Selector: '<S36>/PassengerSelector' */
    rtb_PassengerSelector_0 = &Model_Target_B.HeadrestMatrixConcatenate_i[16];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S131>/RTC Request Response Trigger' */

    /* SignalConversion generated from: '<S32>/Vector Concatenate2' */
    Model_Target_B.VectorConcatenate2_o[0] =
        Model_TargetNearChannel1_LocationRtcOut.REQ_loc[0];
    Model_Target_B.VectorConcatenate2_o[1] =
        Model_TargetNearChannel1_LocationRtcOut.REQ_loc[1];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S130>/RTC Request Response Trigger' */

    /* SignalConversion generated from: '<S32>/Vector Concatenate2' */
    Model_Target_B.VectorConcatenate2_o[2] =
        Model_TargetNearChannel2_LocationRtcOut.REQ_loc[0];
    Model_Target_B.VectorConcatenate2_o[3] =
        Model_TargetNearChannel2_LocationRtcOut.REQ_loc[1];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S133>/RTC Request Response Trigger' */

    /* SignalConversion generated from: '<S32>/Vector Concatenate2' */
    Model_Target_B.VectorConcatenate2_o[4] =
        Model_TargetNearChannel3_LocationRtcOut.REQ_loc[0];
    Model_Target_B.VectorConcatenate2_o[5] =
        Model_TargetNearChannel3_LocationRtcOut.REQ_loc[1];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S132>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S31>/MATLAB Function' incorporates:
     *  Concatenate: '<S32>/Vector Concatenate2'
     *  Constant: '<S31>/Constant'
     *  Selector: '<S31>/Selector'
     */
    Model_Target_MATLABFunction_n(Model_Target_B.VectorConcatenate2_o[0],
        Model_Target_Near0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[0],
        &Model_Target_DW.sf_MATLABFunction_n);

    /* MATLAB Function: '<S31>/MATLAB Function1' incorporates:
     *  Concatenate: '<S32>/Vector Concatenate2'
     *  Constant: '<S31>/Constant'
     *  Selector: '<S31>/Selector1'
     */
    Model_Target_MATLABFunction_n(Model_Target_B.VectorConcatenate2_o[1],
        Model_Target_Near0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[1],
        &Model_Target_DW.sf_MATLABFunction1);

    /* MATLAB Function: '<S31>/MATLAB Function3' incorporates:
     *  Concatenate: '<S32>/Vector Concatenate2'
     *  Constant: '<S31>/Constant'
     *  Selector: '<S31>/Selector2'
     */
    Model_Target_MATLABFunction_n(Model_Target_B.VectorConcatenate2_o[2],
        Model_Target_Near0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[2],
        &Model_Target_DW.sf_MATLABFunction3);

    /* MATLAB Function: '<S31>/MATLAB Function2' incorporates:
     *  Concatenate: '<S32>/Vector Concatenate2'
     *  Constant: '<S31>/Constant'
     *  Selector: '<S31>/Selector3'
     */
    Model_Target_MATLABFunction_n(Model_Target_B.VectorConcatenate2_o[3],
        Model_Target_Near0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[3],
        &Model_Target_DW.sf_MATLABFunction2);

    /* MATLAB Function: '<S31>/MATLAB Function4' incorporates:
     *  Concatenate: '<S32>/Vector Concatenate2'
     *  Constant: '<S31>/Constant'
     *  Selector: '<S31>/Selector4'
     */
    Model_Target_MATLABFunction_n(Model_Target_B.VectorConcatenate2_o[4],
        Model_Target_Near0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[4],
        &Model_Target_DW.sf_MATLABFunction4);

    /* MATLAB Function: '<S31>/MATLAB Function5' incorporates:
     *  Concatenate: '<S32>/Vector Concatenate2'
     *  Constant: '<S31>/Constant'
     *  Selector: '<S31>/Selector5'
     */
    Model_Target_MATLABFunction_n(Model_Target_B.VectorConcatenate2_o[5],
        Model_Target_Near0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[5],
        &Model_Target_DW.sf_MATLABFunction5);

    /* MATLAB Function: '<S31>/MATLAB Function6' incorporates:
     *  Constant: '<S31>/Constant'
     *  SignalConversion generated from: '<S32>/Vector Concatenate2'
     */
    Model_Target_MATLABFunction_n
        (Model_TargetNearChannel4_LocationRtcOut.REQ_loc[0],
         Model_Target_Near0.RampDbPerSample, 0.01,
         &Model_Target_B.MatrixConcatenate4[6],
         &Model_Target_DW.sf_MATLABFunction6);

    /* MATLAB Function: '<S31>/MATLAB Function7' incorporates:
     *  Constant: '<S31>/Constant'
     *  SignalConversion generated from: '<S32>/Vector Concatenate2'
     */
    Model_Target_MATLABFunction_n
        (Model_TargetNearChannel4_LocationRtcOut.REQ_loc[1],
         Model_Target_Near0.RampDbPerSample, 0.01,
         &Model_Target_B.MatrixConcatenate4[7],
         &Model_Target_DW.sf_MATLABFunction7);

    /* MATLAB Function: '<S38>/MATLAB Function' incorporates:
     *  Concatenate: '<S31>/Matrix Concatenate4'
     *  Constant: '<S38>/Constant'
     *  DownSample: '<S158>/Downsample'
     *  S-Function (TOP_MEX): '<S76>/TOP'
     *  Selector: '<S36>/DriverSelector'
     *  Selector: '<S36>/PassengerSelector'
     */
    /*  % Inputs % Parameters */
    /* MATLAB Function 'NEAR/Near1p1/DrProc/Upmixer1p1Dr/MATLAB Function': '<S75>:1' */
    /* '<S75>:1:4' frameSize   = size(FrontAudioIn, 1); */
    /* '<S75>:1:5' NonHr       = single(zeros(frameSize, FrontPeripheralChannelCount)); */
    memset(&Model_Target_B.NonHr_n[0], 0, 56U * sizeof(real32_T));

    /* '<S75>:1:6' Hr          = single(zeros(frameSize, ChannelsPerHeadrest*HeadrestCount)); */
    memset(&Model_Target_B.Hr_f[0], 0, 224U * sizeof(real32_T));

    /* '<S75>:1:8' for k = 1:AnnChannelCount */
    for (c = 0; c < 2; c++)
    {
        /* '<S75>:1:9' for j = 1:FrontPeripheralChannelCount */
        for (xpageoffset = 0; xpageoffset < 7; xpageoffset++)
        {
            /*              NonHr(:,j) = FrontAudioIn(:,1); */
            /* '<S75>:1:11' NonHr(:,j) = NonHr(:,j) + Mixer(FrontAudioIn(:,k), Loc(:,:,k), mix(:,:,j), interp); */
            Model_Target_Mixer(&Model_Target_B.Downsample_b[c << 3],
                               &Model_Target_B.MatrixConcatenate4[c << 1],
                               &(Model_Target_Near0.Dr_mix[25 * xpageoffset]),
                               1.0, Model_Target_B.VectorConcatenate2_o);
            for (yIdx = 0; yIdx < 8; yIdx++)
            {
                stateLen = (xpageoffset << 3) + yIdx;
                Model_Target_B.NonHr_n[stateLen] +=
                    Model_Target_B.VectorConcatenate2_o[yIdx];
            }
        }

        /* '<S75>:1:14' for j = 1:ChannelsPerHeadrest */
        /* '<S75>:1:19' if HeadrestCount == 2 */
        /* '<S75>:1:20' for j = 1:ChannelsPerHeadrest */
        for (xpageoffset = 0; xpageoffset < 14; xpageoffset++)
        {
            /*              Hr(:,j) = DriverAudioIn(:,1); */
            /* '<S75>:1:16' Hr(:,j) = Hr(:,j) + Mixer(DriverAudioIn(:,k), Loc(:,:,k), mix(:,:,j+FrontPeripheralChannelCount), interp); */
            yIdx = c << 3;
            stateLen = c << 1;
            Model_Target_Mixer(&rtb_DriverSelector_0[yIdx],
                               &Model_Target_B.MatrixConcatenate4[stateLen],
                               &(Model_Target_Near0.Dr_mix[(xpageoffset + 7) *
                                 25]), 1.0, Model_Target_B.VectorConcatenate2_o);

            /*                  Hr(:,j+channels_per_headrest) = PassengerAudioIn(:,1); */
            /* '<S75>:1:22' Hr(:,j+ChannelsPerHeadrest) = Hr(:,j+ChannelsPerHeadrest) + Mixer(PassengerAudioIn(:,k), Loc(:,:,k), mix(:,:,j+FrontPeripheralChannelCount+ChannelsPerHeadrest), interp); */
            Model_Target_Mixer(&rtb_PassengerSelector_0[yIdx],
                               &Model_Target_B.MatrixConcatenate4[stateLen],
                               &(Model_Target_Near0.Dr_mix[(xpageoffset + 21) *
                                 25]), 1.0, Model_Target_B.fv);
            for (yIdx = 0; yIdx < 8; yIdx++)
            {
                stateLen = (xpageoffset << 3) + yIdx;
                Model_Target_B.Hr_f[stateLen] +=
                    Model_Target_B.VectorConcatenate2_o[yIdx];
                stateLen = ((xpageoffset + 14) << 3) + yIdx;
                Model_Target_B.Hr_f[stateLen] += Model_Target_B.fv[yIdx];
            }
        }
    }

    /* End of MATLAB Function: '<S38>/MATLAB Function' */
    /* MATLAB Function: '<S39>/MATLAB Function' incorporates:
     *  S-Function (TOP_MEX): '<S41>/TOP'
     */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'DelayPerChannel/MATLAB Function': '<S42>:1' */
    /*  figure out the frame size and channel count */
    /* '<S42>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S42>:1:8' frameSize = int32(frameSize); */
    /* '<S42>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S42>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S42>:1:11' delayTime = int32(delayTime); */
    /* '<S42>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S42>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S42>:1:23' bufferIndex = delayIndex; */
    xpageoffset = Model_Target_DW.delayIndex_b;

    /* '<S42>:1:25' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 7; yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S42>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(xpageoffset, 0, 3640);

        /* '<S42>:1:32' for sample = 1:frameSize */
        for (sample = 0; sample < 8; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S42>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_b[writeIndex] = Model_Target_B.NonHr_n
                [(yIdx << 3) + sample];

            /*  increment write pointer */
            /* '<S42>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 3640);
        }

        /*  Advance buffer index for next channel */
        /* '<S42>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 520, 3640);
    }

    /*  Reset */
    /* '<S42>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    xpageoffset = circindex(Model_Target_DW.delayIndex_b, 8, 3640);

    /* '<S42>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_b = xpageoffset;

    /*  Read samples from delay line */
    /* '<S42>:1:50' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 7; yIdx++)
    {
        /*  Setup read pointer */
        /* '<S42>:1:53' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        writeIndex = circindex(xpageoffset,
                               -(Model_Target_Near0.Dr_EqDelays[yIdx] + 8), 3640);

        /* '<S42>:1:55' for sample = 1:frameSize */
        for (sample = 0; sample < 8; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S42>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.audioOut_o2[sample + (yIdx << 3)] =
                Model_Target_DW.delayBuffer_b[writeIndex];

            /*  increment write pointer */
            /* '<S42>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 3640);
        }

        /*  Advance buffer index for next channel */
        /* '<S42>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 520, 3640);
    }

    /* End of MATLAB Function: '<S39>/MATLAB Function' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S47>/ITC1' */

    /* MATLAB Function: '<S46>/PoolIirProcess' */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S49>:1' */
    /*  Extract configuration information from inputs */
    /* '<S49>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S49>:1:20' VariantStr = char(VariantUint8); */
    /* '<S49>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S49>:1:29' else */
    /* '<S49>:1:30' switch(VariantStr) */
    /* '<S49>:1:31' case{"Hexagon"} */
    /* '<S49>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&Model_Target_B.NonHr_n[0], &Model_Target_B.audioOut_o2[0],
                    &NearFsDrEq47493states[0]);

    /* End of Outputs for S-Function (InitTriggerControl): '<S59>/ITC1' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S65>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S63>/MATLAB Function' */
    Model_Target_MATLABFunction(&(Model_Target_Near0.Dr_RouterOutMap[0]),
        &(Model_TargetNearDr_RouterSetRtcOut.REQ_routerMap[0]),
        &Model_Target_B.sf_MATLABFunction_eq);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S27>/RTC Request Response Trigger' */

    /* Switch: '<S29>/Switch1' incorporates:
     *  Constant: '<S29>/Constant'
     */
    rtb_Merge = (Model_TargetNearEnableRtcOut.REQ_Enable != 0U);
    for (yIdx = 0; yIdx < 56; yIdx++)
    {
        rtb_Delay3 = Model_Target_B.NonHr_n[yIdx];
        if (!rtb_Merge)
        {
            rtb_Delay3 = 0.0F;
        }

        Model_Target_B.NonHr_n[yIdx] = rtb_Delay3;
    }

    /* End of Switch: '<S29>/Switch1' */

    /* S-Function (sdspperm2): '<S66>/Variable Selector' incorporates:
     *  S-Function (sdspupfir2): '<S158>/Reconstruction Filter'
     *  Switch: '<S29>/Switch1'
     */
    for (c = 0; c < 18; c++)
    {
        xpageoffset = Model_Target_B.sf_MATLABFunction_eq.routerMapOut[c];
        if (Model_Target_B.sf_MATLABFunction_eq.routerMapOut[c] - 1 < 0)
        {
            xpageoffset = 1;
        }
        else if (Model_Target_B.sf_MATLABFunction_eq.routerMapOut[c] - 1 >= 7)
        {
            xpageoffset = 7;
        }

        for (stateLen = 0; stateLen < 8; stateLen++)
        {
            Model_Target_B.ReconstructionFilter_h[(c << 3) + stateLen] =
                Model_Target_B.NonHr_n[((xpageoffset - 1) << 3) + stateLen];
        }
    }

    /* End of S-Function (sdspperm2): '<S66>/Variable Selector' */

    /* Logic: '<S66>/OR' incorporates:
     *  Constant: '<S73>/Constant'
     *  Constant: '<S74>/Constant'
     *  RelationalOperator: '<S73>/Compare'
     *  RelationalOperator: '<S74>/Compare'
     */
    for (xpageoffset = 0; xpageoffset < 18; xpageoffset++)
    {
        Model_Target_B.OR_j[xpageoffset] =
            ((Model_Target_B.sf_MATLABFunction_eq.routerMapOut[xpageoffset] <= 0)
             || (Model_Target_B.sf_MATLABFunction_eq.routerMapOut[xpageoffset] >
                 10));
    }

    /* End of Logic: '<S66>/OR' */

    /* Find: '<S66>/Find Nonzero Elements' incorporates:
     *  Logic: '<S66>/OR'
     */
    stateLen = 0;
    c = 0;
    for (xpageoffset = 0; xpageoffset < 18; xpageoffset++)
    {
        if (Model_Target_B.OR_j[c])
        {
            Model_Target_B.FindNonzeroElements_c[stateLen] = (int8_T)
                (xpageoffset + 1);
            stateLen++;
        }

        c++;
    }

    Model_Target_DW.FindNonzeroElements_DIMS1 = stateLen;

    /* End of Find: '<S66>/Find Nonzero Elements' */

    /* Assignment: '<S66>/Assignment' incorporates:
     *  Constant: '<S66>/Constant3'
     *  Find: '<S66>/Find Nonzero Elements'
     *  S-Function (sdspupfir2): '<S158>/Reconstruction Filter'
     */
    memcpy(&Model_Target_B.Assignment_j[0],
           &Model_Target_B.ReconstructionFilter_h[0], 144U * sizeof(real32_T));
    for (yIdx = 0; yIdx < Model_Target_DW.FindNonzeroElements_DIMS1; yIdx++)
    {
        for (stateLen = 0; stateLen < 8; stateLen++)
        {
            Model_Target_B.Assignment_j[stateLen +
                ((Model_Target_B.FindNonzeroElements_c[yIdx] - 1) << 3)] = 0.0F;
        }
    }

    /* End of Assignment: '<S66>/Assignment' */

    /* Switch: '<S29>/Switch3' incorporates:
     *  Constant: '<S29>/Constant'
     */
    for (xpageoffset = 0; xpageoffset < 224; xpageoffset++)
    {
        if (Model_TargetNearEnableRtcOut.REQ_Enable != 0U)
        {
            Model_Target_B.Switch3[xpageoffset] =
                Model_Target_B.Hr_f[xpageoffset];
        }
        else
        {
            Model_Target_B.Switch3[xpageoffset] = 0.0F;
        }
    }

    /* End of Switch: '<S29>/Switch3' */

    /* S-Function (sdspupfir2): '<S158>/Reconstruction Filter' incorporates:
     *  DownSample: '<S158>/Downsample'
     */
    /* Loop over each input channel */
    for (c = 0; c < 2; c++)
    {
        yIdx = c * 33;
        writeIndex = c << 3;
        sample = writeIndex << 2;
        for (m = 0; m < 4; m++)
        {
            int32_T coefArrayIdx;
            int32_T oIdx;
            oIdx = sample + m;
            coefArrayIdx = m * 34;

            /* Consume delay line and beginning of input samples */
            for (stateLen = 0; stateLen < 8; stateLen++)
            {
                rtb_Delay3 = 0.0F;
                for (xpageoffset = 0; xpageoffset < stateLen + 1; xpageoffset++)
                {
                    rtb_Delay3 += Model_Target_B.Downsample_b[(writeIndex +
                        stateLen) - xpageoffset] *
                        Model_Target_ConstP.ReconstructionFilter_FILTER_COEFF[coefArrayIdx
                        + xpageoffset];
                }

                for (xpageoffset = 0; xpageoffset < 33 - stateLen; xpageoffset++)
                {
                    rtb_Delay3 +=
                        Model_Target_ConstP.ReconstructionFilter_FILTER_COEFF
                        [((coefArrayIdx + stateLen) + xpageoffset) + 1] *
                        Model_Target_DW.ReconstructionFilter_TapDelayBuff_n[yIdx
                        + xpageoffset];
                }

                Model_Target_B.ReconstructionFilter_h[oIdx] = rtb_Delay3;
                oIdx += 4;
            }
        }

        /* Update delay line for next frame */
        for (stateLen = yIdx + 24; stateLen >= yIdx; stateLen--)
        {
            Model_Target_DW.ReconstructionFilter_TapDelayBuff_n[stateLen + 8] =
                Model_Target_DW.ReconstructionFilter_TapDelayBuff_n[stateLen];
        }

        for (stateLen = 0; stateLen < 8; stateLen++)
        {
            Model_Target_DW.ReconstructionFilter_TapDelayBuff_n[(yIdx - stateLen)
                + 7] = Model_Target_B.Downsample_b[writeIndex + stateLen];
        }
    }

    /* End of S-Function (sdspupfir2): '<S158>/Reconstruction Filter' */

    /* Sum: '<S158>/Sum' incorporates:
     *  Delay: '<S158>/Band Separation Delay'
     */
    memcpy(&Model_Target_B.Selector2_e[0],
           &Model_Target_B.ReconstructionFilter_h[0], sizeof(real32_T) << 6U);
    for (yIdx = 0; yIdx < 2; yIdx++)
    {
        for (stateLen = 0; stateLen < 32; stateLen++)
        {
            c = (yIdx << 5) + stateLen;
            Model_Target_B.Sum_g[c] =
                Model_Target_DW.BandSeparationDelay_DSTATE_h[134 * yIdx +
                stateLen] - Model_Target_B.Selector2_e[c];
        }
    }

    /* End of Sum: '<S158>/Sum' */

    /* If: '<S30>/If' incorporates:
     *  Assignment: '<S110>/Assignment'
     *  Concatenate: '<S31>/Matrix Concatenate4'
     *  Concatenate: '<S80>/Headrest Matrix Concatenate'
     *  Constant: '<S110>/Constant3'
     *  Constant: '<S78>/Constant'
     *  Constant: '<S82>/Constant'
     *  Find: '<S110>/Find Nonzero Elements'
     *  Logic: '<S110>/OR'
     *  M-S-Function: '<S107>/FeaturePath'
     *  M-S-Function: '<S78>/FeaturePath'
     *  M-S-Function: '<S87>/FeaturePath'
     *  M-S-Function: '<S99>/FeaturePath'
     *  MATLAB Function: '<S102>/PoolIirProcess'
     *  MATLAB Function: '<S107>/MATLAB Function'
     *  MATLAB Function: '<S82>/MATLAB Function'
     *  MATLAB Function: '<S83>/MATLAB Function'
     *  MATLAB Function: '<S90>/PoolIirProcess'
     *  MATLAB Function: '<S95>/MATLAB Function'
     *  S-Function (AudioStats_MEX): '<S87>/AudioStats'
     *  S-Function (AudioStats_MEX): '<S99>/AudioStats'
     *  S-Function (TOP_MEX): '<S107>/TOP'
     *  S-Function (TOP_MEX): '<S120>/TOP'
     *  S-Function (TOP_MEX): '<S85>/TOP'
     *  S-Function (TOP_MEX): '<S87>/TOP'
     *  S-Function (TOP_MEX): '<S87>/TOP1'
     *  S-Function (TOP_MEX): '<S97>/TOP'
     *  S-Function (TOP_MEX): '<S99>/TOP'
     *  S-Function (TOP_MEX): '<S99>/TOP1'
     *  S-Function (sdspperm2): '<S110>/Variable Selector'
     *  Selector: '<S80>/DriverSelector'
     *  Selector: '<S80>/HeadrestSelector'
     *  Selector: '<S80>/PassengerSelector'
     *  SignalConversion generated from: '<S80>/Headrest Matrix Concatenate'
     *  Sum: '<S158>/Sum'
     *  Switch: '<S78>/Switch1'
     */
    rtPrevAction = Model_Target_DW.If_ActiveSubsystem;
    Model_Target_DW.If_ActiveSubsystem = 0;
    if (rtPrevAction != 0)
    {
        if (rtPrevAction == 0)
        {
        }
    }

    /* Outputs for IfAction SubSystem: '<S30>/Subsystem' incorporates:
     *  ActionPort: '<S78>/Action Port'
     */
    for (xpageoffset = 0; xpageoffset < 64; xpageoffset++)
    {
        rtb_Delay3 = Model_Target_B.Sum_g[xpageoffset];

        /* SignalConversion generated from: '<S80>/Headrest Matrix Concatenate' incorporates:
         *  Sum: '<S158>/Sum'
         */
        Model_Target_B.VectorConcatenate1[xpageoffset] = rtb_Delay3;

        /* SignalConversion generated from: '<S80>/Headrest Matrix Concatenate' */
        Model_Target_B.VectorConcatenate1[xpageoffset + 64] = rtb_Delay3;
    }

    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'DelayPerChannel/MATLAB Function': '<S98>:1' */
    /*  figure out the frame size and channel count */
    /* '<S98>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S98>:1:8' frameSize = int32(frameSize); */
    /* '<S98>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S98>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S98>:1:11' delayTime = int32(delayTime); */
    /* '<S98>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S98>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S98>:1:23' bufferIndex = delayIndex; */
    xpageoffset = Model_Target_DW.delayIndex_l;

    /* '<S98>:1:25' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 4; yIdx++)
    {
        Model_Target_B.delayTime[yIdx] = (int32_T)roundf
            (Model_Target_Near0.Fr_eqdelays[yIdx]);

        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S98>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(xpageoffset, 0, 2176);

        /* '<S98>:1:32' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S98>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_hg[writeIndex] =
                Model_Target_B.VectorConcatenate1[(yIdx << 5) + sample];

            /*  increment write pointer */
            /* '<S98>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 2176);
        }

        /*  Advance buffer index for next channel */
        /* '<S98>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 544, 2176);
    }

    /*  Reset */
    /* '<S98>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    xpageoffset = circindex(Model_Target_DW.delayIndex_l, 32, 2176);

    /* '<S98>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_l = xpageoffset;

    /*  Read samples from delay line */
    /* '<S98>:1:50' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 4; yIdx++)
    {
        /*  Setup read pointer */
        /* '<S98>:1:53' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        writeIndex = circindex(xpageoffset, -(Model_Target_B.delayTime[yIdx] +
                                32), 2176);

        /* '<S98>:1:55' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S98>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.audioOut_m[sample + (yIdx << 5)] =
                Model_Target_DW.delayBuffer_hg[writeIndex];

            /*  increment write pointer */
            /* '<S98>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 2176);
        }

        /*  Advance buffer index for next channel */
        /* '<S98>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 544, 2176);
    }

    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S105>:1' */
    /*  Extract configuration information from inputs */
    /* '<S105>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S105>:1:20' VariantStr = char(VariantUint8); */
    /* '<S105>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S105>:1:29' else */
    /* '<S105>:1:30' switch(VariantStr) */
    /* '<S105>:1:31' case{"Hexagon"} */
    /* '<S105>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&Model_Target_B.VectorConcatenate1[0],
                    &Model_Target_B.audioOut_m[0], &NearHrEqFr28288states[0]);
    memcpy(&Model_Target_B.Selector2_e[0], &Model_Target_B.VectorConcatenate1[0],
           sizeof(real32_T) << 6U);
    memcpy(&Model_Target_B.y_ic[0], &Model_Target_B.VectorConcatenate1[64],
           sizeof(real32_T) << 6U);

    /*  % Inputs % Parameters */
    /* MATLAB Function 'NEAR/Near1p1/FrProc/Subsystem/Upmixer1p1Fr/MATLAB Function': '<S119>:1' */
    /* '<S119>:1:4' frameSize   = size(FrontAudioIn, 1); */
    /* '<S119>:1:5' NonHr       = single(zeros(frameSize, FrontPeripheralChannelCount)); */
    memset(&Model_Target_B.NonHr[0], 0, 160U * sizeof(real32_T));

    /* '<S119>:1:6' Hr          = single(zeros(frameSize, ChannelsPerHeadrest*HeadrestCount)); */
    memset(&Model_Target_B.VectorConcatenate1[0], 0, sizeof(real32_T) << 7U);

    /* '<S119>:1:8' for k = 1:AnnChannelCount */
    for (c = 0; c < 2; c++)
    {
        /* '<S119>:1:9' for j = 1:FrontPeripheralChannelCount */
        for (xpageoffset = 0; xpageoffset < 5; xpageoffset++)
        {
            /*              NonHr(:,j) = FrontAudioIn(:,1); */
            /* '<S119>:1:11' NonHr(:,j) = NonHr(:,j) + Mixer(FrontAudioIn(:,k), Loc(:,:,k), mix(:,:,j), interp); */
            Model_Target_Mixer_l(&Model_Target_B.Sum_g[c << 5],
                                 &Model_Target_B.MatrixConcatenate4[c << 1],
                                 &(Model_Target_Near0.Fr_mix[25 * xpageoffset]),
                                 1.0, Model_Target_B.HeadrestMatrixConcatenate_i);
            for (yIdx = 0; yIdx < 32; yIdx++)
            {
                writeIndex = (xpageoffset << 5) + yIdx;
                Model_Target_B.NonHr[writeIndex] +=
                    Model_Target_B.HeadrestMatrixConcatenate_i[yIdx];
            }
        }

        /* '<S119>:1:14' for j = 1:ChannelsPerHeadrest */
        /* '<S119>:1:19' if HeadrestCount == 2 */
        /* '<S119>:1:20' for j = 1:ChannelsPerHeadrest */
        for (xpageoffset = 0; xpageoffset < 2; xpageoffset++)
        {
            /*              Hr(:,j) = DriverAudioIn(:,1); */
            /* '<S119>:1:16' Hr(:,j) = Hr(:,j) + Mixer(DriverAudioIn(:,k), Loc(:,:,k), mix(:,:,j+FrontPeripheralChannelCount), interp); */
            yIdx = c << 5;
            stateLen = c << 1;
            Model_Target_Mixer_l(&Model_Target_B.Selector2_e[yIdx],
                                 &Model_Target_B.MatrixConcatenate4[stateLen],
                                 &(Model_Target_Near0.Fr_mix[(xpageoffset + 5) *
                                   25]), 1.0,
                                 Model_Target_B.HeadrestMatrixConcatenate_i);

            /*                  Hr(:,j+channels_per_headrest) = PassengerAudioIn(:,1); */
            /* '<S119>:1:22' Hr(:,j+ChannelsPerHeadrest) = Hr(:,j+ChannelsPerHeadrest) + Mixer(PassengerAudioIn(:,k), Loc(:,:,k), mix(:,:,j+FrontPeripheralChannelCount+ChannelsPerHeadrest), interp); */
            Model_Target_Mixer_l(&Model_Target_B.y_ic[yIdx],
                                 &Model_Target_B.MatrixConcatenate4[stateLen],
                                 &(Model_Target_Near0.Fr_mix[(xpageoffset + 7) *
                                   25]), 1.0, Model_Target_B.Merge_f);
            for (yIdx = 0; yIdx < 32; yIdx++)
            {
                stateLen = (xpageoffset << 5) + yIdx;
                Model_Target_B.VectorConcatenate1[stateLen] +=
                    Model_Target_B.HeadrestMatrixConcatenate_i[yIdx];
                stateLen = ((xpageoffset + 2) << 5) + yIdx;
                Model_Target_B.VectorConcatenate1[stateLen] +=
                    Model_Target_B.Merge_f[yIdx];
            }
        }
    }

    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'DelayPerChannel/MATLAB Function': '<S86>:1' */
    /*  figure out the frame size and channel count */
    /* '<S86>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S86>:1:8' frameSize = int32(frameSize); */
    /* '<S86>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S86>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S86>:1:11' delayTime = int32(delayTime); */
    /* '<S86>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S86>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S86>:1:23' bufferIndex = delayIndex; */
    xpageoffset = Model_Target_DW.delayIndex_lx;

    /* '<S86>:1:25' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 5; yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S86>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(xpageoffset, 0, 2720);

        /* '<S86>:1:32' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S86>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_o[writeIndex] = Model_Target_B.NonHr
                [(yIdx << 5) + sample];

            /*  increment write pointer */
            /* '<S86>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 2720);
        }

        /*  Advance buffer index for next channel */
        /* '<S86>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 544, 2720);
    }

    /*  Reset */
    /* '<S86>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    xpageoffset = circindex(Model_Target_DW.delayIndex_lx, 32, 2720);

    /* '<S86>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_lx = xpageoffset;

    /*  Read samples from delay line */
    /* '<S86>:1:50' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 5; yIdx++)
    {
        /*  Setup read pointer */
        /* '<S86>:1:53' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        writeIndex = circindex(xpageoffset,
                               -(Model_Target_Near0.Fr_EqDelays[yIdx] + 32),
                               2720);

        /* '<S86>:1:55' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S86>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.audioOut_dj[sample + (yIdx << 5)] =
                Model_Target_DW.delayBuffer_o[writeIndex];

            /*  increment write pointer */
            /* '<S86>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 2720);
        }

        /*  Advance buffer index for next channel */
        /* '<S86>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 544, 2720);
    }

    /* End of Outputs for S-Function (InitTriggerControl): '<S91>/ITC1' */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S93>:1' */
    /*  Extract configuration information from inputs */
    /* '<S93>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S93>:1:20' VariantStr = char(VariantUint8); */
    /* '<S93>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S93>:1:29' else */
    /* '<S93>:1:30' switch(VariantStr) */
    /* '<S93>:1:31' case{"Hexagon"} */
    /* '<S93>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&Model_Target_B.NonHr[0], &Model_Target_B.audioOut_dj[0],
                    &NearFsFrEq10008states[0]);

    /* End of Outputs for S-Function (InitTriggerControl): '<S103>/ITC1' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S109>/RTC Request Response Trigger' */
    Model_Target_MATLABFunction(&(Model_Target_Near0.Fr_RouterOutMap[0]),
        &(Model_TargetNearFr_RouterSetRtcOut.REQ_routerMap[0]),
        &Model_Target_B.sf_MATLABFunction_b);

    /* End of Outputs for S-Function (RTC_NTF): '<S109>/NTF Trigger' */
    rtb_Merge = (Model_TargetNearEnableRtcOut.REQ_Enable != 0U);
    for (yIdx = 0; yIdx < 160; yIdx++)
    {
        rtb_Delay3 = Model_Target_B.NonHr[yIdx];
        if (!rtb_Merge)
        {
            rtb_Delay3 = 0.0F;
        }

        Model_Target_B.NonHr[yIdx] = rtb_Delay3;
    }

    for (c = 0; c < 18; c++)
    {
        /* S-Function (sdspperm2): '<S110>/Variable Selector' incorporates:
         *  Switch: '<S78>/Switch1'
         */
        xpageoffset = Model_Target_B.sf_MATLABFunction_b.routerMapOut[c];
        if (Model_Target_B.sf_MATLABFunction_b.routerMapOut[c] - 1 < 0)
        {
            xpageoffset = 1;
        }
        else if (Model_Target_B.sf_MATLABFunction_b.routerMapOut[c] - 1 >= 5)
        {
            xpageoffset = 5;
        }

        memcpy(&Model_Target_B.VariableSelector_k[c << 5],
               &Model_Target_B.NonHr[(xpageoffset << 5) + -32], sizeof(real32_T)
               << 5U);

        /* End of S-Function (sdspperm2): '<S110>/Variable Selector' */
    }

    for (xpageoffset = 0; xpageoffset < 18; xpageoffset++)
    {
        /* Logic: '<S110>/OR' incorporates:
         *  Constant: '<S117>/Constant'
         *  Constant: '<S118>/Constant'
         *  RelationalOperator: '<S117>/Compare'
         *  RelationalOperator: '<S118>/Compare'
         */
        Model_Target_B.OR_j[xpageoffset] =
            ((Model_Target_B.sf_MATLABFunction_b.routerMapOut[xpageoffset] <= 0)
             || (Model_Target_B.sf_MATLABFunction_b.routerMapOut[xpageoffset] >
                 10));
    }

    stateLen = 0;
    c = 0;
    for (xpageoffset = 0; xpageoffset < 18; xpageoffset++)
    {
        if (Model_Target_B.OR_j[c])
        {
            Model_Target_B.FindNonzeroElements_j[stateLen] = (int8_T)
                (xpageoffset + 1);
            stateLen++;
        }

        c++;
    }

    Model_Target_DW.FindNonzeroElements_DIMS1_a = stateLen;
    memcpy(&Model_Target_B.MatrixConcatenate_g[0],
           &Model_Target_B.VariableSelector_k[0], 576U * sizeof(real32_T));
    for (yIdx = 0; yIdx < Model_Target_DW.FindNonzeroElements_DIMS1_a; yIdx++)
    {
        for (stateLen = 0; stateLen < 32; stateLen++)
        {
            Model_Target_B.MatrixConcatenate_g[stateLen +
                ((Model_Target_B.FindNonzeroElements_j[yIdx] - 1) << 5)] = 0.0F;
        }
    }

    for (xpageoffset = 0; xpageoffset < 128; xpageoffset++)
    {
        /* Switch: '<S78>/Switch3' incorporates:
         *  Constant: '<S78>/Constant'
         */
        if (Model_TargetNearEnableRtcOut.REQ_Enable != 0U)
        {
            Model_Target_B.MatrixConcatenate_g[xpageoffset + 576] =
                Model_Target_B.VectorConcatenate1[xpageoffset];
        }
        else
        {
            Model_Target_B.MatrixConcatenate_g[xpageoffset + 576] = 0.0F;
        }

        /* End of Switch: '<S78>/Switch3' */
    }

    /* End of Outputs for S-Function (InitTriggerControl): '<S166>/ITC1' */

    /* MATLAB Function: '<S4>/MATLAB Function' */
    Model_Target_B.y = Model_TargetNearEnableRtcOut.REQ_Enable;

    /* Update for M-S-Function: '<S259>/TSP' */
    /* MATLAB Function 'NEAR/MATLAB Function': '<S25>:1' */
    /* '<S25>:1:3' y = u; */
    // TSP advanced triggered capture for NearAnn1Ann1NonEntGainCalcGetNonEntBoostLeveldB '<S259>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 0, &Model_Target_B.Switch);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S339>/TSP' */
    // TSP advanced triggered capture for NearAnn2Ann2NonEntGainCalcGetNonEntBoostLeveldB '<S339>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 1, &Model_Target_B.Switch_j);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S419>/TSP' */
    // TSP advanced triggered capture for NearAnn3Ann3NonEntGainCalcGetNonEntBoostLeveldB '<S419>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 2, &Model_Target_B.Switch_g);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S499>/TSP' */
    // TSP advanced triggered capture for NearAnn4Ann4NonEntGainCalcGetNonEntBoostLeveldB '<S499>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 3, &Model_Target_B.Switch_c);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for Delay: '<S158>/Band Separation Delay' */
    for (c = 0; c < 2; c++)
    {
        for (stateLen = 0; stateLen < 102; stateLen++)
        {
            xpageoffset = c * 134 + stateLen;
            Model_Target_DW.BandSeparationDelay_DSTATE_h[xpageoffset] =
                Model_Target_DW.BandSeparationDelay_DSTATE_h[xpageoffset + 32];
        }
    }

    for (yIdx = 0; yIdx < 2; yIdx++)
    {
        memcpy(&Model_Target_DW.BandSeparationDelay_DSTATE_h[yIdx * 134 + 102],
               &Model_Target_B.audioOut_ni[yIdx << 5], sizeof(real32_T) << 5U);
    }

    /* End of Update for Delay: '<S158>/Band Separation Delay' */
    /* End of Outputs for SubSystem: '<Root>/NEAR' */

    /* Outputs for Atomic SubSystem: '<S7>/SrcDownEnt' */
    Model_Target_SrcDownEntTID2();

    /* End of Outputs for SubSystem: '<S7>/SrcDownEnt' */

    /* Outputs for Atomic SubSystem: '<S7>/PreAmpPart1' */
    Model_Target_PreAmpPart1();

    /* End of Outputs for SubSystem: '<S7>/PreAmpPart1' */

    /* Outputs for Atomic SubSystem: '<S7>/SrcDownMic' */
    Model_Target_SrcDownMicTID2();

    /* End of Outputs for SubSystem: '<S7>/SrcDownMic' */

    /* Outputs for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* SignalConversion generated from: '<S900>/Matrix Concatenate' incorporates:
     *  Concatenate: '<S900>/Matrix Concatenate'
     *  Constant: '<S900>/Constant'
     */
    Model_Target_B.MatrixConcatenate_j[10] = 0.0F;
    Model_Target_B.MatrixConcatenate_j[11] = 0.0F;

    /* S-Function (sdspsine2): '<S886>/Modulating Sine Wave' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] =
            Model_Target_ConstP.ModulatingSineWave_Values_SineTable[Model_Target_DW.ModulatingSineWave_TableIdx];
        Model_Target_DW.ModulatingSineWave_TableIdx++;
        if (Model_Target_DW.ModulatingSineWave_TableIdx >= 10)
        {
            Model_Target_DW.ModulatingSineWave_TableIdx = 0U;
        }
    }

    /* End of S-Function (sdspsine2): '<S886>/Modulating Sine Wave' */

    /* Product: '<S886>/Matrix Multiply' incorporates:
     *  Constant: '<S886>/Constant'
     *  DownSample: '<S886>/Downsample2'
     *  S-Function (sdspsine2): '<S886>/Modulating Sine Wave'
     */
    for (yIdx = 0; yIdx < 5; yIdx++)
    {
        memcpy(&Model_Target_B.Downsample2[yIdx << 5],
               &Model_Target_B.HeadrestMatrixConcatenate_i[0], sizeof(real32_T) <<
               5U);
    }

    /* End of Product: '<S886>/Matrix Multiply' */

    /* SignalConversion generated from: '<S886>/Matrix Concatenate' incorporates:
     *  Concatenate: '<S886>/Matrix Concatenate'
     *  S-Function (SampleRateConverter_sfunc): '<S2051>/S-Function'
     */
    memcpy(&Model_Target_B.MatrixConcatenate_m[0], &Model_Target_B.SFunction[0],
           sizeof(real32_T) << 5U);

    /* Delay: '<S662>/Delay2' */
    memcpy(&Model_Target_B.VectorConcatenate1[0],
           &Model_Target_DW.Delay2_DSTATE[0], sizeof(real32_T) << 7U);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S674>/RTC Request Response Trigger' */

    /* Switch: '<S667>/Switch' */
    rtb_Max_h = (real32_T)
        (Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_muteReference == 0U);

    /* Product: '<S879>/MuteLPF' incorporates:
     *  Concatenate: '<S886>/Matrix Concatenate'
     *  Delay: '<S662>/Delay2'
     */
    for (xpageoffset = 0; xpageoffset < 128; xpageoffset++)
    {
        Model_Target_B.MatrixConcatenate_m[xpageoffset + 32] =
            Model_Target_B.VectorConcatenate1[xpageoffset] * rtb_Max_h;
    }

    /* End of Product: '<S879>/MuteLPF' */
    /* MATLAB Function: '<S953>/PoolIirProcess' incorporates:
     *  Concatenate: '<S886>/Matrix Concatenate'
     *  S-Function (TOP_MEX): '<S950>/TOP'
     *  S-Function (TOP_MEX): '<S950>/TOP1'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/PoolIirProcess': '<S954>:1' */
    /* '<S954>:1:5' [frame_size, num_channels] = size(x); */
    /*  Initialize variables */
    /*  Typecast the variables */
    /* '<S954>:1:11' frame_size = uint32(frame_size); */
    /* '<S954>:1:12' num_channels = uint32(num_channels); */
    /* Compute the filter coefficients */
    /* '<S954>:1:15' y = pooliir(x, frame_size, num_channels, numStages, coeffs, states); */
    /*  We have to use a different state buffer than the one passed in.  Matlab */
    /*  value objects are passed by value, not by reference, so the saving of */
    /*  states here does not work.  The state buffer is still necessary to pass */
    /*  allocate in the calling function and pass here in order to trigger CRL. */
    /*  This double buffering is annoying, however only happens during */
    /*  simulation, not code generation. */
    /*  num_states = (length(coeffs) - numChannels) / 2; */
    /*  persistent states; */
    /*  if isempty(states) */
    /*      states = single(zeros(1, num_states)); */
    /*  end */
    /* 'pooliir:15' stateIdx = 1; */
    Model_Target_B.vncBoostGain_j = 1.0;

    /* 'pooliir:16' coeffIdx = 1; */
    Model_Target_B.Switch1 = 1.0;

    /* 'pooliir:18' frameMinus1  = frameSize-1; */
    /*  number of samples minus one */
    /* 'pooliir:19' y     = coder.nullcopy(x); */
    /*  output matrix */
    /*  OUTER LOOP over all channels                  */
    /* 'pooliir:22' for cha = 1:numChannels */
    for (c = 0; c < 5; c++)
    {
        /*  FIRST STAGE */
        /*  prologue: get coefficients, states and input vector  */
        /*  and perform some computations */
        /* 'pooliir:28' w1 = states(stateIdx); */
        rtb_Delay3 = Model_Target_DW.states_h[(int32_T)
            Model_Target_B.vncBoostGain_j - 1];

        /* 'pooliir:28' stateIdx = stateIdx+1; */
        Model_Target_B.vncBoostGain_o = Model_Target_B.vncBoostGain_j + 1.0;

        /* S-Function (TOP_MEX): '<S950>/TOP1' */
        /* 'pooliir:29' gain = coeffs(coeffIdx); */
        rtb_max_j =
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
            [(int32_T)Model_Target_B.Switch1 - 1];

        /* 'pooliir:29' coeffIdx = coeffIdx+1; */
        /* 'pooliir:30' w2 = states(stateIdx); */
        w2 = Model_Target_DW.states_h[(int32_T)(Model_Target_B.vncBoostGain_j +
            1.0) - 1];

        /* 'pooliir:30' stateIdx = stateIdx-1; */
        Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0) -
            1.0;

        /* S-Function (TOP_MEX): '<S950>/TOP1' */
        /* 'pooliir:31' a2   = coeffs(coeffIdx); */
        a2 =
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
            [(int32_T)(Model_Target_B.Switch1 + 1.0) - 1];

        /* 'pooliir:31' coeffIdx = coeffIdx+1; */
        /* 'pooliir:32' xx  = x(1,cha); */
        /* 'pooliir:32' a1   = coeffs(coeffIdx); */
        /* 'pooliir:32' coeffIdx = coeffIdx+1; */
        /* 'pooliir:33' xx  = xx*gain; */
        xpageoffset = c << 5;
        xx = Model_Target_B.MatrixConcatenate_m[xpageoffset] * rtb_max_j;

        /* 'pooliir:33' b2   = coeffs(coeffIdx); */
        /* 'pooliir:33' coeffIdx = coeffIdx+1; */
        /* 'pooliir:34' yy  = w1+xx; */
        yy = rtb_Delay3 + xx;

        /* S-Function (TOP_MEX): '<S950>/TOP1' incorporates:
         *  Concatenate: '<S886>/Matrix Concatenate'
         */
        /* 'pooliir:34' b1   = coeffs(coeffIdx); */
        /* 'pooliir:34' coeffIdx = coeffIdx+1; */
        /* 'pooliir:35' w1  = b1*xx; */
        rtb_alpha =
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
            [(int32_T)((((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) + 1.0) - 1];
        rtb_Delay3 = rtb_alpha * xx;

        /*  main loop: 5 ops/sample */
        /* 'pooliir:38' i = 1; */
        /* 'pooliir:39' while i <= frameMinus1 */
        for (stateLen = 0; stateLen < 31; stateLen++)
        {
            /* 'pooliir:40' r  = a1*yy; */
            /* 'pooliir:40' w1 = w1+w2; */
            rtb_Delay3 += w2;

            /* 'pooliir:40' y(i,cha) = yy; */
            writeIndex = stateLen + xpageoffset;
            Model_Target_B.NonHr[writeIndex] = yy;

            /* 'pooliir:41' q  = b2*xx; */
            q = Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
                [(int32_T)(((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) - 1] *
                xx;

            /* 'pooliir:41' w1 = w1-r; */
            /* 'pooliir:41' xx = x(i+1,cha); */
            /* 'pooliir:42' xx = xx*gain; */
            xx = Model_Target_B.MatrixConcatenate_m[writeIndex + 1] * rtb_max_j;

            /* 'pooliir:43' w2 = a2*yy; */
            w2 = a2 * yy;

            /* 'pooliir:43' yy = w1+xx; */
            yy = (rtb_Delay3 -
                  Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
                  [(int32_T)((Model_Target_B.Switch1 + 1.0) + 1.0) - 1] * yy) +
                xx;

            /* 'pooliir:44' w1 = b1*xx; */
            rtb_Delay3 = rtb_alpha * xx;

            /* 'pooliir:44' w2 = q-w2; */
            w2 = q - w2;

            /* 'pooliir:44' i = i + 1; */
        }

        /*  epilogue: drain pipe and write states */
        /* 'pooliir:48' r  = a1*yy; */
        /* 'pooliir:48' w1 = w1+w2; */
        /* 'pooliir:48' y(frameMinus1+1,cha) = yy; */
        Model_Target_B.NonHr[xpageoffset + 31] = yy;

        /* 'pooliir:49' q  = b2*xx; */
        /* 'pooliir:49' w1 = w1-r; */
        Model_Target_DW.states_h[(int32_T)(Model_Target_B.vncBoostGain_o - 1.0)
            - 1] = (rtb_Delay3 + w2) -
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
            [(int32_T)((Model_Target_B.Switch1 + 1.0) + 1.0) - 1] * yy;

        /* 'pooliir:50' w2 = a2*yy; */
        /* 'pooliir:50' states(stateIdx) = w1; */
        /* 'pooliir:50' stateIdx = stateIdx+1; */
        /* 'pooliir:51' w2 = q-w2; */
        Model_Target_DW.states_h[(int32_T)(Model_Target_B.vncBoostGain_j + 1.0)
            - 1] =
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
            [(int32_T)(((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) - 1] * xx -
            a2 * yy;

        /* 'pooliir:51' states(stateIdx) = w2; */
        /* 'pooliir:51' stateIdx = stateIdx+1; */
        Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0) +
            1.0;

        /*  NOTE: asm implementation needs to exit here if it's only */
        /*  one stage, NOTE: all subsequent stages work in-place */
        /* 'pooliir:55' for st = 2:numStages(cha) */
        b = Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpassPooliirNumStages
            [c];
        for (st = 2U; st <= b; st++)
        {
            /*  prologue: get coefficients, states and input vector,  */
            /*  and perform some computations */
            /* 'pooliir:58' w1 = states(stateIdx); */
            rtb_Delay3 = Model_Target_DW.states_h[(int32_T)
                Model_Target_B.vncBoostGain_j - 1];

            /* 'pooliir:58' stateIdx = stateIdx+1; */
            Model_Target_B.vncBoostGain_o = Model_Target_B.vncBoostGain_j + 1.0;

            /* 'pooliir:59' a2 = coeffs(coeffIdx); */
            Model_Target_B.a2_tmp = (((((Model_Target_B.Switch1 + 1.0) + 1.0) +
                1.0) + 1.0) + 1.0) + ((real_T)st - 2.0) * 4.0;
            a2 =
                Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
                [(int32_T)Model_Target_B.a2_tmp - 1];

            /* 'pooliir:59' coeffIdx = coeffIdx+1; */
            /* 'pooliir:60' w2 = states(stateIdx); */
            w2 = Model_Target_DW.states_h[(int32_T)
                (Model_Target_B.vncBoostGain_j + 1.0) - 1];

            /* 'pooliir:60' stateIdx = stateIdx-1; */
            Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0)
                - 1.0;

            /* 'pooliir:61' a1 = coeffs(coeffIdx); */
            rtb_max_j =
                Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
                [(int32_T)(Model_Target_B.a2_tmp + 1.0) - 1];

            /* 'pooliir:61' coeffIdx = coeffIdx+1; */
            Model_Target_B.vncBoostGain = (((((((Model_Target_B.Switch1 + 1.0) +
                1.0) + 1.0) + 1.0) + 1.0) + ((real_T)st - 2.0) * 4.0) + 1.0) +
                1.0;

            /* 'pooliir:62' xx = y(1,cha); */
            xx = Model_Target_B.NonHr[xpageoffset];

            /* 'pooliir:62' b2 = coeffs(coeffIdx); */
            /* 'pooliir:62' coeffIdx = coeffIdx+1; */
            /* 'pooliir:63' yy = w1+xx; */
            yy = xx + rtb_Delay3;

            /* 'pooliir:63' b1 = coeffs(coeffIdx); */
            /* 'pooliir:63' coeffIdx = coeffIdx+1; */
            /* 'pooliir:64' w1 = b1*xx; */
            rtb_Delay3 =
                Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
                [(int32_T)(((Model_Target_B.a2_tmp + 1.0) + 1.0) + 1.0) - 1] *
                xx;

            /*  main loop: 4 ops/sample */
            /* 'pooliir:67' i = 1; */
            /* 'pooliir:68' while i <= frameMinus1 */
            for (stateLen = 0; stateLen < 31; stateLen++)
            {
                /* 'pooliir:69' r  = a1*yy; */
                /* 'pooliir:69' w1 = w1+w2; */
                rtb_Delay3 += w2;

                /* 'pooliir:69' y(i,cha) = yy; */
                yIdx = (c << 5) + stateLen;
                Model_Target_B.NonHr[yIdx] = yy;

                /* 'pooliir:70' q  = b2*xx; */
                q = Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
                    [(int32_T)((Model_Target_B.a2_tmp + 1.0) + 1.0) - 1] * xx;

                /* 'pooliir:70' w1 = w1-r ; */
                /* 'pooliir:70' xx = y(i+1,cha); */
                xx = Model_Target_B.NonHr[yIdx + 1];

                /* 'pooliir:71' w2 = a2*yy; */
                w2 = a2 * yy;

                /* 'pooliir:71' yy = w1+xx; */
                yy = (rtb_Delay3 - rtb_max_j * yy) + xx;

                /* 'pooliir:72' w1 = b1*xx; */
                rtb_Delay3 =
                    Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
                    [(int32_T)(Model_Target_B.vncBoostGain + 1.0) - 1] * xx;

                /* 'pooliir:72' w2 = q-w2; */
                w2 = q - w2;

                /* 'pooliir:72' i = i + 1; */
            }

            /*  epilogue: drain pipe and write states */
            /* 'pooliir:76' r  = a1*yy; */
            /* 'pooliir:76' w1 = w1+w2; */
            /* 'pooliir:76' y(frameMinus1+1,cha) = yy; */
            Model_Target_B.NonHr[xpageoffset + 31] = yy;

            /* 'pooliir:77' q  = b2*xx; */
            /* 'pooliir:77' w1 = w1-r; */
            Model_Target_DW.states_h[(int32_T)(Model_Target_B.vncBoostGain_o -
                1.0) - 1] = (rtb_Delay3 + w2) - rtb_max_j * yy;

            /* 'pooliir:78' w2 = a2*yy; */
            /* 'pooliir:78' states(stateIdx) = w1; */
            /* 'pooliir:78' stateIdx = stateIdx+1; */
            /* 'pooliir:79' w2 = q-w2; */
            Model_Target_DW.states_h[(int32_T)(Model_Target_B.vncBoostGain_j +
                1.0) - 1] =
                Model_Target_PreAmp0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
                [(int32_T)((Model_Target_B.a2_tmp + 1.0) + 1.0) - 1] * xx - a2 *
                yy;

            /* 'pooliir:79' states(stateIdx) = w2; */
            /* 'pooliir:79' stateIdx = stateIdx+1; */
            Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0)
                + 1.0;
        }

        Model_Target_B.Switch1 = (((((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0)
            + 1.0) + 1.0) + (((real_T)b - 2.0) + 1.0) * 4.0;
    }

    /* End of MATLAB Function: '<S953>/PoolIirProcess' */
    for (xpageoffset = 0; xpageoffset < 160; xpageoffset++)
    {
        /* Product: '<S886>/Product1' incorporates:
         *  DownSample: '<S886>/Downsample2'
         *  Reshape: '<S953>/Reshape'
         */
        Model_Target_B.Product1[xpageoffset] =
            Model_Target_B.Downsample2[xpageoffset] *
            Model_Target_B.NonHr[xpageoffset];
    }

    /* MATLAB Function: '<S946>/PoolIirProcess' incorporates:
     *  Product: '<S886>/Product1'
     *  S-Function (TOP_MEX): '<S943>/TOP'
     *  S-Function (TOP_MEX): '<S943>/TOP1'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/PoolIirProcess': '<S947>:1' */
    /* '<S947>:1:5' [frame_size, num_channels] = size(x); */
    /*  Initialize variables */
    /*  Typecast the variables */
    /* '<S947>:1:11' frame_size = uint32(frame_size); */
    /* '<S947>:1:12' num_channels = uint32(num_channels); */
    /* Compute the filter coefficients */
    /* '<S947>:1:15' y = pooliir(x, frame_size, num_channels, numStages, coeffs, states); */
    /*  We have to use a different state buffer than the one passed in.  Matlab */
    /*  value objects are passed by value, not by reference, so the saving of */
    /*  states here does not work.  The state buffer is still necessary to pass */
    /*  allocate in the calling function and pass here in order to trigger CRL. */
    /*  This double buffering is annoying, however only happens during */
    /*  simulation, not code generation. */
    /*  num_states = (length(coeffs) - numChannels) / 2; */
    /*  persistent states; */
    /*  if isempty(states) */
    /*      states = single(zeros(1, num_states)); */
    /*  end */
    /* 'pooliir:15' stateIdx = 1; */
    Model_Target_B.vncBoostGain_j = 1.0;

    /* 'pooliir:16' coeffIdx = 1; */
    Model_Target_B.Switch1 = 1.0;

    /* 'pooliir:18' frameMinus1  = frameSize-1; */
    /*  number of samples minus one */
    /* 'pooliir:19' y     = coder.nullcopy(x); */
    /*  output matrix */
    /*  OUTER LOOP over all channels                  */
    /* 'pooliir:22' for cha = 1:numChannels */
    for (c = 0; c < 5; c++)
    {
        /*  FIRST STAGE */
        /*  prologue: get coefficients, states and input vector  */
        /*  and perform some computations */
        /* 'pooliir:28' w1 = states(stateIdx); */
        rtb_Delay3 = Model_Target_DW.states_e[(int32_T)
            Model_Target_B.vncBoostGain_j - 1];

        /* 'pooliir:28' stateIdx = stateIdx+1; */
        Model_Target_B.vncBoostGain_o = Model_Target_B.vncBoostGain_j + 1.0;

        /* S-Function (TOP_MEX): '<S943>/TOP1' */
        /* 'pooliir:29' gain = coeffs(coeffIdx); */
        rtb_max_j =
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
            [(int32_T)Model_Target_B.Switch1 - 1];

        /* 'pooliir:29' coeffIdx = coeffIdx+1; */
        /* 'pooliir:30' w2 = states(stateIdx); */
        w2 = Model_Target_DW.states_e[(int32_T)(Model_Target_B.vncBoostGain_j +
            1.0) - 1];

        /* 'pooliir:30' stateIdx = stateIdx-1; */
        Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0) -
            1.0;

        /* 'pooliir:31' a2   = coeffs(coeffIdx); */
        a2 =
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
            [(int32_T)(Model_Target_B.Switch1 + 1.0) - 1];

        /* 'pooliir:31' coeffIdx = coeffIdx+1; */
        /* 'pooliir:32' xx  = x(1,cha); */
        /* 'pooliir:32' a1   = coeffs(coeffIdx); */
        /* 'pooliir:32' coeffIdx = coeffIdx+1; */
        /* 'pooliir:33' xx  = xx*gain; */
        xpageoffset = c << 5;
        xx = Model_Target_B.Product1[xpageoffset] * rtb_max_j;

        /* 'pooliir:33' b2   = coeffs(coeffIdx); */
        /* 'pooliir:33' coeffIdx = coeffIdx+1; */
        /* 'pooliir:34' yy  = w1+xx; */
        yy = rtb_Delay3 + xx;

        /* S-Function (TOP_MEX): '<S943>/TOP1' incorporates:
         *  Product: '<S886>/Product1'
         */
        /* 'pooliir:34' b1   = coeffs(coeffIdx); */
        /* 'pooliir:34' coeffIdx = coeffIdx+1; */
        /* 'pooliir:35' w1  = b1*xx; */
        rtb_alpha =
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
            [(int32_T)((((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) + 1.0) - 1];
        rtb_Delay3 = rtb_alpha * xx;

        /*  main loop: 5 ops/sample */
        /* 'pooliir:38' i = 1; */
        /* 'pooliir:39' while i <= frameMinus1 */
        for (stateLen = 0; stateLen < 31; stateLen++)
        {
            /* 'pooliir:40' r  = a1*yy; */
            /* 'pooliir:40' w1 = w1+w2; */
            rtb_Delay3 += w2;

            /* 'pooliir:40' y(i,cha) = yy; */
            Model_Target_B.NonHr[stateLen + xpageoffset] = yy;

            /* 'pooliir:41' q  = b2*xx; */
            q = Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
                [(int32_T)(((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) - 1] *
                xx;

            /* 'pooliir:41' w1 = w1-r; */
            /* 'pooliir:41' xx = x(i+1,cha); */
            /* 'pooliir:42' xx = xx*gain; */
            xx = Model_Target_B.Product1[(xpageoffset + stateLen) + 1] *
                rtb_max_j;

            /* 'pooliir:43' w2 = a2*yy; */
            w2 = a2 * yy;

            /* 'pooliir:43' yy = w1+xx; */
            yy = (rtb_Delay3 -
                  Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
                  [(int32_T)((Model_Target_B.Switch1 + 1.0) + 1.0) - 1] * yy) +
                xx;

            /* 'pooliir:44' w1 = b1*xx; */
            rtb_Delay3 = rtb_alpha * xx;

            /* 'pooliir:44' w2 = q-w2; */
            w2 = q - w2;

            /* 'pooliir:44' i = i + 1; */
        }

        /*  epilogue: drain pipe and write states */
        /* 'pooliir:48' r  = a1*yy; */
        /* 'pooliir:48' w1 = w1+w2; */
        /* 'pooliir:48' y(frameMinus1+1,cha) = yy; */
        writeIndex = (c << 5) + 31;
        Model_Target_B.NonHr[writeIndex] = yy;

        /* 'pooliir:49' q  = b2*xx; */
        /* 'pooliir:49' w1 = w1-r; */
        Model_Target_DW.states_e[(int32_T)(Model_Target_B.vncBoostGain_o - 1.0)
            - 1] = (rtb_Delay3 + w2) -
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
            [(int32_T)((Model_Target_B.Switch1 + 1.0) + 1.0) - 1] * yy;

        /* 'pooliir:50' w2 = a2*yy; */
        /* 'pooliir:50' states(stateIdx) = w1; */
        /* 'pooliir:50' stateIdx = stateIdx+1; */
        /* 'pooliir:51' w2 = q-w2; */
        Model_Target_DW.states_e[(int32_T)(Model_Target_B.vncBoostGain_j + 1.0)
            - 1] =
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
            [(int32_T)(((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) - 1] * xx -
            Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
            [(int32_T)(Model_Target_B.Switch1 + 1.0) - 1] * yy;

        /* 'pooliir:51' states(stateIdx) = w2; */
        /* 'pooliir:51' stateIdx = stateIdx+1; */
        Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0) +
            1.0;

        /*  NOTE: asm implementation needs to exit here if it's only */
        /*  one stage, NOTE: all subsequent stages work in-place */
        /* 'pooliir:55' for st = 2:numStages(cha) */
        b = Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliasPooliirNumStages
            [c];
        for (st = 2U; st <= b; st++)
        {
            /*  prologue: get coefficients, states and input vector,  */
            /*  and perform some computations */
            /* 'pooliir:58' w1 = states(stateIdx); */
            rtb_Delay3 = Model_Target_DW.states_e[(int32_T)
                Model_Target_B.vncBoostGain_j - 1];

            /* 'pooliir:58' stateIdx = stateIdx+1; */
            Model_Target_B.vncBoostGain_o = Model_Target_B.vncBoostGain_j + 1.0;

            /* 'pooliir:59' a2 = coeffs(coeffIdx); */
            Model_Target_B.vncBoostGain = (((((Model_Target_B.Switch1 + 1.0) +
                1.0) + 1.0) + 1.0) + 1.0) + ((real_T)st - 2.0) * 4.0;
            a2 =
                Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
                [(int32_T)Model_Target_B.vncBoostGain - 1];

            /* 'pooliir:59' coeffIdx = coeffIdx+1; */
            /* 'pooliir:60' w2 = states(stateIdx); */
            w2 = Model_Target_DW.states_e[(int32_T)
                (Model_Target_B.vncBoostGain_j + 1.0) - 1];

            /* 'pooliir:60' stateIdx = stateIdx-1; */
            Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0)
                - 1.0;

            /* 'pooliir:61' a1 = coeffs(coeffIdx); */
            rtb_max_j =
                Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
                [(int32_T)(Model_Target_B.vncBoostGain + 1.0) - 1];

            /* 'pooliir:61' coeffIdx = coeffIdx+1; */
            /* 'pooliir:62' xx = y(1,cha); */
            xx = Model_Target_B.NonHr[xpageoffset];

            /* 'pooliir:62' b2 = coeffs(coeffIdx); */
            /* 'pooliir:62' coeffIdx = coeffIdx+1; */
            /* 'pooliir:63' yy = w1+xx; */
            yy = xx + rtb_Delay3;

            /* 'pooliir:63' b1 = coeffs(coeffIdx); */
            /* 'pooliir:63' coeffIdx = coeffIdx+1; */
            /* 'pooliir:64' w1 = b1*xx; */
            rtb_alpha =
                Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
                [(int32_T)(((Model_Target_B.vncBoostGain + 1.0) + 1.0) + 1.0) -
                1];
            rtb_Delay3 = rtb_alpha * xx;

            /*  main loop: 4 ops/sample */
            /* 'pooliir:67' i = 1; */
            /* 'pooliir:68' while i <= frameMinus1 */
            for (stateLen = 0; stateLen < 31; stateLen++)
            {
                /* 'pooliir:69' r  = a1*yy; */
                /* 'pooliir:69' w1 = w1+w2; */
                rtb_Delay3 += w2;

                /* 'pooliir:69' y(i,cha) = yy; */
                Model_Target_B.NonHr[stateLen + (c << 5)] = yy;

                /* 'pooliir:70' q  = b2*xx; */
                q = Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
                    [(int32_T)((Model_Target_B.vncBoostGain + 1.0) + 1.0) - 1] *
                    xx;

                /* 'pooliir:70' w1 = w1-r ; */
                /* 'pooliir:70' xx = y(i+1,cha); */
                xx = Model_Target_B.NonHr[((c << 5) + stateLen) + 1];

                /* 'pooliir:71' w2 = a2*yy; */
                w2 = a2 * yy;

                /* 'pooliir:71' yy = w1+xx; */
                yy = (rtb_Delay3 - rtb_max_j * yy) + xx;

                /* 'pooliir:72' w1 = b1*xx; */
                rtb_Delay3 = xx * rtb_alpha;

                /* 'pooliir:72' w2 = q-w2; */
                w2 = q - w2;

                /* 'pooliir:72' i = i + 1; */
            }

            /*  epilogue: drain pipe and write states */
            /* 'pooliir:76' r  = a1*yy; */
            /* 'pooliir:76' w1 = w1+w2; */
            /* 'pooliir:76' y(frameMinus1+1,cha) = yy; */
            Model_Target_B.NonHr[writeIndex] = yy;

            /* 'pooliir:77' q  = b2*xx; */
            /* 'pooliir:77' w1 = w1-r; */
            Model_Target_DW.states_e[(int32_T)(Model_Target_B.vncBoostGain_o -
                1.0) - 1] = (rtb_Delay3 + w2) - rtb_max_j * yy;

            /* 'pooliir:78' w2 = a2*yy; */
            /* 'pooliir:78' states(stateIdx) = w1; */
            /* 'pooliir:78' stateIdx = stateIdx+1; */
            /* 'pooliir:79' w2 = q-w2; */
            Model_Target_DW.states_e[(int32_T)(Model_Target_B.vncBoostGain_j +
                1.0) - 1] =
                Model_Target_PreAmp0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
                [(int32_T)((Model_Target_B.vncBoostGain + 1.0) + 1.0) - 1] * xx
                - a2 * yy;

            /* 'pooliir:79' states(stateIdx) = w2; */
            /* 'pooliir:79' stateIdx = stateIdx+1; */
            Model_Target_B.vncBoostGain_j = (Model_Target_B.vncBoostGain_j + 1.0)
                + 1.0;
        }

        Model_Target_B.Switch1 = (((((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0)
            + 1.0) + 1.0) + (((real_T)b - 2.0) + 1.0) * 4.0;
    }

    /* End of MATLAB Function: '<S946>/PoolIirProcess' */

    /* DownSample: '<S886>/Downsample2' incorporates:
     *  Reshape: '<S946>/Reshape'
     */
    for (stateLen = 0; stateLen < 10; stateLen++)
    {
        Model_Target_B.Downsample2[stateLen] = Model_Target_B.NonHr[stateLen <<
            4];
    }

    /* End of DownSample: '<S886>/Downsample2' */

    /* Selector: '<S886>/Selector1' */
    for (yIdx = 0; yIdx < 4; yIdx++)
    {
        c = (yIdx + 1) << 1;
        xpageoffset = yIdx << 1;
        Model_Target_B.VectorConcatenate2_o[xpageoffset] =
            Model_Target_B.Downsample2[c];
        Model_Target_B.VectorConcatenate2_o[xpageoffset + 1] =
            Model_Target_B.Downsample2[c + 1];
    }

    /* End of Selector: '<S886>/Selector1' */
    /* MATLAB Function: '<S958>/delay' incorporates:
     *  Selector: '<S886>/Selector1'
     */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'Delay/delay': '<S959>:1' */
    /*  figure out the frame size and channel count */
    /* '<S959>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S959>:1:8' frameSize = int32(frameSize); */
    /* '<S959>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S959>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S959>:1:11' delayTime = int32(delayTime); */
    /* '<S959>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S959>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S959>:1:23' bufferIndex = delayIndex; */
    xpageoffset = Model_Target_DW.delayIndex_o;

    /* '<S959>:1:25' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 4; yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S959>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(xpageoffset, 0, 1032);

        /* '<S959>:1:32' for sample = 1:frameSize */
        /*  overwrite oldest sample with the current input sample */
        /* '<S959>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
        c = yIdx << 1;
        Model_Target_DW.delayBuffer[writeIndex] =
            Model_Target_B.VectorConcatenate2_o[c];

        /*  increment write pointer */
        /* '<S959>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
        /*  overwrite oldest sample with the current input sample */
        /* '<S959>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
        Model_Target_DW.delayBuffer[circindex(writeIndex, 1, 1032)] =
            Model_Target_B.VectorConcatenate2_o[c + 1];

        /*  increment write pointer */
        /* '<S959>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
        /*  Advance buffer index for next channel */
        /* '<S959>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 258, 1032);
    }

    /*  Reset */
    /* '<S959>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    xpageoffset = circindex(Model_Target_DW.delayIndex_o, 2, 1032);

    /* '<S959>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_o = xpageoffset;

    /*  Read samples from delay line */
    /* '<S959>:1:50' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 4; yIdx++)
    {
        /*  Setup read pointer */
        /* '<S959>:1:53' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
        writeIndex = circindex(xpageoffset,
                               -(Model_Target_PreAmp0.AudiopilotHfNoiseRefLatencySamples
                                + 2), 1032);

        /* '<S959>:1:55' for sample = 1:frameSize */
        /*  overwrite oldest sample with the current input sample */
        /* '<S959>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
        c = yIdx << 1;
        Model_Target_B.MatrixConcatenate_j[c] =
            Model_Target_DW.delayBuffer[writeIndex];

        /*  increment write pointer */
        /* '<S959>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
        /*  overwrite oldest sample with the current input sample */
        /* '<S959>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
        Model_Target_B.MatrixConcatenate_j[c + 1] =
            Model_Target_DW.delayBuffer[circindex(writeIndex, 1, 1032)];

        /*  increment write pointer */
        /* '<S959>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
        /*  Advance buffer index for next channel */
        /* '<S959>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 258, 1032);
    }

    /* End of MATLAB Function: '<S958>/delay' */

    /* Selector: '<S886>/Selector' incorporates:
     *  Concatenate: '<S900>/Matrix Concatenate'
     */
    Model_Target_B.MatrixConcatenate_j[8] = Model_Target_B.Downsample2[0];
    Model_Target_B.MatrixConcatenate_j[9] = Model_Target_B.Downsample2[1];

    /* Buffer: '<S901>/Buffer' incorporates:
     *  Concatenate: '<S900>/Matrix Concatenate'
     */
    xpageoffset = 0;
    for (c = 0; c < 6; c++)
    {
        writeIndex = 2;
        sample = c << 9;
        yIdx = sample + Model_Target_DW.Buffer_inBufPtrIdx_e;
        if (Model_Target_DW.Buffer_inBufPtrIdx_e > 510)
        {
            for (stateLen = 0; stateLen < 512 -
                    Model_Target_DW.Buffer_inBufPtrIdx_e; stateLen++)
            {
                Model_Target_DW.Buffer_CircBuf_c[yIdx + stateLen] =
                    Model_Target_B.MatrixConcatenate_j[xpageoffset + stateLen];
            }

            xpageoffset = (xpageoffset - Model_Target_DW.Buffer_inBufPtrIdx_e) +
                512;
            yIdx = sample;
            writeIndex = Model_Target_DW.Buffer_inBufPtrIdx_e - 510;
        }

        for (stateLen = 0; stateLen < writeIndex; stateLen++)
        {
            Model_Target_DW.Buffer_CircBuf_c[yIdx + stateLen] =
                Model_Target_B.MatrixConcatenate_j[xpageoffset + stateLen];
        }

        xpageoffset += writeIndex;
    }

    Model_Target_DW.Buffer_inBufPtrIdx_e += 2;
    if (Model_Target_DW.Buffer_inBufPtrIdx_e >= 512)
    {
        Model_Target_DW.Buffer_inBufPtrIdx_e -= 512;
    }

    /* End of Buffer: '<S901>/Buffer' */
    /* MATLAB Function: '<S1007>/PoolIirProcess' */
    Model_Target_PoolIirProcess_n(Model_Target_B.SFunction,
        Model_Target_PreAmp0.AudiopilotLfNoiseMicPooliirNumStages,
        &(Model_Target_PreAmp0.AudiopilotLfNoiseMicpooliirCoeffs[0]),
        Model_Target_DW.states_f, &Model_Target_B.sf_PoolIirProcess_n);

    /* Buffer: '<S965>/BufferMic' incorporates:
     *  Reshape: '<S1007>/Reshape'
     */
    for (stateLen = 0; stateLen < 32; stateLen++)
    {
        Model_Target_DW.BufferMic_CircBuf[Model_Target_DW.BufferMic_inBufPtrIdx
            + stateLen] = Model_Target_B.sf_PoolIirProcess_n.y[stateLen];
    }

    Model_Target_DW.BufferMic_inBufPtrIdx += 32;
    if (Model_Target_DW.BufferMic_inBufPtrIdx >= 128)
    {
        Model_Target_DW.BufferMic_inBufPtrIdx -= 128;
    }

    /* End of Buffer: '<S965>/BufferMic' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        /* Product: '<S879>/MuteLF' incorporates:
         *  Delay: '<S662>/Delay1'
         */
        Model_Target_B.MuteLF[xpageoffset] = rtb_Max_h *
            Model_Target_DW.Delay1_DSTATE_lo[xpageoffset];
    }

    /* MATLAB Function: '<S1014>/PoolIirProcess' */
    Model_Target_PoolIirProcess_n(Model_Target_B.MuteLF,
        Model_Target_PreAmp0.AudiopilotLfNoiseRefPooliirNumStages,
        &(Model_Target_PreAmp0.AudiopilotLfNoiseRefpooliirCoeffs[0]),
        Model_Target_DW.states_o, &Model_Target_B.sf_PoolIirProcess_e);

    /* Buffer: '<S965>/BufferRef' incorporates:
     *  Reshape: '<S1014>/Reshape'
     */
    for (stateLen = 0; stateLen < 32; stateLen++)
    {
        Model_Target_DW.BufferRef_CircBuf[Model_Target_DW.BufferRef_inBufPtrIdx
            + stateLen] = Model_Target_B.sf_PoolIirProcess_e.y[stateLen];
    }

    Model_Target_DW.BufferRef_inBufPtrIdx += 32;
    if (Model_Target_DW.BufferRef_inBufPtrIdx >= 128)
    {
        Model_Target_DW.BufferRef_inBufPtrIdx -= 128;
    }

    /* End of Buffer: '<S965>/BufferRef' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S675>/RTC Request Response Trigger' */

    /* RateTransition: '<S881>/Rate Transition3' */
    if (Model_Target_DW.RateTransition3_semaphoreTaken == 0)
    {
        Model_Target_DW.RateTransition3_Buffer0 =
            Model_TargetPreAmpAudiopilotsetSpeedInRtcOut.REQ_speedIn;
    }

    /* End of RateTransition: '<S881>/Rate Transition3' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S678>/RTC Request Response Trigger' */

    /* RateTransition: '<S881>/Rate Transition6' */
    if (Model_Target_DW.RateTransition6_semaphoreTaken == 0)
    {
        Model_Target_DW.RateTransition6_Buffer0 = Model_Target_B.hvacDbspl;
    }

    /* End of RateTransition: '<S881>/Rate Transition6' */
    /* RateTransition: '<S882>/Rate Transition' */
    if (Model_Target_M->Timing.RateInteraction.TID2_6)
    {
        Model_Target_DW.RateTransition_Buffer =
            Model_Target_PreAmp0.AudiopilotRatioLowBoundDb;

        /* RateTransition: '<S882>/Rate Transition1' */
        Model_Target_DW.RateTransition1_Buffer =
            Model_Target_PreAmp0.AudiopilotRatioHighBoundDb;
    }

    /* End of RateTransition: '<S882>/Rate Transition' */
    /* RateTransition: '<S879>/Speed Rate Transition' */
    if (Model_Target_DW.SpeedRateTransition_semaphoreTaken == 0)
    {
        Model_Target_DW.SpeedRateTransition_Buffer0 =
            Model_TargetPreAmpAudiopilotsetSpeedInRtcOut.REQ_speedIn;
    }

    /* End of RateTransition: '<S879>/Speed Rate Transition' */
    /* End of Outputs for S-Function (RTC_NTF): '<S674>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S675>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S678>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S772>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S775>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S1110>/PoolIirProcess' */
    Model_Target_PoolIirProcess(Model_Target_PreAmpPart1_B.sf_tone_k.audioOut,
        &(Model_Target_PreAmp0.LevelDetectPreemphasisPooliirNumStages[0]),
        &(Model_Target_PreAmp0.LevelDetectPreemphasispooliirCoeffs[0]),
        Model_Target_DW.states_n, &Model_Target_B.sf_PoolIirProcess_ep);

    /* MATLAB Function: '<S1073>/PreProcess' incorporates:
     *  Reshape: '<S1110>/Reshape'
     */
    /*  Pre-process by calculating the root mean square (rms) of the samples in the */
    /*  output frame or the maximum (peak) of the frame */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/EntertainmentLevelDetection/PreProcessing/PreProcess': '<S1104>:1' */
    /*  Calculate RMS first */
    /* '<S1104>:1:7' curr = 10 * log10(max(mean(Signal .* Signal, 1)) + eps); */
    for (xpageoffset = 0; xpageoffset < 64; xpageoffset++)
    {
        Model_Target_B.Selector2_e[xpageoffset] =
            Model_Target_B.sf_PoolIirProcess_ep.y[xpageoffset] *
            Model_Target_B.sf_PoolIirProcess_ep.y[xpageoffset];
    }

    for (stateLen = 0; stateLen < 2; stateLen++)
    {
        xpageoffset = stateLen << 5;
        Model_Target_B.MatrixConcatenate_j2[stateLen] =
            Model_Target_B.Selector2_e[xpageoffset];
        for (c = 0; c < 31; c++)
        {
            Model_Target_B.MatrixConcatenate_j2[stateLen] +=
                Model_Target_B.Selector2_e[(xpageoffset + c) + 1];
        }

        Model_Target_B.MatrixConcatenate_j2[stateLen] = qhmath_div_f
            (Model_Target_B.MatrixConcatenate_j2[stateLen], 32.0F);
    }

    if (Model_Target_B.MatrixConcatenate_j2[0] <
            Model_Target_B.MatrixConcatenate_j2[1])
    {
        rtb_alpha = Model_Target_B.MatrixConcatenate_j2[1];
    }
    else
    {
        rtb_alpha = Model_Target_B.MatrixConcatenate_j2[0];
    }

    rtb_Delay3 = qhmath_log10_f(rtb_alpha + 2.22044605E-16F) * 10.0F;

    /* '<S1104>:1:8' RmsOutput = max(curr); */
    /* '<S1104>:1:10' if (PeakEnable) */
    if (Model_Target_ConstB.Compare)
    {
        /*  Calculate peak of frame if necessary */
        /* '<S1104>:1:12' curr = 20 * log10(max(max(abs(Signal))) + eps); */
        for (stateLen = 0; stateLen < 64; stateLen++)
        {
            Model_Target_B.Selector2_e[stateLen] = qhmath_abs_f
                (Model_Target_B.sf_PoolIirProcess_ep.y[stateLen]);
        }

        for (xpageoffset = 0; xpageoffset < 2; xpageoffset++)
        {
            c = xpageoffset << 5;
            Model_Target_B.MatrixConcatenate_j2[xpageoffset] =
                Model_Target_B.Selector2_e[c];
            for (stateLen = 0; stateLen < 31; stateLen++)
            {
                w2 = Model_Target_B.MatrixConcatenate_j2[xpageoffset];
                rtb_alpha = Model_Target_B.Selector2_e[(c + stateLen) + 1];
                if (w2 < rtb_alpha)
                {
                    w2 = rtb_alpha;
                }

                Model_Target_B.MatrixConcatenate_j2[xpageoffset] = w2;
            }
        }

        if (Model_Target_B.MatrixConcatenate_j2[0] <
                Model_Target_B.MatrixConcatenate_j2[1])
        {
            rtb_alpha = Model_Target_B.MatrixConcatenate_j2[1];
        }
        else
        {
            rtb_alpha = Model_Target_B.MatrixConcatenate_j2[0];
        }

        rtb_max_j = qhmath_log10_f(rtb_alpha + 2.22044605E-16F) * 20.0F;

        /* '<S1104>:1:13' PeakOutput = max(curr); */
    }
    else
    {
        /* '<S1104>:1:14' else */
        /*  If not, just set outpout to same as RMS */
        /* '<S1104>:1:16' PeakOutput = RmsOutput; */
        rtb_max_j = rtb_Delay3;
    }

    /* MATLAB Function: '<S1100>/delay' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'Delay/delay': '<S1101>:1' */
    /*  figure out the frame size and channel count */
    /* '<S1101>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S1101>:1:8' frameSize = int32(frameSize); */
    /* '<S1101>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S1101>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S1101>:1:11' delayTime = int32(delayTime); */
    /* '<S1101>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1101>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1101>:1:23' bufferIndex = delayIndex; */
    xpageoffset = Model_Target_DW.delayIndex;

    /* '<S1101>:1:25' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 2; yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S1101>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(xpageoffset, 0, 576);

        /* '<S1101>:1:32' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1101>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_h[writeIndex] =
                Model_Target_PreAmpPart1_B.sf_tone_k.audioOut[(yIdx << 5) +
                sample];

            /*  increment write pointer */
            /* '<S1101>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 576);
        }

        /*  Advance buffer index for next channel */
        /* '<S1101>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 288, 576);
    }

    /*  Reset */
    /* '<S1101>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    xpageoffset = circindex(Model_Target_DW.delayIndex, 32, 576);

    /* '<S1101>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex = xpageoffset;

    /*  Read samples from delay line */
    /* '<S1101>:1:50' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 2; yIdx++)
    {
        /*  Setup read pointer */
        /* '<S1101>:1:53' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
        writeIndex = circindex(xpageoffset,
                               -(Model_Target_PreAmp0.LevelDetectMusicDelaySamples
                                + 32), 576);

        /* '<S1101>:1:55' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1101>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.audioOut_d[sample + (yIdx << 5)] =
                Model_Target_DW.delayBuffer_h[writeIndex];

            /*  increment write pointer */
            /* '<S1101>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 576);
        }

        /*  Advance buffer index for next channel */
        /* '<S1101>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 288, 576);
    }

    /* End of MATLAB Function: '<S1100>/delay' */
    /* MATLAB Function: '<S1128>/rgainy process' */
    Model_Target_rgainyprocess_k(Model_Target_ConstB.AudioStatsFunc,
        Model_Target_B.audioOut_d, &Model_Target_B.sf_rgainyprocess_k);

    /* MATLAB Function: '<S666>/select one channel gain' */
    /*  Rgainy outputs gains of all channels. In the entertainment path, we only */
    /*  have one ramper meaning that the same gain gets applied to all channels. */
    /*  The following code extracts the gain of just the first channel as output. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Volume/select one channel gain': '<S1119>:1' */
    /* '<S1119>:1:5' gainSingleChannel = squeeze(gainIn(:,1,:)); */
    Model_Target_B.gainSingleChannel =
        Model_Target_B.sf_rgainyprocess_k.gainOut[0];

    /* MATLAB Function: '<S665>/Linear2Db' */
    /*  Convert linear volume to dB */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/EntertainmentLevelDetection/Linear2Db': '<S1071>:1' */
    /* '<S1071>:1:4' VoldDb = single(20 * log10(Volume + eps)); */
    rtb_Max_h = qhmath_log10_f(Model_Target_B.gainSingleChannel +
        2.22044605E-16F) * 20.0F;

    /* MATLAB Function: '<S1092>/InnerLink' incorporates:
     *  Constant: '<S661>/Constant'
     *  Constant: '<S665>/DyneqMode'
     *  MATLAB Function: '<S1073>/PreProcess'
     */
    Model_Target_InnerLink_p(rtb_Delay3, rtb_max_j,
        Model_Target_PreAmp0.LevelDetectSysMaxDbspl,
        Model_Target_PreAmp0.DyneqLevelDetectSlowDecayDbPerSample,
        Model_Target_PreAmp0.DyneqLevelDetectHoldMarginDb,
        Model_Target_PreAmp0.DyneqLevelDetectHoldTimeSamples,
        Model_Target_PreAmp0.DyneqLevelDetectFastDecayDbPerSample,
        Model_Target_PreAmp0.DyneqLevelDetectMinVolumeDb,
        Model_Target_PreAmp0.DyneqLevelDetectMaxVolumeDb, rtb_Max_h, 0.0, 0.0F,
        &Model_Target_B.sf_InnerLink_a, &Model_Target_DW.sf_InnerLink_a);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S801>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S1079>/InnerLink' incorporates:
     *  Constant: '<S661>/Constant'
     *  Constant: '<S665>/AudiopilotMode'
     *  MATLAB Function: '<S1073>/PreProcess'
     */
    Model_Target_InnerLink_p(rtb_Delay3, rtb_max_j,
        Model_Target_PreAmp0.LevelDetectSysMaxDbspl,
        Model_Target_PreAmp0.AudiopilotLevelDetectSlowDecayDbPerSample,
        Model_Target_PreAmp0.AudiopilotLevelDetectHoldMarginDb,
        Model_Target_PreAmp0.AudiopilotLevelDetectHoldTimeSamples,
        Model_Target_PreAmp0.AudiopilotLevelDetectFastDecayDbPerSample,
        Model_Target_PreAmp0.AudiopilotLevelDetectMinVolumeDb,
        Model_Target_PreAmp0.AudiopilotLevelDetectMaxVolumeDb, rtb_Max_h, 0.0,
        0.0F, &Model_Target_B.sf_InnerLink_p, &Model_Target_DW.sf_InnerLink_p);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S803>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S763>/InputOverRide' */
    /*  This implements the overrides of the levels of the input signal */
    /*  If the flag is held high (value = 1), the input levels take on the  */
    /*  provided values. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/Boosts/InputOverride/InputOverRide': '<S800>:1' */
    /*  DynEq Signal Level */
    /* '<S800>:1:10' if (DynEqSignalOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetLoudSignalOverRideRtcOut.REQ_LoudSignalOverRideFlag
        != 0U)
    {
        /* '<S800>:1:11' DynEqSignalOut = DynEqSignalOverRide; */
        w2 =
            Model_TargetPreAmpAudiopilotsetLoudSignalOverRideRtcOut.REQ_LoudSignalOverRide;
    }
    else
    {
        /* '<S800>:1:12' else */
        /* '<S800>:1:13' DynEqSignalOut = DynEqSignalIn; */
        w2 = Model_Target_B.sf_InnerLink_a.level;
    }

    /*  AudioPilot Signal Level */
    /* '<S800>:1:17' if (AudioPilotSignalOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetVNCSignalOverRideRtcOut.REQ_VNCSignalOverRideFlag
        != 0U)
    {
        /* '<S800>:1:18' AudioPilotSignalOut = AudioPilotSignalOverRide; */
        rtb_max_j =
            Model_TargetPreAmpAudiopilotsetVNCSignalOverRideRtcOut.REQ_VNCSignalOverRide;
    }
    else
    {
        /* '<S800>:1:19' else */
        /* '<S800>:1:20' AudioPilotSignalOut = max(AudioPilotSignalIn, AudioPilotMinSignal); */
        rtb_max_j = fmaxf(Model_Target_B.sf_InnerLink_p.level,
                          Model_Target_PreAmp0.AudiopilotMinSignalLevelDbspl);
    }

    /* End of MATLAB Function: '<S763>/InputOverRide' */

    /* RateTransition: '<S664>/Rate Transition1' */
    rtb_Max_h =
        Model_Target_DW.RateTransition1_Buffer_k[Model_Target_DW.RateTransition1_ActiveBufIdx];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S823>/RTC Request Response Trigger' */

    /* RateTransition: '<S664>/Rate Transition11' */
    a2 =
        Model_Target_DW.RateTransition11_Buffer[Model_Target_DW.RateTransition11_ActiveBufIdx];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S826>/RTC Request Response Trigger' */

    /* RateTransition: '<S664>/Rate Transition6' */
    xx =
        Model_Target_DW.RateTransition6_Buffer[Model_Target_DW.RateTransition6_ActiveBufIdx];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S822>/RTC Request Response Trigger' */

    /* RateTransition: '<S664>/Rate Transition2' */
    yy =
        Model_Target_DW.RateTransition2_Buffer[Model_Target_DW.RateTransition2_ActiveBufIdx];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S825>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S738>/NoiseOverRide' */
    Model_Target_B.LFNoise = rtb_Max_h;
    Model_Target_B.WBNoise = a2;
    Model_Target_B.HFNoise = xx;
    Model_Target_B.Ratio = yy;

    /*  This function executes the overrides. */
    /*  For each parameter or state, if the flag is enabled (set to 1) */
    /*  then the variable will take on the value provided. */
    /*  Otherwise, this is a pass through. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/InputOverRide/NoiseOverRide': '<S824>:1' */
    /*  Pass through */
    /* '<S824>:1:12' LFNoise = LFNoiseIn; */
    /* '<S824>:1:13' WBNoise = WBNoiseIn; */
    /* '<S824>:1:14' HFNoise = HFNoiseIn; */
    /* '<S824>:1:15' Ratio = RatioIn; */
    /*  Low frequency noise override */
    /* '<S824>:1:18' if (LFNoiseOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetLFNoiseOverRideRtcOut.REQ_LFNoiseOverRideFlag
        != 0U)
    {
        /* '<S824>:1:19' LFNoise = LFNoiseOverRide; */
        Model_Target_B.LFNoise =
            Model_TargetPreAmpAudiopilotsetLFNoiseOverRideRtcOut.REQ_LFNoiseOverRide;
    }

    /*  Wide band noise override */
    /* '<S824>:1:23' if (WBNoiseOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetWBNoiseOverRideRtcOut.REQ_WBNoiseOverRideFlag
        != 0U)
    {
        /* '<S824>:1:24' WBNoise = WBNoiseOverRide; */
        Model_Target_B.WBNoise =
            Model_TargetPreAmpAudiopilotsetWBNoiseOverRideRtcOut.REQ_WBNoiseOverRide;
    }

    /*  High frequency noise override */
    /* '<S824>:1:28' if (HFNoiseOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetHFNoiseOverRideRtcOut.REQ_HFNoiseOverRideFlag
        != 0U)
    {
        /* '<S824>:1:29' HFNoise = HFNoiseOverRide; */
        Model_Target_B.HFNoise =
            Model_TargetPreAmpAudiopilotsetHFNoiseOverRideRtcOut.REQ_HFNoiseOverRide;
    }

    /*  Noise ratio override */
    /* '<S824>:1:33' if (RatioOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetRatioOverRideRtcOut.REQ_RatioOverRideFlag
        != 0U)
    {
        /* '<S824>:1:34' Ratio = RatioOverRide; */
        Model_Target_B.Ratio =
            Model_TargetPreAmpAudiopilotsetRatioOverRideRtcOut.REQ_RatioOverRide;
    }

    /* End of MATLAB Function: '<S738>/NoiseOverRide' */
    /* MATLAB Function: '<S735>/AlphaCalculation' incorporates:
     *  Switch: '<S735>/Switch1'
     *  Switch: '<S735>/Switch2'
     */
    /*  This calculates the alpha modifier for boost map adjustment. */
    /*  For each noise estimate, a value is calculated denoting the estimate's  */
    /*  position within a specified range.  The modifier is the product of */
    /*  the values from the two noise estimates. */
    /*  The modifier is a value between 0 and 1.   */
    /*  A value of 0 means no boost map adjustment. */
    /*  A value of 1 will allow the full boost map adjustment based on the ratio. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/BoostMapAdjustment/AlphaCalculation': '<S741>:1' */
    /*  alpha:  HF Noise */
    /* '<S741>:1:15' if HFNoise < HFNoiseLow */
    if (Model_Target_B.HFNoise <
            Model_Target_PreAmp0.AudiopilotHfNoiseLowBoundDbspl)
    {
        /* '<S741>:1:16' alpha = single(0); */
        rtb_alpha = 0.0F;
    }
    else if (Model_Target_B.HFNoise >
             Model_Target_PreAmp0.AudiopilotHfNoiseHighBoundDbspl)
    {
        /* '<S741>:1:17' elseif HFNoise > HFNoiseHigh */
        /* '<S741>:1:18' alpha = single(1); */
        rtb_alpha = 1.0F;
    }
    else
    {
        /* '<S741>:1:19' else */
        /* '<S741>:1:20' alpha = single((HFNoise-HFNoiseLow)/(HFNoiseHigh-HFNoiseLow)); */
        rtb_alpha = qhmath_div_f(Model_Target_B.HFNoise -
            Model_Target_PreAmp0.AudiopilotHfNoiseLowBoundDbspl,
            Model_Target_PreAmp0.AudiopilotHfNoiseHighBoundDbspl -
            Model_Target_PreAmp0.AudiopilotHfNoiseLowBoundDbspl);
    }

    /*  beta: LF Noise */
    /* '<S741>:1:24' if LFnoise < LFNoiseLow */
    if (Model_Target_B.LFNoise <
            Model_Target_PreAmp0.AudiopilotLfNoiseLowBoundDbspl)
    {
        /* '<S741>:1:25' beta = single(0); */
        a2 = 0.0F;
    }
    else if (Model_Target_B.LFNoise >
             Model_Target_PreAmp0.AudiopilotLfNoiseHighBoundDbspl)
    {
        /* '<S741>:1:26' elseif LFnoise > LFNoiseHigh */
        /* '<S741>:1:27' beta = single(1); */
        a2 = 1.0F;
    }
    else
    {
        /* '<S741>:1:28' else */
        /* '<S741>:1:29' beta  = single((LFnoise-LFNoiseLow)/(LFNoiseHigh-LFNoiseLow)); */
        a2 = qhmath_div_f(Model_Target_B.LFNoise -
                          Model_Target_PreAmp0.AudiopilotLfNoiseLowBoundDbspl,
                          Model_Target_PreAmp0.AudiopilotLfNoiseHighBoundDbspl -
                          Model_Target_PreAmp0.AudiopilotLfNoiseLowBoundDbspl);
    }

    /*  product */
    /* '<S741>:1:33' alpha = alpha * beta; */
    rtb_alpha *= a2;

    /* End of MATLAB Function: '<S735>/AlphaCalculation' */

    /* MATLAB Function: '<S735>/BoostMapAdjustments' */
    /*  This adjusts the slope and the thresholds for all three bands */
    /*  based on the ratio and the alpha modifier. */
    /*  Typically the more aggressive tuning, denoted by suffix_1,  */
    /*  corresponds  to the higher ratio value, */
    /*  whereas the less aggressive base tuning,denoted by suffix_0, */
    /*  corresponds to the lower ratio value. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/BoostMapAdjustment/BoostMapAdjustments': '<S745>:1' */
    /*  Set up two-element arrays for the purpose of interpolation */
    /*  Note that the Ratio array has the high value before the low value. */
    /* '<S745>:1:20' RatioPair = [ratioHigh ratioLow]; */
    Model_Target_B.MatrixConcatenate_j2[0] =
        Model_Target_PreAmp0.AudiopilotRatioHighBoundDb;
    Model_Target_B.MatrixConcatenate_j2[1] =
        Model_Target_PreAmp0.AudiopilotRatioLowBoundDb;

    /* '<S745>:1:22' BthreshPair = [BassThresh0 BassThresh1]; */
    Model_Target_B.BthreshPair[0] = Model_Target_PreAmp0.AudiopilotBassThresh0Db;
    Model_Target_B.BthreshPair[1] = Model_Target_PreAmp0.AudiopilotBassThresh1Db;

    /* '<S745>:1:23' MthreshPair = [MidrangeThresh0 MidrangeThresh1]; */
    Model_Target_B.MthreshPair[0] =
        Model_Target_PreAmp0.AudiopilotMidrangeThresh0Db;
    Model_Target_B.MthreshPair[1] =
        Model_Target_PreAmp0.AudiopilotMidrangeThresh1Db;

    /* '<S745>:1:24' TthreshPair = [TrebleThresh0 TrebleThresh1]; */
    Model_Target_B.TthreshPair[0] =
        Model_Target_PreAmp0.AudiopilotTrebleThresh0Db;
    Model_Target_B.TthreshPair[1] =
        Model_Target_PreAmp0.AudiopilotTrebleThresh1Db;

    /* '<S745>:1:25' BslopePair = [BassSlope0 BassSlope1]; */
    Model_Target_B.BslopePair[0] =
        Model_Target_PreAmp0.AudiopilotBassSlope0Dbperdb;
    Model_Target_B.BslopePair[1] =
        Model_Target_PreAmp0.AudiopilotBassSlope1Dbperdb;

    /* '<S745>:1:26' MslopePair = [MidrangeSlope0 MidrangeSlope1]; */
    Model_Target_B.MslopePair[0] =
        Model_Target_PreAmp0.AudiopilotMidrangeSlope0Dbperdb;
    Model_Target_B.MslopePair[1] =
        Model_Target_PreAmp0.AudiopilotMidrangeSlope1Dbperdb;

    /* '<S745>:1:27' TslopePair = [TrebleSlope0 TrebleSlope1]; */
    Model_Target_B.TslopePair[0] =
        Model_Target_PreAmp0.AudiopilotTrebleSlope0Dbperdb;
    Model_Target_B.TslopePair[1] =
        Model_Target_PreAmp0.AudiopilotTrebleSlope1Dbperdb;

    /*  Saturation of the ratio value to the specified range */
    /*  Apply the alpha modifier */
    /* '<S745>:1:32' if ratio >= ratioHigh */
    /*  This is for ratio values higher than high value.   */
    /*  In these cases, the interp1() function really does not need to be run */
    /*  Optimization opportunity. */
    /* '<S745>:1:36' BassSlope = (interp1(RatioPair, BslopePair, ratioHigh, 'linear'))*alpha ... */
    /* '<S745>:1:37'                     + (1-alpha)*BslopePair(1); */
    yy = (1.0F - rtb_alpha) * Model_Target_PreAmp0.AudiopilotBassSlope0Dbperdb +
        Model_Target_interp1(Model_Target_B.MatrixConcatenate_j2,
        Model_Target_B.BslopePair,
        Model_Target_PreAmp0.AudiopilotRatioHighBoundDb) * rtb_alpha;

    /* '<S745>:1:38' MidrangeSlope = (interp1(RatioPair, MslopePair, ratioHigh, 'linear'))*alpha ...    */
    /* '<S745>:1:39'                     + (1-alpha)*MslopePair(1); */
    a2 = (1.0F - rtb_alpha) *
        Model_Target_PreAmp0.AudiopilotMidrangeSlope0Dbperdb +
        Model_Target_interp1(Model_Target_B.MatrixConcatenate_j2,
        Model_Target_B.MslopePair,
        Model_Target_PreAmp0.AudiopilotRatioHighBoundDb) * rtb_alpha;

    /* '<S745>:1:40' TrebleSlope = (interp1(RatioPair, TslopePair, ratioHigh, 'linear'))*alpha ... */
    /* '<S745>:1:41'                     + (1-alpha)*TslopePair(1); */
    /* '<S745>:1:42' BassThresh = (interp1(RatioPair, BthreshPair, ratioHigh, 'linear'))*alpha ... */
    /* '<S745>:1:43'                     + (1-alpha)*BthreshPair(1); */
    q = (1.0F - rtb_alpha) * Model_Target_PreAmp0.AudiopilotBassThresh0Db +
        Model_Target_interp1(Model_Target_B.MatrixConcatenate_j2,
        Model_Target_B.BthreshPair,
        Model_Target_PreAmp0.AudiopilotRatioHighBoundDb) * rtb_alpha;

    /* '<S745>:1:44' MidrangeThresh = (interp1(RatioPair, MthreshPair, ratioHigh, 'linear'))*alpha ... */
    /* '<S745>:1:45'                     + (1-alpha)*MthreshPair(1); */
    xx = (1.0F - rtb_alpha) * Model_Target_PreAmp0.AudiopilotMidrangeThresh0Db +
        Model_Target_interp1(Model_Target_B.MatrixConcatenate_j2,
        Model_Target_B.MthreshPair,
        Model_Target_PreAmp0.AudiopilotRatioHighBoundDb) * rtb_alpha;

    /* S-Function (TOP_MEX): '<S767>/TOP' */
    /* '<S745>:1:46' TrebleThresh = (interp1(RatioPair, TthreshPair, ratioHigh, 'linear'))*alpha ... */
    /* '<S745>:1:47'                     + (1-alpha)*TthreshPair(1); */
    /* Switch: '<S759>/Switch3' incorporates:
     *  Constant: '<S771>/Constant'
     *  MinMax: '<S771>/Max'
     *  MinMax: '<S771>/Min'
     *  Switch: '<S771>/Switch'
     */
    if (Model_TargetPreAmpAudiopilotsetVNCTrebleBoostOverRideRtcOut.REQ_VNCTrebleBoostOverRideFlag
        != 0U)
    {
        rtb_Max_h =
            Model_TargetPreAmpAudiopilotsetVNCTrebleBoostOverRideRtcOut.REQ_VNCTrebleBoostOverRide;
    }
    else
    {
        if (Model_Target_PreAmp0.AudiopilotTrebleDownwardSlopeDbPerDb > 0.0F)
        {
            /* Switch: '<S771>/Switch' incorporates:
             *  MATLAB Function: '<S735>/BoostMapAdjustments'
             *  MinMax: '<S771>/Min1'
             *  Product: '<S771>/Product'
             *  Product: '<S771>/Product1'
             *  Sum: '<S771>/Sum'
             *  Sum: '<S771>/Sum1'
             */
            rtb_alpha = fminf((rtb_max_j -
                               Model_Target_PreAmp0.AudiopilotTrebleDownwardThreshDbspl)
                              * Model_Target_PreAmp0.AudiopilotTrebleDownwardSlopeDbPerDb,
                              (((1.0F - rtb_alpha) *
                                Model_Target_PreAmp0.AudiopilotTrebleThresh0Db +
                                Model_Target_interp1
                                (Model_Target_B.MatrixConcatenate_j2,
                                 Model_Target_B.TthreshPair,
                                 Model_Target_PreAmp0.AudiopilotRatioHighBoundDb)
                                * rtb_alpha) + (Model_Target_B.WBNoise -
                                rtb_max_j)) * ((1.0F - rtb_alpha) *
                               Model_Target_PreAmp0.AudiopilotTrebleSlope0Dbperdb
                               + Model_Target_interp1
                               (Model_Target_B.MatrixConcatenate_j2,
                                Model_Target_B.TslopePair,
                                Model_Target_PreAmp0.AudiopilotRatioHighBoundDb)
                               * rtb_alpha));
        }
        else
        {
            /* Switch: '<S771>/Switch' incorporates:
             *  MATLAB Function: '<S735>/BoostMapAdjustments'
             *  Product: '<S771>/Product'
             *  Sum: '<S771>/Sum'
             */
            rtb_alpha = (((1.0F - rtb_alpha) *
                          Model_Target_PreAmp0.AudiopilotTrebleThresh0Db +
                          Model_Target_interp1
                          (Model_Target_B.MatrixConcatenate_j2,
                           Model_Target_B.TthreshPair,
                           Model_Target_PreAmp0.AudiopilotRatioHighBoundDb) *
                          rtb_alpha) + (Model_Target_B.WBNoise - rtb_max_j)) *
                ((1.0F - rtb_alpha) *
                 Model_Target_PreAmp0.AudiopilotTrebleSlope0Dbperdb +
                 Model_Target_interp1(Model_Target_B.MatrixConcatenate_j2,
                  Model_Target_B.TslopePair,
                  Model_Target_PreAmp0.AudiopilotRatioHighBoundDb) * rtb_alpha);
        }

        rtb_Max_h = fminf(fmaxf(0.0F, rtb_alpha),
                          Model_Target_PreAmp0.AudiopilotTrebleMaxTotalBoostDb);
    }

    /* End of Switch: '<S759>/Switch3' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S862>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S863>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S740>/Ramper' */
    /*  This ramps the on/off switches for both audiopilot and dynamic EQ */
    /*  T */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/RampedEnable/Ramper': '<S864>:1' */
    /*  States */
    /*  Initialization */
    /* '<S864>:1:10' if isempty(dyneq_boost_gain_prev) */
    /* '<S864>:1:14' if isempty(audiopilot_boost_gain_prev) */
    /*  Default to disable  */
    /*  These values should typically not be used. */
    /* '<S864>:1:20' dyneq_boost_gain = single(0); */
    /* '<S864>:1:21' audiopilot_boost_gain = single(0); */
    /*  The value ramps up to 1 or decays to 0 with a first order filter */
    /*  The ramp coefficient is shared between the two features, */
    /*  AudioPilot and Dynamic EQ */
    /* '<S864>:1:27' if dyneq_on */
    if (Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_dyneq_on != 0U)
    {
        /* '<S864>:1:28' dyneq_boost_gain = (1-rampCoef) + (rampCoef * dyneq_boost_gain_prev); */
        rtb_alpha = (1.0F - Model_Target_PreAmp0.AudiopilotEnableRampCoef) +
            Model_Target_PreAmp0.AudiopilotEnableRampCoef *
            Model_Target_DW.dyneq_boost_gain_prev;
    }
    else
    {
        /* '<S864>:1:29' else */
        /* '<S864>:1:30' dyneq_boost_gain = rampCoef * dyneq_boost_gain_prev; */
        rtb_alpha = Model_Target_PreAmp0.AudiopilotEnableRampCoef *
            Model_Target_DW.dyneq_boost_gain_prev;
    }

    /* '<S864>:1:33' if audiopilot_on */
    if (Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_audiopilot_on !=
            0U)
    {
        /* '<S864>:1:34' audiopilot_boost_gain = (1-rampCoef) + (rampCoef * audiopilot_boost_gain_prev); */
        rtb_TrebleSlope = (1.0F - Model_Target_PreAmp0.AudiopilotEnableRampCoef)
            + Model_Target_PreAmp0.AudiopilotEnableRampCoef *
            Model_Target_DW.audiopilot_boost_gain_prev;
    }
    else
    {
        /* '<S864>:1:35' else */
        /* '<S864>:1:36' audiopilot_boost_gain = rampCoef * audiopilot_boost_gain_prev; */
        rtb_TrebleSlope = Model_Target_PreAmp0.AudiopilotEnableRampCoef *
            Model_Target_DW.audiopilot_boost_gain_prev;
    }

    /*  Maintain states */
    /* '<S864>:1:40' dyneq_boost_gain_prev = dyneq_boost_gain; */
    Model_Target_DW.dyneq_boost_gain_prev = rtb_alpha;

    /* '<S864>:1:41' audiopilot_boost_gain_prev = audiopilot_boost_gain; */
    Model_Target_DW.audiopilot_boost_gain_prev = rtb_TrebleSlope;
    Model_Target_B.dyneq_boost_gain = rtb_alpha;
    Model_Target_B.audiopilot_boost_gain = rtb_TrebleSlope;

    /* End of MATLAB Function: '<S740>/Ramper' */

    /* Product: '<S759>/Product' */
    Model_Target_B.Product = rtb_Max_h * Model_Target_B.audiopilot_boost_gain;

    /* Switch: '<S759>/Switch' incorporates:
     *  Constant: '<S769>/Constant'
     *  MinMax: '<S769>/Max'
     *  MinMax: '<S769>/Min'
     *  Product: '<S769>/Product'
     *  Sum: '<S736>/Sum1'
     *  Sum: '<S769>/Sum'
     */
    if (Model_TargetPreAmpAudiopilotsetDynEQBoostOverRideRtcOut.REQ_DynEQBoostOverRideFlag
        != 0U)
    {
        rtb_alpha =
            Model_TargetPreAmpAudiopilotsetDynEQBoostOverRideRtcOut.REQ_DynEQBoostOverRide;
    }
    else
    {
        rtb_alpha = fminf(fmaxf(0.0F,
                                (Model_Target_PreAmp0.AudiopilotDyneqBassThreshDbspl
                            - (Model_Target_B.Product + w2)) *
                                Model_Target_PreAmp0.AudiopilotDyneqBassSlopeDbPerDb),
                          Model_Target_PreAmp0.AudiopilotBassMaxDyneqBoostDb);
    }

    /* Product: '<S759>/Product3' incorporates:
     *  Switch: '<S759>/Switch'
     */
    Model_Target_B.Product3 = rtb_alpha * Model_Target_B.dyneq_boost_gain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S773>/RTC Request Response Trigger' */
    /* Switch: '<S759>/Switch1' incorporates:
     *  Constant: '<S768>/Constant'
     *  MinMax: '<S768>/Max'
     *  MinMax: '<S768>/Min'
     *  Switch: '<S768>/Switch'
     */
    if (Model_TargetPreAmpAudiopilotsetVNCBassBoostOverRideRtcOut.REQ_VNCBassBoostOverRideFlag
        != 0U)
    {
        rtb_Max_h =
            Model_TargetPreAmpAudiopilotsetVNCBassBoostOverRideRtcOut.REQ_VNCBassBoostOverRide;
    }
    else
    {
        if (Model_Target_PreAmp0.AudiopilotBassDownwardSlopeDbPerDb > 0.0F)
        {
            /* Switch: '<S768>/Switch' incorporates:
             *  MinMax: '<S768>/Min1'
             *  Product: '<S768>/Product'
             *  Product: '<S768>/Product1'
             *  Sum: '<S768>/Sum'
             *  Sum: '<S768>/Sum1'
             */
            rtb_alpha = fminf((rtb_max_j -
                               Model_Target_PreAmp0.AudiopilotBassDownwardThreshDbspl)
                              * Model_Target_PreAmp0.AudiopilotBassDownwardSlopeDbPerDb,
                              ((Model_Target_B.LFNoise - rtb_max_j) + q) * yy);
        }
        else
        {
            /* Switch: '<S768>/Switch' incorporates:
             *  Product: '<S768>/Product'
             *  Sum: '<S768>/Sum'
             */
            rtb_alpha = ((Model_Target_B.LFNoise - rtb_max_j) + q) * yy;
        }

        rtb_Max_h = fminf(fmaxf(0.0F, rtb_alpha),
                          Model_Target_PreAmp0.AudiopilotBassMaxAudiopilotBoostDb);
    }

    /* End of Switch: '<S759>/Switch1' */

    /* Product: '<S759>/Product2' */
    Model_Target_B.Product2 = rtb_Max_h * Model_Target_B.audiopilot_boost_gain;

    /* MinMax: '<S736>/Min' incorporates:
     *  Sum: '<S736>/Sum'
     */
    Model_Target_B.Min = fminf(Model_Target_B.Product3 + Model_Target_B.Product2,
        Model_Target_PreAmp0.AudiopilotBassMaxTotalBoostDb);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S699>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S699>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S774>/RTC Request Response Trigger' */
    /* Switch: '<S759>/Switch2' incorporates:
     *  Constant: '<S770>/Constant'
     *  MinMax: '<S770>/Max'
     *  MinMax: '<S770>/Min'
     *  Switch: '<S770>/Switch'
     */
    if (Model_TargetPreAmpAudiopilotsetVNCMidBoostOverRideRtcOut.REQ_VNCMidBoostOverRideFlag
        != 0U)
    {
        rtb_Max_h =
            Model_TargetPreAmpAudiopilotsetVNCMidBoostOverRideRtcOut.REQ_VNCMidBoostOverRide;
    }
    else
    {
        if (Model_Target_PreAmp0.AudiopilotMidrangeDownwardSlopeDbPerDb > 0.0F)
        {
            /* Switch: '<S770>/Switch' incorporates:
             *  MinMax: '<S770>/Min1'
             *  Product: '<S770>/Product'
             *  Product: '<S770>/Product1'
             *  Sum: '<S770>/Sum'
             *  Sum: '<S770>/Sum1'
             */
            rtb_alpha = fminf((rtb_max_j -
                               Model_Target_PreAmp0.AudiopilotMidrangeDownwardThreshDbspl)
                              * Model_Target_PreAmp0.AudiopilotMidrangeDownwardSlopeDbPerDb,
                              ((Model_Target_B.WBNoise - rtb_max_j) + xx) * a2);
        }
        else
        {
            /* Switch: '<S770>/Switch' incorporates:
             *  Product: '<S770>/Product'
             *  Sum: '<S770>/Sum'
             */
            rtb_alpha = ((Model_Target_B.WBNoise - rtb_max_j) + xx) * a2;
        }

        rtb_Max_h = fminf(fmaxf(0.0F, rtb_alpha),
                          Model_Target_PreAmp0.AudiopilotMidrangeMaxTotalBoostDb);
    }

    /* End of Switch: '<S759>/Switch2' */

    /* Product: '<S759>/Product1' */
    Model_Target_B.Product1_o = rtb_Max_h * Model_Target_B.audiopilot_boost_gain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S700>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S700>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S701>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S701>/NTF Trigger' */

    /* MinMax: '<S698>/TrebleMax' incorporates:
     *  Constant: '<S698>/Constant3'
     *  Gain: '<S711>/Gain'
     *  Math: '<S711>/Math Function'
     */
    rtb_max_j = fmaxf(qhmath_pow_f(10.0F, 0.05F * Model_Target_B.Product), 0.0F);

    /* Switch: '<S698>/Switch' incorporates:
     *  Constant: '<S698>/Constant'
     *  Constant: '<S698>/Constant4'
     *  Gain: '<S710>/Gain'
     *  Math: '<S710>/Math Function'
     *  MinMax: '<S698>/MidrangeMax'
     *  Sum: '<S698>/Add1'
     */
    if (Model_Target_PreAmp0.AudiopilotTwoDowngrade != 0U)
    {
        rtb_Max_h = 0.0F;
    }
    else
    {
        rtb_Max_h = fmaxf(qhmath_pow_f(10.0F, 0.05F * Model_Target_B.Product1_o)
                          - rtb_max_j, 0.0F);
    }

    /* End of Switch: '<S698>/Switch' */
    /* DiscreteFilter: '<S698>/Bpf' incorporates:
     *  S-Function (TOP_MEX): '<S706>/TOP'
     *  S-Function (TOP_MEX): '<S706>/TOP1'
     */
    yIdx = 0;
    for (c = 0; c < 2; c++)
    {
        sample = c << 1;
        for (stateLen = 0; stateLen < 32; stateLen++)
        {
            Model_Target_B.Bpf[yIdx] =
                Model_Target_PreAmp0.AudiopilotBassBpfNumerator[0] *
                Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx] +
                Model_Target_DW.Bpf_states[sample];
            Model_Target_DW.Bpf_states[sample] =
                (Model_Target_DW.Bpf_states[sample + 1] +
                 Model_Target_PreAmp0.AudiopilotBassBpfNumerator[1] *
                 Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx]) -
                Model_Target_PreAmp0.AudiopilotBassBpfDenominator[1] *
                Model_Target_B.Bpf[yIdx];
            Model_Target_DW.Bpf_states[sample + 1] =
                Model_Target_PreAmp0.AudiopilotBassBpfNumerator[2] *
                Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx] -
                Model_Target_PreAmp0.AudiopilotBassBpfDenominator[2] *
                Model_Target_B.Bpf[yIdx];
            yIdx++;
        }
    }

    /* End of DiscreteFilter: '<S698>/Bpf' */

    /* MinMax: '<S698>/BassMax' incorporates:
     *  Constant: '<S698>/Constant1'
     *  Gain: '<S709>/Gain'
     *  Math: '<S709>/Math Function'
     *  Sum: '<S698>/Add'
     *  Sum: '<S698>/Add2'
     */
    w2 = fmaxf(qhmath_pow_f(10.0F, 0.05F * Model_Target_B.Min) - (rtb_max_j +
                rtb_Max_h), 0.0F);

    /* Product: '<S698>/BPFFramify' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] = w2;
    }

    /* End of Product: '<S698>/BPFFramify' */

    /* DiscreteFilter: '<S698>/ZipperNoiseReductionBpf' incorporates:
     *  Product: '<S698>/BPFFramify'
     *  S-Function (TOP_MEX): '<S702>/TOP1'
     */
    yIdx = 0;
    for (stateLen = 0; stateLen < 32; stateLen++)
    {
        Model_Target_B.ZipperNoiseReductionBpf[yIdx] =
            Model_Target_PreAmp0.AudiopilotAntiZipperRampLpfNumerator *
            Model_Target_B.HeadrestMatrixConcatenate_i[yIdx] +
            Model_Target_DW.ZipperNoiseReductionBpf_states;
        Model_Target_DW.ZipperNoiseReductionBpf_states = 0.0F -
            Model_Target_PreAmp0.AudiopilotAntiZipperRampLpfDenominator[1] *
            Model_Target_B.ZipperNoiseReductionBpf[yIdx];
        yIdx++;
    }

    /* End of DiscreteFilter: '<S698>/ZipperNoiseReductionBpf' */

    /* MATLAB Function: '<S698>/ApplyBpfGain' */
    Model_Target_ApplyBpfGain(Model_Target_B.Bpf,
        Model_Target_B.ZipperNoiseReductionBpf, &Model_Target_B.sf_ApplyBpfGain);

    /* DiscreteFilter: '<S698>/Lpf' incorporates:
     *  S-Function (TOP_MEX): '<S707>/TOP'
     *  S-Function (TOP_MEX): '<S707>/TOP1'
     */
    yIdx = 0;
    for (c = 0; c < 2; c++)
    {
        sample = c << 2;
        for (stateLen = 0; stateLen < 32; stateLen++)
        {
            Model_Target_B.Lpf[yIdx] =
                Model_Target_PreAmp0.AudiopilotMidrangeLpfNumerator[0] *
                Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx] +
                Model_Target_DW.Lpf_states[sample];
            Model_Target_DW.Lpf_states[sample] =
                (Model_Target_DW.Lpf_states[sample + 1] +
                 Model_Target_PreAmp0.AudiopilotMidrangeLpfNumerator[1] *
                 Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx]) -
                Model_Target_PreAmp0.AudiopilotMidrangeLpfDenominator[1] *
                Model_Target_B.Lpf[yIdx];
            Model_Target_DW.Lpf_states[sample + 1] =
                (Model_Target_DW.Lpf_states[sample + 2] +
                 Model_Target_PreAmp0.AudiopilotMidrangeLpfNumerator[2] *
                 Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx]) -
                Model_Target_PreAmp0.AudiopilotMidrangeLpfDenominator[2] *
                Model_Target_B.Lpf[yIdx];
            Model_Target_DW.Lpf_states[sample + 2] =
                (Model_Target_DW.Lpf_states[sample + 3] +
                 Model_Target_PreAmp0.AudiopilotMidrangeLpfNumerator[3] *
                 Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx]) -
                Model_Target_PreAmp0.AudiopilotMidrangeLpfDenominator[3] *
                Model_Target_B.Lpf[yIdx];
            Model_Target_DW.Lpf_states[sample + 3] =
                Model_Target_PreAmp0.AudiopilotMidrangeLpfNumerator[4] *
                Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx] -
                Model_Target_PreAmp0.AudiopilotMidrangeLpfDenominator[4] *
                Model_Target_B.Lpf[yIdx];
            yIdx++;
        }
    }

    /* End of DiscreteFilter: '<S698>/Lpf' */

    /* Product: '<S698>/LPFFramify' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] = rtb_Max_h;
    }

    /* End of Product: '<S698>/LPFFramify' */

    /* DiscreteFilter: '<S698>/ZipperNoiseReductionLpf' incorporates:
     *  Product: '<S698>/LPFFramify'
     *  S-Function (TOP_MEX): '<S702>/TOP1'
     */
    yIdx = 0;
    for (stateLen = 0; stateLen < 32; stateLen++)
    {
        Model_Target_B.ZipperNoiseReductionLpf[yIdx] =
            Model_Target_PreAmp0.AudiopilotAntiZipperRampLpfNumerator *
            Model_Target_B.HeadrestMatrixConcatenate_i[yIdx] +
            Model_Target_DW.ZipperNoiseReductionLpf_states;
        Model_Target_DW.ZipperNoiseReductionLpf_states = 0.0F -
            Model_Target_PreAmp0.AudiopilotAntiZipperRampLpfDenominator[1] *
            Model_Target_B.ZipperNoiseReductionLpf[yIdx];
        yIdx++;
    }

    /* End of DiscreteFilter: '<S698>/ZipperNoiseReductionLpf' */

    /* MATLAB Function: '<S698>/ApplyLpfGain' */
    Model_Target_ApplyBpfGain(Model_Target_B.Lpf,
        Model_Target_B.ZipperNoiseReductionLpf, &Model_Target_B.sf_ApplyLpfGain);

    /* Product: '<S698>/WideFramify' */
    for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] = rtb_max_j;
    }

    /* End of Product: '<S698>/WideFramify' */

    /* DiscreteFilter: '<S698>/ZipperNoiseReductionWide' incorporates:
     *  Product: '<S698>/WideFramify'
     *  S-Function (TOP_MEX): '<S702>/TOP1'
     */
    yIdx = 0;
    for (stateLen = 0; stateLen < 32; stateLen++)
    {
        Model_Target_B.ZipperNoiseReductionWide[yIdx] =
            Model_Target_PreAmp0.AudiopilotAntiZipperRampLpfNumerator *
            Model_Target_B.HeadrestMatrixConcatenate_i[yIdx] +
            Model_Target_DW.ZipperNoiseReductionWide_states;
        Model_Target_DW.ZipperNoiseReductionWide_states = 0.0F -
            Model_Target_PreAmp0.AudiopilotAntiZipperRampLpfDenominator[1] *
            Model_Target_B.ZipperNoiseReductionWide[yIdx];
        yIdx++;
    }

    /* End of DiscreteFilter: '<S698>/ZipperNoiseReductionWide' */

    /* MATLAB Function: '<S698>/ApplyWideGain' incorporates:
     *  DiscreteFilter: '<S698>/ZipperNoiseReductionWide'
     */
    /*  This applies a frame of gains to the input audio */
    /*  It should work for any number of channels */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainApplication/Compensation/ApplyWideGain': '<S705>:1' */
    /* '<S705>:1:5' numchan = size(audio,2); */
    /* '<S705>:1:6' out = audio .* (gain * ones(1,numchan)); */
    for (yIdx = 0; yIdx < 2; yIdx++)
    {
        memcpy(&Model_Target_B.Selector2_e[yIdx << 5],
               &Model_Target_B.ZipperNoiseReductionWide[0], sizeof(real32_T) <<
               5U);
    }

    for (yIdx = 0; yIdx < 64; yIdx++)
    {
        Model_Target_B.Sum_g[yIdx] =
            Model_Target_B.sf_rgainyprocess_k.audioOut[yIdx] *
            Model_Target_B.Selector2_e[yIdx];
    }

    /* End of MATLAB Function: '<S698>/ApplyWideGain' */
    /* MATLAB Function: '<S714>/delay' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'Delay/delay': '<S715>:1' */
    /*  figure out the frame size and channel count */
    /* '<S715>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S715>:1:8' frameSize = int32(frameSize); */
    /* '<S715>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S715>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S715>:1:11' delayTime = int32(delayTime); */
    /* '<S715>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S715>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S715>:1:23' bufferIndex = delayIndex; */
    xpageoffset = Model_Target_DW.delayIndex_i;

    /* '<S715>:1:25' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 2; yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S715>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(xpageoffset, 0, 76);

        /* '<S715>:1:32' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S715>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_k[writeIndex] = Model_Target_B.Sum_g
                [(yIdx << 5) + sample];

            /*  increment write pointer */
            /* '<S715>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 76);
        }

        /*  Advance buffer index for next channel */
        /* '<S715>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 38, 76);
    }

    /*  Reset */
    /* '<S715>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    xpageoffset = circindex(Model_Target_DW.delayIndex_i, 32, 76);

    /* '<S715>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_i = xpageoffset;

    /*  Read samples from delay line */
    /* '<S715>:1:50' for channel = 1:numChannels */
    for (yIdx = 0; yIdx < 2; yIdx++)
    {
        /*  Setup read pointer */
        /* '<S715>:1:53' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
        writeIndex = circindex(xpageoffset,
                               -(Model_Target_PreAmp0.AudiopilotMidrangeLpfAlignDelaySamples
                                + 32), 76);

        /* '<S715>:1:55' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S715>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.Sum_g[sample + (yIdx << 5)] =
                Model_Target_DW.delayBuffer_k[writeIndex];

            /*  increment write pointer */
            /* '<S715>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 76);
        }

        /*  Advance buffer index for next channel */
        /* '<S715>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        xpageoffset = circindex(xpageoffset, 38, 76);
    }

    /* End of MATLAB Function: '<S714>/delay' */
    for (xpageoffset = 0; xpageoffset < 64; xpageoffset++)
    {
        /* Sum: '<S698>/Sum' */
        Model_Target_B.Sum_j[xpageoffset] = (Model_Target_B.Sum_g[xpageoffset] +
            Model_Target_B.sf_ApplyLpfGain.out[xpageoffset]) +
            Model_Target_B.sf_ApplyBpfGain.out[xpageoffset];
    }

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S737>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S772>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S773>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S774>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S775>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S801>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S803>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S737>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S822>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S823>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S825>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S826>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S862>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S863>/NTF Trigger' */

    /* RateTransition: '<S664>/Rate Transition9' */
    rtb_Max_h =
        Model_Target_DW.RateTransition9_Buffer[Model_Target_DW.RateTransition9_ActiveBufIdx];

    /* Switch: '<S1075>/audiopilot' incorporates:
     *  MATLAB Function: '<S1073>/PreProcess'
     */
    Model_Target_B.audiopilot = rtb_Delay3;

    /* Switch: '<S1088>/dyneq' incorporates:
     *  MATLAB Function: '<S1073>/PreProcess'
     */
    Model_Target_B.dyneq = rtb_Delay3;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1114>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1114>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1143>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1143>/NTF Trigger' */
    /* MATLAB Function: '<S1142>/balanceProcess' incorporates:
     *  S-Function (TOP_MEX): '<S1142>/TOP'
     *  Sum: '<S698>/Sum'
     */
    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'PreAmp/DecRate/Medusa5H1/Balance/Balance/balanceProcess': '<S1153>:1' */
    /*  Applies the Left and Right gains to the respective channels via multiple */
    /*    rampers */
    /*  Inputs: */
    /*   audioIn: Input audio */
    /*   channelToRamperMap: Input channels mapped to their corresponding ramper. */
    /*   MaskNumRampers: Number of rampers (set in the Mask file) = 4 */
    /*  Data Store objects (registered in "Edit Data" dialog) */
    /*  Figure out the frame size, channel count and number of rampers */
    /* '<S1153>:1:16' [frameSize, ~] = size(audioIn); */
    /*  set the size and datatype of the output buffer */
    /* '<S1153>:1:19' audioOut = coder.nullcopy(audioIn); */
    /*    Every channel needs a ramper, but every ramper does not need to be on a */
    /*    channel necessarily. */
    /* '<S1153>:1:23' for ramper = 1:MaskNumRampers */
    for (c = 0; c < 4; c++)
    {
        /*  Get the gains */
        /* '<S1153>:1:25' gain = Rampers(ramper).currentGain; */
        rtb_max_j = Model_TargetControlDsms.PreAmpBalance_CfgRampers[c].
            currentGain;

        /* '<S1153>:1:26' rampCoeffMultipliers = ones(1, frameSize, 'single'); */
        for (xpageoffset = 0; xpageoffset < 32; xpageoffset++)
        {
            Model_Target_B.HeadrestMatrixConcatenate_i[xpageoffset] = 1.0F;
        }

        /* '<S1153>:1:27' if (Freeze(1) == false) */
        if (Model_TargetControlDsms.PreAmpBalance_CfgFreeze == 0U)
        {
            /* '<S1153>:1:28' if (Rampers(ramper).frameCount == 0) */
            if (Model_TargetControlDsms.PreAmpBalance_CfgRampers[c].frameCount ==
                0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1153>:1:30' gain = Rampers(ramper).targetGain; */
                rtb_max_j = Model_TargetControlDsms.PreAmpBalance_CfgRampers[c].
                    targetGain;
            }
            else
            {
                /* '<S1153>:1:31' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1153>:1:33' k = Rampers(ramper).rampCoeff; */
                /* '<S1153>:1:34' rampCoeffMultipliers = (k * rampCoeffMultipliers) .^ (1:frameSize); */
                for (yIdx = 0; yIdx < 32; yIdx++)
                {
                    Model_Target_B.HeadrestMatrixConcatenate_i[yIdx] =
                        qhmath_pow_f
                        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[c].
                         rampCoeff, (real32_T)((real_T)yIdx + 1.0));
                }

                /* '<S1153>:1:35' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
                xpageoffset = Model_TargetControlDsms.PreAmpBalance_CfgRampers[c]
                    .frameCount;
                if (xpageoffset < -2147483647)
                {
                    Model_TargetControlDsms.PreAmpBalance_CfgRampers[c].
                        frameCount = MIN_int32_T;
                }
                else
                {
                    Model_TargetControlDsms.PreAmpBalance_CfgRampers[c].
                        frameCount = xpageoffset - 1;
                }
            }
        }

        /*  Apply the gains to the corresponding channels via the Mask parameter */
        /*  and tuneTop paramter "channelToRamperMap".   */
        /* '<S1153>:1:41' currentChannelGroup = find(channelToRamperMap == ramper); */
        tmp[0] = ((real_T)(c + 1) ==
                  Model_Target_PreAmp0.Balance_CfgChanRampMap[0]);
        tmp[1] = ((real_T)(c + 1) ==
                  Model_Target_PreAmp0.Balance_CfgChanRampMap[1]);
        Model_Target_eml_find_a(tmp, Model_Target_B.d_data,
                                Model_Target_B.d_size);

        /* '<S1153>:1:42' for ch = 1:numel(currentChannelGroup) */
        stateLen = Model_Target_B.d_size[1];
        for (xpageoffset = 0; xpageoffset < stateLen; xpageoffset++)
        {
            /* '<S1153>:1:43' audioOut(:,currentChannelGroup(ch)) = (gain * rampCoeffMultipliers)' .* audioIn(:,currentChannelGroup(ch)); */
            writeIndex = Model_Target_B.d_data[xpageoffset];
            for (yIdx = 0; yIdx < 32; yIdx++)
            {
                Model_Target_B.FRIn[yIdx + ((writeIndex - 1) << 5)] =
                    Model_Target_B.Sum_j[((writeIndex - 1) << 5) + yIdx] *
                    (rtb_max_j * Model_Target_B.HeadrestMatrixConcatenate_i[yIdx]);
            }
        }

        /* '<S1153>:1:45' Rampers(ramper).currentGain = gain * rampCoeffMultipliers(end); */
        Model_TargetControlDsms.PreAmpBalance_CfgRampers[c].currentGain =
            rtb_max_j * Model_Target_B.HeadrestMatrixConcatenate_i[31];
    }

    /*  If ramper value of -1 is encountered, this indicates an unused channel. */
    /*  Assign values of zero to all samples of these channels. */
    /* '<S1153>:1:50' unusedChannelGroup = find(channelToRamperMap == -1); */
    tmp[0] = (Model_Target_PreAmp0.Balance_CfgChanRampMap[0] == -1.0F);
    tmp[1] = (Model_Target_PreAmp0.Balance_CfgChanRampMap[1] == -1.0F);
    Model_Target_eml_find_a(tmp, Model_Target_B.d_data, Model_Target_B.d_size);

    /* '<S1153>:1:51' for unusedCh = 1:numel(unusedChannelGroup) */
    c = Model_Target_B.d_size[1];
    for (stateLen = 0; stateLen < c; stateLen++)
    {
        /* '<S1153>:1:52' audioOut(:,unusedChannelGroup(unusedCh)) = 0; */
        writeIndex = Model_Target_B.d_data[stateLen];
        memset(&Model_Target_B.FRIn[(writeIndex << 5) + -32], 0, sizeof(real32_T)
               << 5U);
    }

    /* End of MATLAB Function: '<S1142>/balanceProcess' */

    /* Outputs for Atomic SubSystem: '<S1137>/Medusa5H1 Part 1' */
    Model_Target_Medusa5H1Part1();

    /* End of Outputs for SubSystem: '<S1137>/Medusa5H1 Part 1' */

    /* Delay: '<S1803>/Variable Integer Delay' incorporates:
     *  DownSample: '<S1172>/Downsample'
     */
    if (Model_Target_PreAmp0.NearDelay < 1.0F)
    {
        /* Delay: '<S1803>/Variable Integer Delay' incorporates:
         *  DownSample: '<S1172>/Downsample'
         */
        memcpy(&Model_Target_B.VariableIntegerDelay[0],
               &Model_Target_B.Downsample[0], sizeof(real32_T) << 4U);
    }
    else
    {
        if (Model_Target_PreAmp0.NearDelay > 100.0F)
        {
            b = 100U;
        }
        else
        {
            rtb_alpha = fmodf(truncf(Model_Target_PreAmp0.NearDelay),
                              4.2949673E+9F);
            b = rtb_alpha < 0.0F ? (uint32_T)-(int32_T)(uint32_T)-rtb_alpha :
                (uint32_T)rtb_alpha;
        }

        for (stateLen = 0; stateLen < 8; stateLen++)
        {
            if ((uint32_T)stateLen < b)
            {
                c = (stateLen - (int32_T)b) + 100;
                Model_Target_B.VariableIntegerDelay[stateLen] =
                    Model_Target_DW.VariableIntegerDelay_DSTATE[c];
                Model_Target_B.VariableIntegerDelay[stateLen + 8] =
                    Model_Target_DW.VariableIntegerDelay_DSTATE[c + 100];
            }
            else
            {
                c = stateLen - (int32_T)b;
                Model_Target_B.VariableIntegerDelay[stateLen] =
                    Model_Target_B.Downsample[c];
                Model_Target_B.VariableIntegerDelay[stateLen + 8] =
                    Model_Target_B.Downsample[c + 8];
            }
        }
    }

    /* End of Delay: '<S1803>/Variable Integer Delay' */
    /* MATLAB Function: '<S1810>/FirEvenProcess' incorporates:
     *  Constant: '<S1803>/Constant'
     *  DownSample: '<S1172>/Downsample'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenProcess': '<S1812>:1' */
    /* '<S1812>:1:4' [FilterLength, ~] = size(FlippedCoeffs); */
    /* '<S1812>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Initialize variables */
    /* '<S1812>:1:11' if isempty(States) */
    /*  Set correct data types */
    /* '<S1812>:1:16' FilterLength = uint32(FilterLength); */
    /* '<S1812>:1:17' FrameSize = uint32(FrameSize); */
    /* '<S1812>:1:18' ActiveCoeffSet = uint32(ActiveCoeffSet); */
    /* '<S1812>:1:21' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1812>:1:24' else */
    /*  FIR EVEN HEXAGON */
    /* '<S1812>:1:26' if (FilterLength > FrameSize) */
    /* '<S1812>:1:27' y = fireven_hexagon_process_mt(single(u), uint32(ActiveCoeffSet), single(States), uint32(CodeWorkMemory)); */
    Model_Target_B.uv[0] = 0U;
    Model_Target_B.uv[1] = 0U;
    fireven_process_mt(&Model_Target_B.Downsample_b[0],
                       &Model_Target_B.Downsample[0], &Model_Target_B.uv[0],
                       &Model_Target_DW.States[0], &NearWiggleCodeWorkMemory[0]);

    /* MATLAB Function: '<S1804>/Crossfade ' incorporates:
     *  Delay: '<S1803>/Variable Integer Delay'
     */
    /*  fadetime in ms */
    /*  sigSelect = 0 passes normalEnt, sigSelect = 1 passes monoEnt */
    /* MATLAB Function 'CrossFader/Crossfade ': '<S1808>:1' */
    /*  first run init */
    /* '<S1808>:1:9' if (isempty(currentFadeInd)) */
    /*  Selection changed */
    /* '<S1808>:1:15' startFade = 0; */
    stateLen = 0;

    /* '<S1808>:1:16' if (currentSig ~= sigSelect) */
    if (Model_Target_DW.currentSig != Model_Target_B.y)
    {
        /*     currentSig = sigSelect; */
        /* '<S1808>:1:18' currentSig = uint32(sigSelect); */
        Model_Target_DW.currentSig = Model_Target_B.y;

        /* '<S1808>:1:19' currentFadeInd = 0; */
        Model_Target_DW.currentFadeInd = 0.0;

        /* '<S1808>:1:20' startFade = 1; */
        stateLen = 1;
    }

    /* '<S1808>:1:23' crossfadedOutput = single(zeros(size(normalEnt))); */
    /* '<S1808>:1:24' normalEntOutput = single(zeros(size(normalEnt))); */
    /* '<S1808>:1:25' monoEntOutput = single(zeros(size(normalEnt))); */
    /*  Process the audio */
    /* '<S1808>:1:28' if ((currentFadeInd ~= 0)||(startFade)) */
    if ((Model_Target_DW.currentFadeInd != 0.0) || (stateLen != 0))
    {
        /*  Apply the cross fade gains, either because we're mid-ramp or we're */
        /*  starting over */
        /* '<S1808>:1:31' for (samp = 1:size(normalEnt, 1) */
        for (stateLen = 0; stateLen < 8; stateLen++)
        {
            /* '<S1808>:1:32' currentFadeInd = currentFadeInd + 1; */
            Model_Target_DW.currentFadeInd++;

            /*  lookup gains for this sample */
            /* '<S1808>:1:34' if (currentFadeInd > fadeSamples) */
            if (Model_Target_DW.currentFadeInd > Model_Target_ConstB.Product)
            {
                /*  we hit the end of the ramp, but we're still working */
                /*  a frame that was ramping */
                /* '<S1808>:1:37' if (currentSig) */
                if (Model_Target_DW.currentSig != 0U)
                {
                    /* '<S1808>:1:38' normalEntGain = 0; */
                    Model_Target_B.vncBoostGain_j = 0.0;

                    /* '<S1808>:1:39' monoEntGain = 1; */
                    Model_Target_B.Switch1 = 1.0;
                }
                else
                {
                    /* '<S1808>:1:40' else */
                    /* '<S1808>:1:41' normalEntGain = 1; */
                    Model_Target_B.vncBoostGain_j = 1.0;

                    /* '<S1808>:1:42' monoEntGain = 0; */
                    Model_Target_B.Switch1 = 0.0;
                }

                /* '<S1808>:1:44' else */
                /*  actively ramping */
                /* '<S1808>:1:46' if (currentSig) */
            }
            else if (Model_Target_DW.currentSig != 0U)
            {
                /*                  sig1Gain = fadeDownGain(currentFadeInd); */
                /* '<S1808>:1:48' normalEntGain = 1-(currentFadeInd/fadeSamples); */
                Model_Target_B.Switch1 = Model_Target_DW.currentFadeInd /
                    Model_Target_ConstB.Product;
                Model_Target_B.vncBoostGain_j = 1.0 - Model_Target_B.Switch1;

                /*                  sig2Gain = fadeUpGain(currentFadeInd); */
                /* '<S1808>:1:50' monoEntGain = (currentFadeInd/fadeSamples); */
            }
            else
            {
                /* '<S1808>:1:51' else */
                /*                  sig1Gain = fadeUpGain(currentFadeInd); */
                /* '<S1808>:1:53' normalEntGain = (currentFadeInd/fadeSamples); */
                Model_Target_B.vncBoostGain_j = Model_Target_DW.currentFadeInd /
                    Model_Target_ConstB.Product;

                /*                  sig2Gain = fadeDownGain(currentFadeInd); */
                /* '<S1808>:1:55' monoEntGain = 1-(currentFadeInd/fadeSamples); */
                Model_Target_B.Switch1 = 1.0 - Model_Target_DW.currentFadeInd /
                    Model_Target_ConstB.Product;
            }

            /*  apply gains */
            /* '<S1808>:1:59' normalEntOutput(samp,:) = (normalEnt(samp,:)*normalEntGain); */
            /* '<S1808>:1:60' monoEntOutput(samp,:) = (monoEnt(samp,:)*monoEntGain); */
            /* '<S1808>:1:61' crossfadedOutput(samp,:) = single(normalEnt(samp,:)*normalEntGain + monoEnt(samp,:)*monoEntGain); */
            Model_Target_B.crossfadedOutput[stateLen] =
                Model_Target_B.VariableIntegerDelay[stateLen] * (real32_T)
                Model_Target_B.vncBoostGain_j +
                Model_Target_B.Downsample_b[stateLen] * (real32_T)
                Model_Target_B.Switch1;
            Model_Target_B.crossfadedOutput[stateLen + 8] =
                Model_Target_B.VariableIntegerDelay[stateLen + 8] * (real32_T)
                Model_Target_B.vncBoostGain_j +
                Model_Target_B.Downsample_b[stateLen + 8] * (real32_T)
                Model_Target_B.Switch1;
        }

        /*  reset fade if finished */
        /* '<S1808>:1:64' if (currentFadeInd > fadeSamples) */
        if (Model_Target_DW.currentFadeInd > Model_Target_ConstB.Product)
        {
            /* '<S1808>:1:65' currentFadeInd = 0; */
            Model_Target_DW.currentFadeInd = 0.0;
        }

        /* '<S1808>:1:67' else */
        /*  Just pass selected signal */
        /* '<S1808>:1:69' if (currentSig) */
    }
    else if (Model_Target_DW.currentSig != 0U)
    {
        /* '<S1808>:1:70' crossfadedOutput = single(monoEnt(1:size(normalEnt,1),1:size(normalEnt,2))); */
        memcpy(&Model_Target_B.crossfadedOutput[0],
               &Model_Target_B.Downsample_b[0], sizeof(real32_T) << 4U);
    }
    else
    {
        /* '<S1808>:1:71' else */
        /* '<S1808>:1:72' crossfadedOutput = single(normalEnt); */
        memcpy(&Model_Target_B.crossfadedOutput[0],
               &Model_Target_B.VariableIntegerDelay[0], sizeof(real32_T) << 4U);
    }

    /* End of MATLAB Function: '<S1804>/Crossfade ' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1813>/ITC1' */
    /* Update for Delay: '<S1803>/Variable Integer Delay' incorporates:
     *  DownSample: '<S1172>/Downsample'
     */
    for (c = 0; c < 2; c++)
    {
        for (stateLen = 0; stateLen < 92; stateLen++)
        {
            xpageoffset = c * 100 + stateLen;
            Model_Target_DW.VariableIntegerDelay_DSTATE[xpageoffset] =
                Model_Target_DW.VariableIntegerDelay_DSTATE[xpageoffset + 8];
        }
    }

    for (yIdx = 0; yIdx < 2; yIdx++)
    {
        for (stateLen = 0; stateLen < 8; stateLen++)
        {
            Model_Target_DW.VariableIntegerDelay_DSTATE[(stateLen + 100 * yIdx)
                + 92] = Model_Target_B.Downsample[(yIdx << 3) + stateLen];
        }
    }

    /* End of Update for Delay: '<S1803>/Variable Integer Delay' */
    /* End of Outputs for SubSystem: '<S663>/NearWiggleFilters' */

    /* Outputs for Atomic SubSystem: '<S1137>/Medusa5H1 Part 2' */
    Model_Target_Medusa5H1Part2TID2();

    /* End of Outputs for SubSystem: '<S1137>/Medusa5H1 Part 2' */

    /* Outputs for Atomic SubSystem: '<S1137>/Medusa5H1 Part 3' */
    Model_Target_Medusa5H1Part3();

    /* End of Outputs for SubSystem: '<S1137>/Medusa5H1 Part 3' */

    /* Outputs for Atomic SubSystem: '<S1137>/Medusa5H1 Part 4' */
    Model_Target_Medusa5H1Part4();

    /* End of Outputs for SubSystem: '<S1137>/Medusa5H1 Part 4' */

    /* Outputs for Atomic SubSystem: '<S1137>/Medusa5H1 Part 5' */
    Model_Target_Medusa5H1Part5();

    /* End of Outputs for SubSystem: '<S1137>/Medusa5H1 Part 5' */

    /* Outputs for Atomic SubSystem: '<S1137>/Medusa5H1 Part 6' */
    Model_Target_Medusa5H1Part6();

    /* End of Outputs for SubSystem: '<S1137>/Medusa5H1 Part 6' */

    /* Outputs for Atomic SubSystem: '<S663>/PreAmpPart2' */
    Model_Target_PreAmpPart2();

    /* End of Outputs for SubSystem: '<S663>/PreAmpPart2' */

    /* Outputs for Atomic SubSystem: '<S663>/VLS' */
    Model_Target_VLS();

    /* End of Outputs for SubSystem: '<S663>/VLS' */

    /* Outputs for Atomic SubSystem: '<S663>/MedusaPostHoligram' */
    /* Sum: '<S1138>/Add' incorporates:
     *  Assignment: '<S66>/Assignment'
     */
    for (xpageoffset = 0; xpageoffset < 144; xpageoffset++)
    {
        Model_Target_MedusaPostHoligram_B.MatrixConcatenate[xpageoffset] =
            Model_Target_B.FRIn[xpageoffset] +
            Model_Target_B.Assignment_j[xpageoffset];
    }

    /* End of Sum: '<S1138>/Add' */

    /* Sum: '<S1138>/Add1' incorporates:
     *  Concatenate: '<S4>/Matrix Concatenate'
     */
    for (xpageoffset = 0; xpageoffset < 704; xpageoffset++)
    {
        Model_Target_B.FRIn[xpageoffset] =
            Model_Target_B.sf_fade_l.audioOut[xpageoffset] +
            Model_Target_B.MatrixConcatenate_g[xpageoffset];
    }

    /* End of Sum: '<S1138>/Add1' */

    /* Outputs for Atomic SubSystem: '<S1138>/MedusaPostHoligram' */
    Model_Target_MedusaPostHoligram();

    /* End of Outputs for SubSystem: '<S1138>/MedusaPostHoligram' */
    /* End of Outputs for SubSystem: '<S663>/MedusaPostHoligram' */

    /* Outputs for Atomic SubSystem: '<S7>/SrcUp' */
    Model_Target_SrcUpTID2();

    /* End of Outputs for SubSystem: '<S7>/SrcUp' */

    /* Update for Delay: '<S660>/Delay3' */
    Model_Target_DW.Delay3_DSTATE = rtb_Max_h;

    /* Update for Atomic SubSystem: '<S7>/PreAmpPart1' */
    Model_Target_PreAmpPart1_Update();

    /* End of Update for SubSystem: '<S7>/PreAmpPart1' */
    for (yIdx = 0; yIdx < 3968; yIdx++)
    {
        /* Update for Atomic SubSystem: '<S655>/AudioPilot35' */
        /* Update for Delay: '<S662>/Delay2' */
        Model_Target_DW.Delay2_DSTATE[yIdx] = Model_Target_DW.Delay2_DSTATE[yIdx
            + 128];

        /* End of Update for SubSystem: '<S655>/AudioPilot35' */
    }

    /* Update for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* Update for Delay: '<S662>/Delay2' incorporates:
     *  Selector: '<S1165>/Selector1'
     */
    memcpy(&Model_Target_DW.Delay2_DSTATE[3968], &Model_Target_B.LoRoLimpRimp[0],
           sizeof(real32_T) << 7U);

    /* End of Update for SubSystem: '<S655>/AudioPilot35' */
    for (yIdx = 0; yIdx < 992; yIdx++)
    {
        /* Update for Atomic SubSystem: '<S655>/AudioPilot35' */
        /* Update for Delay: '<S662>/Delay1' */
        Model_Target_DW.Delay1_DSTATE_lo[yIdx] =
            Model_Target_DW.Delay1_DSTATE_lo[yIdx + 32];

        /* End of Update for SubSystem: '<S655>/AudioPilot35' */
    }

    /* Update for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* Update for Delay: '<S662>/Delay1' incorporates:
     *  S-Function (sdspstatfcns): '<S1164>/Mean'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_lo[992], &Model_Target_B.Mean[0],
           sizeof(real32_T) << 5U);

    /* Update for M-S-Function: '<S676>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotVehicleSpeed '<S676>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 46,
                    &(Model_TargetPreAmpAudiopilotsetSpeedInRtcOut.REQ_speedIn));

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S671>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHvacDbspl '<S671>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 22, &Model_Target_B.hvacDbspl);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S857>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseDbspl '<S857>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 24, &Model_Target_B.LFNoise);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S860>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotWbNoiseDbspl '<S860>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 47, &Model_Target_B.WBNoise);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S855>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoiseDbspl '<S855>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 15, &Model_Target_B.HFNoise);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S858>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotNoiseRatio '<S858>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 41, &Model_Target_B.Ratio);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S859>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotTotalBassBoostDb '<S859>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 45, &Model_Target_B.Min);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S852>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotAudiopilotMidrangeBoostDb '<S852>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 11, &Model_Target_B.Product1_o);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S853>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotAudiopilotTrebleBoostDb '<S853>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 12, &Model_Target_B.Product);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S854>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotDyneqBassBoostDb '<S854>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 13, &Model_Target_B.Product3);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S851>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotAudiopilotBassBoostDb '<S851>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 9, &Model_Target_B.Product2);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S856>/TSP' incorporates:
     *  Constant: '<S664>/IgnoreMicFlag'
     */
    // TSP advanced triggered capture for PreAmpAudiopilotIgnoreMicFlag '<S856>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 23, &Model_Target_ConstP.pooled111);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S865>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotAudiopilotBoostGain '<S865>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 10,
                    &Model_Target_B.audiopilot_boost_gain);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S866>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotDyneqBoostGain '<S866>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 14, &Model_Target_B.dyneq_boost_gain);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1084>/TSP' */
    // TSP advanced triggered capture for PreAmpLevelWatchAudiopilotEnvDb '<S1084>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 48, &Model_Target_B.audiopilot);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1085>/TSP' */
    // TSP advanced triggered capture for PreAmpLevelWatchAudiopilotLevelDbspl '<S1085>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 49,
                    &Model_Target_B.sf_InnerLink_p.level);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1097>/TSP' */
    // TSP advanced triggered capture for PreAmpLevelWatchDyneqEnvDb '<S1097>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 50, &Model_Target_B.dyneq);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1098>/TSP' */
    // TSP advanced triggered capture for PreAmpLevelWatchDyneqLevelDbspl '<S1098>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 51,
                    &Model_Target_B.sf_InnerLink_a.level);

#endif                                 //TSP_ENABLE_ADVANCED

    /* End of Update for SubSystem: '<S655>/AudioPilot35' */

    /* Update for Atomic SubSystem: '<S1137>/Medusa5H1 Part 3' */
    Model_Target_Medusa5H1Part3_Update();

    /* End of Update for SubSystem: '<S1137>/Medusa5H1 Part 3' */
}

/* Model step function for TID3 */
void Model_Target_step3(void)  /* Sample time: [0.0014444444444444444s, 0.0s] */
{
    int32_T bufferIndex;
    int32_T currentOffset;
    int32_T offsetFromMemBase;
    int32_T uyIdx;

    /* Outputs for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* Buffer: '<S965>/BufferRef' */
    for (bufferIndex = 0; bufferIndex < 64; bufferIndex++)
    {
        Model_Target_B.BufferRef[bufferIndex] =
            Model_Target_DW.BufferRef_CircBuf[Model_Target_DW.BufferRef_outBufPtrIdx
            + bufferIndex];
    }

    bufferIndex = Model_Target_DW.BufferRef_outBufPtrIdx + 64;
    if (Model_Target_DW.BufferRef_outBufPtrIdx + 64 == 128)
    {
        bufferIndex = 0;
    }

    Model_Target_DW.BufferRef_outBufPtrIdx = bufferIndex;

    /* End of Buffer: '<S965>/BufferRef' */
    /* MATLAB Function: '<S1019>/delay' incorporates:
     *  Buffer: '<S965>/BufferRef'
     *  Concatenate: '<S962>/Matrix Concatenate1'
     *  DownSample: '<S965>/DownsampleRef'
     */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'Delay/delay': '<S1020>:1' */
    /*  figure out the frame size and channel count */
    /* '<S1020>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S1020>:1:8' frameSize = int32(frameSize); */
    /* '<S1020>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S1020>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S1020>:1:11' delayTime = int32(delayTime); */
    /* '<S1020>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1020>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1020>:1:23' bufferIndex = delayIndex; */
    /* '<S1020>:1:25' for channel = 1:numChannels */
    /*  Save writeIndex for next channel */
    /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
    /*  up the registers before any buffer access */
    /* '<S1020>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
    /* '<S1020>:1:32' for sample = 1:frameSize */
    /*  overwrite oldest sample with the current input sample */
    /* '<S1020>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
    Model_Target_DW.delayBuffer_g[circindex(Model_Target_DW.delayIndex_k, 0, 70)]
        = Model_Target_B.BufferRef[0];

    /*  increment write pointer */
    /* '<S1020>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
    /*  Advance buffer index for next channel */
    /* '<S1020>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
    /*  Reset */
    /* '<S1020>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    bufferIndex = circindex(Model_Target_DW.delayIndex_k, 1, 70);

    /* '<S1020>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_k = bufferIndex;

    /*  Read samples from delay line */
    /* '<S1020>:1:50' for channel = 1:numChannels */
    /*  Setup read pointer */
    /* '<S1020>:1:53' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
    /* '<S1020>:1:55' for sample = 1:frameSize */
    /*  overwrite oldest sample with the current input sample */
    /* '<S1020>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
    Model_Target_B.MatrixConcatenate1[0] =
        Model_Target_DW.delayBuffer_g[circindex(bufferIndex,
        -(Model_Target_PreAmp0.AudiopilotLfNoiseRefLatencySamples + 1), 70)];

    /* Buffer: '<S965>/BufferMic' */
    /*  increment write pointer */
    /* '<S1020>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
    /*  Advance buffer index for next channel */
    /* '<S1020>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
    for (bufferIndex = 0; bufferIndex < 64; bufferIndex++)
    {
        Model_Target_B.BufferMic[bufferIndex] =
            Model_Target_DW.BufferMic_CircBuf[Model_Target_DW.BufferMic_outBufPtrIdx
            + bufferIndex];
    }

    currentOffset = Model_Target_DW.BufferMic_outBufPtrIdx + 64;
    if (Model_Target_DW.BufferMic_outBufPtrIdx + 64 == 128)
    {
        currentOffset = 0;
    }

    Model_Target_DW.BufferMic_outBufPtrIdx = currentOffset;

    /* End of Buffer: '<S965>/BufferMic' */

    /* DownSample: '<S965>/DownsampleMic' incorporates:
     *  Buffer: '<S965>/BufferMic'
     *  Concatenate: '<S962>/Matrix Concatenate1'
     */
    Model_Target_B.MatrixConcatenate1[1] = Model_Target_B.BufferMic[0];

    /* Buffer: '<S978>/Buffer' incorporates:
     *  Concatenate: '<S962>/Matrix Concatenate1'
     */
    currentOffset = 0;
    uyIdx = 1;
    offsetFromMemBase = Model_Target_DW.Buffer_inBufPtrIdx_g;
    if (Model_Target_DW.Buffer_inBufPtrIdx_g > 511)
    {
        currentOffset = 512 - Model_Target_DW.Buffer_inBufPtrIdx_g;
        offsetFromMemBase = 0;
        uyIdx = Model_Target_DW.Buffer_inBufPtrIdx_g - 511;
    }

    for (bufferIndex = 0; bufferIndex < uyIdx; bufferIndex++)
    {
        Model_Target_DW.Buffer_CircBuf_d[offsetFromMemBase + bufferIndex] =
            Model_Target_B.MatrixConcatenate1[currentOffset + bufferIndex];
    }

    currentOffset += uyIdx;
    uyIdx = 1;
    offsetFromMemBase = Model_Target_DW.Buffer_inBufPtrIdx_g + 512;
    if (Model_Target_DW.Buffer_inBufPtrIdx_g > 511)
    {
        currentOffset = (currentOffset - Model_Target_DW.Buffer_inBufPtrIdx_g) +
            512;
        offsetFromMemBase = 512;
        uyIdx = Model_Target_DW.Buffer_inBufPtrIdx_g - 511;
    }

    for (bufferIndex = 0; bufferIndex < uyIdx; bufferIndex++)
    {
        Model_Target_DW.Buffer_CircBuf_d[offsetFromMemBase + bufferIndex] =
            Model_Target_B.MatrixConcatenate1[currentOffset + bufferIndex];
    }

    Model_Target_DW.Buffer_inBufPtrIdx_g++;
    if (Model_Target_DW.Buffer_inBufPtrIdx_g >= 512)
    {
        Model_Target_DW.Buffer_inBufPtrIdx_g -= 512;
    }

    /* End of Buffer: '<S978>/Buffer' */
    /* End of Outputs for SubSystem: '<S655>/AudioPilot35' */
}

/* Model step function for TID4 */
void Model_Target_step4(void)  /* Sample time: [0.0028888888888888888s, 0.0s] */
{
    /* Outputs for Atomic SubSystem: '<S1137>/Medusa5H1 Part 2' */
    Model_Target_Medusa5H1Part2TID4();

    /* End of Outputs for SubSystem: '<S1137>/Medusa5H1 Part 2' */
}

/* Model step function for TID5 */
void Model_Target_step5(void)   /* Sample time: [0.011555555555555555s, 0.0s] */
{
    /* Outputs for Atomic SubSystem: '<S1137>/Medusa5H1 Part 2' */
    Model_Target_Medusa5H1Part2TID5();

    /* End of Outputs for SubSystem: '<S1137>/Medusa5H1 Part 2' */
}

/* Model step function for TID6 */
void Model_Target_step6(void)    /* Sample time: [0.04622222222222222s, 0.0s] */
{
    creal32_T tmp[65];
    creal32_T a[25];
    creal32_T a_0;
    int32_T br_tmp;
    int32_T chan1Idx;
    int32_T iDelta;
    int32_T iheight;
    int32_T istart;
    int32_T ix;
    int32_T iy;
    int32_T ju;
    int32_T k;
    real32_T IRGlobalMin[65];
    real32_T b_x_data[65];
    real32_T rtb_u_h[65];
    real32_T Slew;
    real32_T X2_im;
    real32_T temp_im;
    real32_T temp_re;
    real32_T twid_im;
    real32_T twid_re;
    boolean_T tst;
    static const real32_T b[129] =
    {
        1.0F, 0.999698818F, 0.99879545F, 0.997290432F, 0.99518472F, 0.992479563F,
        0.989176512F, 0.985277653F, 0.980785251F, 0.975702107F, 0.970031261F,
        0.963776052F, 0.956940353F, 0.949528158F, 0.941544056F, 0.932992816F,
        0.923879504F, 0.914209723F, 0.903989315F, 0.893224299F, 0.881921232F,
        0.870086968F, 0.857728601F, 0.84485358F, 0.831469595F, 0.817584813F,
        0.803207517F, 0.78834641F, 0.773010433F, 0.757208824F, 0.740951121F,
        0.724247098F, 0.707106769F, 0.689540565F, 0.671559F, 0.653172851F,
        0.634393334F, 0.615231633F, 0.59569931F, 0.575808227F, 0.555570245F,
        0.534997642F, 0.514102757F, 0.492898226F, 0.471396744F, 0.449611336F,
        0.427555084F, 0.40524134F, 0.382683456F, 0.359895051F, 0.336889863F,
        0.313681751F, 0.290284663F, 0.266712785F, 0.242980197F, 0.219101235F,
        0.195090324F, 0.170961902F, 0.146730468F, 0.122410677F, 0.0980171412F,
        0.0735645667F, 0.0490676761F, 0.024541229F, 0.0F, -0.024541229F,
        -0.0490676761F, -0.0735645667F, -0.0980171412F, -0.122410677F,
        -0.146730468F, -0.170961902F, -0.195090324F, -0.219101235F,
        -0.242980197F, -0.266712785F, -0.290284663F, -0.313681751F,
        -0.336889863F, -0.359895051F, -0.382683456F, -0.40524134F, -0.427555084F,
        -0.449611336F, -0.471396744F, -0.492898226F, -0.514102757F,
        -0.534997642F, -0.555570245F, -0.575808227F, -0.59569931F, -0.615231633F,
        -0.634393334F, -0.653172851F, -0.671559F, -0.689540565F, -0.707106769F,
        -0.724247098F, -0.740951121F, -0.757208824F, -0.773010433F, -0.78834641F,
        -0.803207517F, -0.817584813F, -0.831469595F, -0.84485358F, -0.857728601F,
        -0.870086968F, -0.881921232F, -0.893224299F, -0.903989315F,
        -0.914209723F, -0.923879504F, -0.932992816F, -0.941544056F,
        -0.949528158F, -0.956940353F, -0.963776052F, -0.970031261F,
        -0.975702107F, -0.980785251F, -0.985277653F, -0.989176512F,
        -0.992479563F, -0.99518472F, -0.997290432F, -0.99879545F, -0.999698818F,
        -1.0F
    };

    static const real32_T c[129] =
    {
        0.0F, -0.024541229F, -0.0490676761F, -0.0735645667F, -0.0980171412F,
        -0.122410677F, -0.146730468F, -0.170961902F, -0.195090324F,
        -0.219101235F, -0.242980197F, -0.266712785F, -0.290284663F,
        -0.313681751F, -0.336889863F, -0.359895051F, -0.382683456F, -0.40524134F,
        -0.427555084F, -0.449611336F, -0.471396744F, -0.492898226F,
        -0.514102757F, -0.534997642F, -0.555570245F, -0.575808227F, -0.59569931F,
        -0.615231633F, -0.634393334F, -0.653172851F, -0.671559F, -0.689540565F,
        -0.707106769F, -0.724247098F, -0.740951121F, -0.757208824F,
        -0.773010433F, -0.78834641F, -0.803207517F, -0.817584813F, -0.831469595F,
        -0.84485358F, -0.857728601F, -0.870086968F, -0.881921232F, -0.893224299F,
        -0.903989315F, -0.914209723F, -0.923879504F, -0.932992816F,
        -0.941544056F, -0.949528158F, -0.956940353F, -0.963776052F,
        -0.970031261F, -0.975702107F, -0.980785251F, -0.985277653F,
        -0.989176512F, -0.992479563F, -0.99518472F, -0.997290432F, -0.99879545F,
        -0.999698818F, -1.0F, -0.999698818F, -0.99879545F, -0.997290432F,
        -0.99518472F, -0.992479563F, -0.989176512F, -0.985277653F, -0.980785251F,
        -0.975702107F, -0.970031261F, -0.963776052F, -0.956940353F,
        -0.949528158F, -0.941544056F, -0.932992816F, -0.923879504F,
        -0.914209723F, -0.903989315F, -0.893224299F, -0.881921232F,
        -0.870086968F, -0.857728601F, -0.84485358F, -0.831469595F, -0.817584813F,
        -0.803207517F, -0.78834641F, -0.773010433F, -0.757208824F, -0.740951121F,
        -0.724247098F, -0.707106769F, -0.689540565F, -0.671559F, -0.653172851F,
        -0.634393334F, -0.615231633F, -0.59569931F, -0.575808227F, -0.555570245F,
        -0.534997642F, -0.514102757F, -0.492898226F, -0.471396744F,
        -0.449611336F, -0.427555084F, -0.40524134F, -0.382683456F, -0.359895051F,
        -0.336889863F, -0.313681751F, -0.290284663F, -0.266712785F,
        -0.242980197F, -0.219101235F, -0.195090324F, -0.170961902F,
        -0.146730468F, -0.122410677F, -0.0980171412F, -0.0735645667F,
        -0.0490676761F, -0.024541229F, -0.0F
    };

    creal32_T *rtb_Selector_e_0;

    /* Outputs for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* Buffer: '<S901>/Buffer' */
    br_tmp = 0;
    for (chan1Idx = 0; chan1Idx < 6; chan1Idx++)
    {
        ix = Model_Target_DW.Buffer_outBufPtrIdx_d - 128;
        if (Model_Target_DW.Buffer_outBufPtrIdx_d - 128 < 0)
        {
            ix = Model_Target_DW.Buffer_outBufPtrIdx_d + 384;
        }

        ju = 256;
        if (ix > 256)
        {
            iy = (chan1Idx << 9) + ix;
            for (iDelta = 0; iDelta < 512 - ix; iDelta++)
            {
                Model_Target_B.u_i[br_tmp + iDelta] =
                    Model_Target_DW.Buffer_CircBuf_c[iy + iDelta];
            }

            br_tmp = (br_tmp - ix) + 512;
            ju = ix - 256;
            ix = 0;
        }

        iy = (chan1Idx << 9) + ix;
        for (iDelta = 0; iDelta < ju; iDelta++)
        {
            Model_Target_B.u_i[br_tmp + iDelta] =
                Model_Target_DW.Buffer_CircBuf_c[iy + iDelta];
        }

        br_tmp += ju;
        ix += ju;
    }

    if (ix == 512)
    {
        ix = 0;
    }

    Model_Target_DW.Buffer_outBufPtrIdx_d = ix;

    /* End of Buffer: '<S901>/Buffer' */

    /* MATLAB Function: '<S902>/Windowing' incorporates:
     *  Constant: '<S901>/const'
     */
    /*  Get sizes */
    /* MATLAB Function 'RfftWindowing/Windowing': '<S904>:1' */
    /* '<S904>:1:4' [~, numChannels] = size(u); */
    /*  Loop since array-vector multiply operation doesn't work here */
    /*  Input/Output have the same variable name for in-place processing */
    /* '<S904>:1:8' for i = 1:numChannels */
    for (iDelta = 0; iDelta < 6; iDelta++)
    {
        /* '<S904>:1:9' u(:, i) = u(:,i) .* win; */
        for (br_tmp = 0; br_tmp < 256; br_tmp++)
        {
            ix = (iDelta << 8) + br_tmp;
            Model_Target_B.u_i[ix] *= Model_Target_ConstP.pooled66[br_tmp];
        }
    }

    /* End of MATLAB Function: '<S902>/Windowing' */

    /* MATLAB Function: '<S906>/MATLAB Function1' */
    /* MATLAB Function 'Rfft/Rfft/Generic/MATLAB Function1': '<S907>:1' */
    /* '<S907>:1:3' y = RfftProcessSim(u, fftSize); */
    /*  Calculates the FFT of a purely real input signal. Uses an optimized 2 for */
    /*  1 Rfft algorithm.  */
    /*  Inputs: */
    /*        u: input of size (fftSize x numChannels) */
    /*        fftSize: Size of FFT */
    /*  Output: */
    /*        y: array of size (fftSize/2 + 1 x numChannels) number of unique FFT */
    /*            coefficients of the input */
    /* -------------------------------------------------------------------------- */
    /*  Function for simulation */
    /* 'RfftProcessSim:14' half_spectrum_size = (fftSize/2) + 1; */
    /* 'RfftProcessSim:15' numChannels = size(u,2); */
    /* 'RfftProcessSim:16' numChannelPairs = floor(numChannels/2); */
    /* 'RfftProcessSim:17' extraChannel = numChannels - numChannelPairs*2; */
    /*  Initialize output */
    /* 'RfftProcessSim:21' y = single(complex(zeros(half_spectrum_size,size(u,2)))); */
    /*  Calculate 2 Channel Real FFT for every channel pair */
    /* 'RfftProcessSim:24' for pairIdx = 1: numChannelPairs */
    for (br_tmp = 0; br_tmp < 3; br_tmp++)
    {
        /* 'RfftProcessSim:25' chan1Idx = pairIdx*2-1; */
        chan1Idx = ((br_tmp + 1) << 1) - 1;

        /* 'RfftProcessSim:26' chan2Idx = chan1Idx + 1; */
        /* 'RfftProcessSim:27' [X1, X2] = Rfft2ChanProcessSim(u(:,chan1Idx), u(:,chan2Idx), fftSize); */
        /*  Computes the Real FFT of a Two Channel Signal.  */
        /*  This is the Generic C Variant. */
        /*  Computation of Two Real FFTs is done using a single complex FFT. */
        /*  Channel 1 is loaded into the real part and Channel 2 into imag. */
        /*  Complex FFT is computed. */
        /*  FFT of channel 1 is extracted as the conjugate symmetric part  */
        /*  FFT of channel 3 is extracted as the conjugate anti-symmetric part . */
        /*  Inputs: */
        /*      x1 - purely real channel 1  */
        /*      x2 - purely real channel 2 */
        /*      fftSize - length of x1 and x2. Also the size of FFT/ */
        /*  Outputs: */
        /*      X1 - FFT of x1 */
        /*      X2 - FFT of x2 */
        /*  ------------------------------------------------------------------------- */
        /*  Output size equal to number of independent FFT coefficients */
        /* 'Rfft2ChanProcessSim:19' half_spectrum_size = (fftSize/2) + 1; */
        /*  Compute Complex FFT */
        /* 'Rfft2ChanProcessSim:22' X = fft(complex(x1, x2)); */
        for (k = 0; k < 256; k++)
        {
            Model_Target_B.x_k[k].re = Model_Target_B.u_i[((chan1Idx - 1) << 8)
                + k];
            Model_Target_B.x_k[k].im = Model_Target_B.u_i[(chan1Idx << 8) + k];
        }

        iy = 0;
        ju = 0;
        for (iDelta = 0; iDelta < 255; iDelta++)
        {
            Model_Target_B.X_c[iy] = Model_Target_B.x_k[iDelta];
            iy = 256;
            tst = true;
            while (tst)
            {
                iy >>= 1;
                ju ^= iy;
                tst = ((ju & iy) == 0);
            }

            iy = ju;
        }

        Model_Target_B.X_c[iy] = Model_Target_B.x_k[255];
        for (k = 0; k <= 254; k += 2)
        {
            temp_re = Model_Target_B.X_c[k + 1].re;
            temp_im = Model_Target_B.X_c[k + 1].im;
            Model_Target_B.X_c[k + 1].re = Model_Target_B.X_c[k].re -
                Model_Target_B.X_c[k + 1].re;
            Model_Target_B.X_c[k + 1].im = Model_Target_B.X_c[k].im -
                Model_Target_B.X_c[k + 1].im;
            Model_Target_B.X_c[k].re += temp_re;
            Model_Target_B.X_c[k].im += temp_im;
        }

        iDelta = 2;
        iy = 4;
        k = 64;
        iheight = 253;
        while (k > 0)
        {
            int32_T temp_re_tmp;
            for (ix = 0; ix < iheight; ix += iy)
            {
                temp_re_tmp = ix + iDelta;
                temp_re = Model_Target_B.X_c[temp_re_tmp].re;
                temp_im = Model_Target_B.X_c[temp_re_tmp].im;
                Model_Target_B.X_c[temp_re_tmp].re = Model_Target_B.X_c[ix].re -
                    temp_re;
                Model_Target_B.X_c[temp_re_tmp].im = Model_Target_B.X_c[ix].im -
                    temp_im;
                Model_Target_B.X_c[ix].re += temp_re;
                Model_Target_B.X_c[ix].im += temp_im;
            }

            istart = 1;
            for (ju = k; ju < 128; ju += k)
            {
                int32_T ihi;
                twid_re = b[ju];
                twid_im = c[ju];
                ix = istart;
                ihi = istart + iheight;
                while (ix < ihi)
                {
                    temp_re_tmp = ix + iDelta;
                    temp_im = Model_Target_B.X_c[temp_re_tmp].im;
                    Slew = Model_Target_B.X_c[temp_re_tmp].re;
                    temp_re = Slew * twid_re - temp_im * twid_im;
                    temp_im = temp_im * twid_re + Slew * twid_im;
                    Model_Target_B.X_c[temp_re_tmp].re = Model_Target_B.X_c[ix].
                        re - temp_re;
                    Model_Target_B.X_c[temp_re_tmp].im = Model_Target_B.X_c[ix].
                        im - temp_im;
                    Model_Target_B.X_c[ix].re += temp_re;
                    Model_Target_B.X_c[ix].im += temp_im;
                    ix += iy;
                }

                istart++;
            }

            k /= 2;
            iDelta = iy;
            iy += iy;
            iheight -= iDelta;
        }

        /*  Temporary variable for calculating outputs */
        /* 'Rfft2ChanProcessSim:25' Z = conj(circshift(flip(X),1)); */
        memcpy(&Model_Target_B.x_k[0], &Model_Target_B.X_c[0], sizeof(creal32_T)
               << 8U);
        for (ix = 0; ix < 128; ix++)
        {
            temp_re = Model_Target_B.x_k[ix].re;
            temp_im = Model_Target_B.x_k[ix].im;
            Model_Target_B.x_k[ix] = Model_Target_B.x_k[255 - ix];
            Model_Target_B.x_k[255 - ix].re = temp_re;
            Model_Target_B.x_k[255 - ix].im = temp_im;
        }

        memcpy(&Model_Target_B.a_c[0], &Model_Target_B.x_k[0], sizeof(creal32_T)
               << 8U);
        for (ix = 254; ix >= 0; ix--)
        {
            Model_Target_B.a_c[ix + 1] = Model_Target_B.a_c[ix];
        }

        Model_Target_B.a_c[0] = Model_Target_B.x_k[255];

        /*  % Nullcopy copies type, size, and complexity to output */
        /* 'Rfft2ChanProcessSim:28' X1 = complex(single(zeros(half_spectrum_size, 1))); */
        /* 'Rfft2ChanProcessSim:29' X2 = complex(single(zeros(half_spectrum_size, 1))); */
        /*  Apply FFT properties of symmetry to extract FFT of even and imag channel */
        /* 'Rfft2ChanProcessSim:32' X1(1:half_spectrum_size) = (X(1:half_spectrum_size) + Z(1:half_spectrum_size))/2; */
        /* 'Rfft2ChanProcessSim:33' X2(1:half_spectrum_size) = (X(1:half_spectrum_size) - Z(1:half_spectrum_size))/2j; */
        /* 'RfftProcessSim:28' y(:,chan1Idx)   = X1(:); */
        /* 'RfftProcessSim:29' y(:,chan2Idx)   = X2(:); */
        for (iDelta = 0; iDelta < 129; iDelta++)
        {
            temp_re = Model_Target_B.X_c[iDelta].re;
            twid_im = Model_Target_B.X_c[iDelta].im;
            Slew = Model_Target_B.a_c[iDelta].re;
            X2_im = -Model_Target_B.a_c[iDelta].im;
            temp_im = temp_re + Slew;
            twid_re = twid_im + X2_im;
            if (twid_re == 0.0F)
            {
                k = (chan1Idx - 1) * 129 + iDelta;
                Model_Target_B.y_d[k].re = qhmath_div_f(temp_im, 2.0F);
                Model_Target_B.y_d[k].im = 0.0F;
            }
            else if (temp_im == 0.0F)
            {
                k = (chan1Idx - 1) * 129 + iDelta;
                Model_Target_B.y_d[k].re = 0.0F;
                Model_Target_B.y_d[k].im = qhmath_div_f(twid_re, 2.0F);
            }
            else
            {
                k = (chan1Idx - 1) * 129 + iDelta;
                Model_Target_B.y_d[k].re = qhmath_div_f(temp_im, 2.0F);
                Model_Target_B.y_d[k].im = qhmath_div_f(twid_re, 2.0F);
            }

            temp_im = temp_re - Slew;
            twid_re = twid_im - X2_im;
            if (temp_im == 0.0F)
            {
                k = 129 * chan1Idx + iDelta;
                Model_Target_B.y_d[k].re = qhmath_div_f(twid_re, 2.0F);
                Model_Target_B.y_d[k].im = 0.0F;
            }
            else if (twid_re == 0.0F)
            {
                k = 129 * chan1Idx + iDelta;
                Model_Target_B.y_d[k].re = 0.0F;
                Model_Target_B.y_d[k].im = -qhmath_div_f(temp_im, 2.0F);
            }
            else
            {
                k = 129 * chan1Idx + iDelta;
                Model_Target_B.y_d[k].re = qhmath_div_f(twid_re, 2.0F);
                Model_Target_B.y_d[k].im = -qhmath_div_f(temp_im, 2.0F);
            }
        }
    }

    /* End of MATLAB Function: '<S906>/MATLAB Function1' */

    /* Selector: '<S900>/Selector' */
    /*  if numChannels is odd, there is an extra channel, Calculate RFFT normally */
    /* 'RfftProcessSim:33' if extraChannel == 1 */
    rtb_Selector_e_0 = &Model_Target_B.y_d[0];

    /* MATLAB Function: '<S883>/FormCoherenceMatrixGXY' incorporates:
     *  Constant: '<S883>/Constant1'
     *  Selector: '<S900>/Selector'
     */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /FormCoherenceMatrixGXY': '<S888>:1' */
    /* '<S888>:1:3' K = HFWELCHSIZE; */
    /*  K: size of Welch window */
    /* '<S888>:1:4' L = ceil(size(StftIn,1)/2); */
    /*  L: number frequency bins */
    /* '<S888>:1:5' M = size(StftIn,2); */
    /*  M: mic + number of ref channels */
    /*  Initialize states */
    /* '<S888>:1:11' if isempty(GXY) */
    /* '<S888>:1:14' if isempty(frame_counter) */
    /*  Modulo K Counter */
    /* '<S888>:1:19' if frame_counter < K */
    if (Model_Target_DW.frame_counter < 16)
    {
        /*  frame counter increment */
        /* '<S888>:1:21' frame_counter = frame_counter + int16(1); */
        Model_Target_DW.frame_counter++;
    }
    else
    {
        /* '<S888>:1:22' else */
        /*  reset frame counter */
        /* '<S888>:1:24' frame_counter = int16(1); */
        Model_Target_DW.frame_counter = 1;
    }

    /* '<S888>:1:28' if frame_counter < K */
    if (Model_Target_DW.frame_counter < 16)
    {
        /*  Reset at the first frame */
        /* '<S888>:1:30' if frame_counter == 1 */
        if (Model_Target_DW.frame_counter == 1)
        {
            /* '<S888>:1:31' GXY = complex(single(zeros(L,M,M))); */
            memset(&Model_Target_DW.GXY[0], 0, 1625U * sizeof(creal32_T));
        }

        /*  Accumulate */
        /* '<S888>:1:34' for i = 1:M */
        for (iDelta = 0; iDelta < 5; iDelta++)
        {
            /* '<S888>:1:35' for j = i:M */
            iy = 4 - iDelta;
            for (br_tmp = 0; br_tmp <= iy; br_tmp++)
            {
                ju = iDelta + br_tmp;

                /*  Loop over the lower triangular matrix (including the diagonal) */
                /* '<S888>:1:37' EXY = (conj((2*StftIn(1:2:end,i)))) .* (2*StftIn(1:2:end,j)); */
                /* '<S888>:1:38' GXY(:,i,j) = GXY(:,i,j)+ EXY/K; */
                for (k = 0; k < 65; k++)
                {
                    iheight = k << 1;
                    istart = 129 * iDelta + iheight;
                    temp_re = rtb_Selector_e_0[istart].re * 2.0F;
                    temp_im = -(rtb_Selector_e_0[istart].im * 2.0F);
                    ix = 129 * ju + iheight;
                    twid_re = rtb_Selector_e_0[ix].re * 2.0F;
                    twid_im = rtb_Selector_e_0[ix].im * 2.0F;
                    Slew = temp_re * twid_re - temp_im * twid_im;
                    temp_im = temp_re * twid_im + temp_im * twid_re;
                    if (temp_im == 0.0F)
                    {
                        temp_re = qhmath_div_f(Slew, 16.0F);
                        temp_im = 0.0F;
                    }
                    else if (Slew == 0.0F)
                    {
                        temp_re = 0.0F;
                        temp_im = qhmath_div_f(temp_im, 16.0F);
                    }
                    else
                    {
                        temp_re = qhmath_div_f(Slew, 16.0F);
                        temp_im = qhmath_div_f(temp_im, 16.0F);
                    }

                    chan1Idx = (65 * iDelta + k) + 325 * ju;
                    tmp[k].re = Model_Target_DW.GXY[chan1Idx].re + temp_re;
                    tmp[k].im = Model_Target_DW.GXY[chan1Idx].im + temp_im;
                }

                memcpy(&Model_Target_DW.GXY[iDelta * 65 + ju * 325], &tmp[0],
                       65U * sizeof(creal32_T));
            }
        }

        /* '<S888>:1:41' GnnUpdate = false; */
        tst = false;
    }
    else
    {
        /* '<S888>:1:42' else */
        /*  Last Frame */
        /* '<S888>:1:44' for i = 1:M */
        for (ix = 0; ix < 5; ix++)
        {
            /* '<S888>:1:45' for j = i:M */
            chan1Idx = 4 - ix;
            for (iDelta = 0; iDelta <= chan1Idx; iDelta++)
            {
                ju = ix + iDelta;

                /*  Loop over the lower triangular matrix (including the diagonal) */
                /* '<S888>:1:47' EXY = (conj((2*StftIn(1:2:end,i)))) .* (2*StftIn(1:2:end,j)); */
                /* '<S888>:1:48' GXY(:,i,j) = GXY(:,i,j)+ EXY/K; */
                for (br_tmp = 0; br_tmp < 65; br_tmp++)
                {
                    iheight = br_tmp << 1;
                    istart = 129 * ix + iheight;
                    temp_re = rtb_Selector_e_0[istart].re * 2.0F;
                    temp_im = -(rtb_Selector_e_0[istart].im * 2.0F);
                    istart = 129 * ju + iheight;
                    twid_re = rtb_Selector_e_0[istart].re * 2.0F;
                    twid_im = rtb_Selector_e_0[istart].im * 2.0F;
                    Slew = temp_re * twid_re - temp_im * twid_im;
                    temp_im = temp_re * twid_im + temp_im * twid_re;
                    if (temp_im == 0.0F)
                    {
                        temp_re = qhmath_div_f(Slew, 16.0F);
                        temp_im = 0.0F;
                    }
                    else if (Slew == 0.0F)
                    {
                        temp_re = 0.0F;
                        temp_im = qhmath_div_f(temp_im, 16.0F);
                    }
                    else
                    {
                        temp_re = qhmath_div_f(Slew, 16.0F);
                        temp_im = qhmath_div_f(temp_im, 16.0F);
                    }

                    k = (65 * ix + br_tmp) + 325 * ju;
                    tmp[br_tmp].re = Model_Target_DW.GXY[k].re + temp_re;
                    tmp[br_tmp].im = Model_Target_DW.GXY[k].im + temp_im;
                }

                memcpy(&Model_Target_DW.GXY[ix * 65 + ju * 325], &tmp[0], 65U *
                       sizeof(creal32_T));
            }

            /* '<S888>:1:50' for j = 1:i-1 */
            for (br_tmp = 0; br_tmp < ix; br_tmp++)
            {
                /*  Construct full matrix when Welch window size is met */
                /* '<S888>:1:52' GXY(:,i,j) = conj(GXY(:,j,i)); */
                for (k = 0; k < 65; k++)
                {
                    chan1Idx = (65 * br_tmp + k) + 325 * ix;
                    tmp[k].re = Model_Target_DW.GXY[chan1Idx].re;
                    tmp[k].im = -Model_Target_DW.GXY[chan1Idx].im;
                }

                memcpy(&Model_Target_DW.GXY[ix * 65 + br_tmp * 325], &tmp[0],
                       65U * sizeof(creal32_T));
            }
        }

        /* '<S888>:1:55' GnnUpdate = true; */
        tst = true;
    }

    /* S-Function (TOP_MEX): '<S893>/RefPowerMin' */
    /* '<S888>:1:57' GXYOut = GXY; */
    /* If: '<S889>/If' incorporates:
     *  MATLAB Function: '<S883>/FormCoherenceMatrixGXY'
     */
    if (tst)
    {
        /* Outputs for IfAction SubSystem: '<S889>/If Action Subsystem' incorporates:
         *  ActionPort: '<S894>/Action Port'
         */
        /*  global GXY; */
        /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /GaussianElimination/If Action Subsystem/GaussianElimination': '<S897>:1' */
        /* '<S897>:1:6' u = GXY; */
        /* '<S897>:1:7' M = size(u,1); */
        /*  Number of frequency bins */
        /* '<S897>:1:8' N = size(u,2); */
        /*  Size of coherence matrix */
        /*  Vectors of Noise */
        /* '<S897>:1:11' c = single(zeros(M,1)); */
        /* '<S897>:1:12' Gyy = real(u(:,N,N)); */
        /* '<S897>:1:14' for i = 1:M */
        /*  For coherence that is higher than threshold (meaning noise is low), we will enhance it to avoid */
        /*  overestimation at low noise level */
        /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /GaussianElimination/If Action Subsystem/CoherenceModifier': '<S896>:1' */
        /* '<S896>:1:5' N = length(u); */
        /* '<S896>:1:6' threshold = 0.88; */
        /* y = u; */
        /* '<S896>:1:8' for i = 1:N */
        for (iDelta = 0; iDelta < 65; iDelta++)
        {
            /* MATLAB Function: '<S894>/GaussianElimination' */
            /*  Loop over each frequency bin */
            /* '<S897>:1:16' S_data = squeeze(u(i,:,:)); */
            /* '<S897>:1:17' S_mod = GaussianElim(S_data); */
            for (br_tmp = 0; br_tmp < 5; br_tmp++)
            {
                for (k = 0; k < 5; k++)
                {
                    a[k + 5 * br_tmp] = Model_Target_DW.GXY[(65 * k + iDelta) +
                        325 * br_tmp];
                }
            }

            /*  This function performs Gaussian elimination  */
            /*  on a cross-correlation matrix, a.  */
            /* '<S897>:1:31' temp = a; */
            /* '<S897>:1:32' m = size(a,1); */
            /* '<S897>:1:33' for j =1:m-1 */
            for (ju = 0; ju < 4; ju++)
            {
                /* '<S897>:1:34' for i = j+1:m */
                iy = 3 - ju;
                for (k = 0; k <= iy; k++)
                {
                    boolean_T guard1 = false;
                    boolean_T guard2 = false;
                    ix = (ju + k) + 1;

                    /* '<S897>:1:35' if ((j>1) && abs(a(j,j)/temp(j,j)) > 0.001) || ((j==1) && abs(a(j,j))>eps) */
                    guard1 = false;
                    guard2 = false;
                    if (ju + 1 > 1)
                    {
                        chan1Idx = ju * 5 + ju;
                        temp_im = a[chan1Idx].re;
                        twid_re = a[chan1Idx].im;
                        br_tmp = (chan1Idx % 5 * 65 + iDelta) + chan1Idx / 5 *
                            325;
                        X2_im = Model_Target_DW.GXY[br_tmp].re;
                        twid_im = Model_Target_DW.GXY[br_tmp].im;
                        if (twid_im == 0.0F)
                        {
                            if (twid_re == 0.0F)
                            {
                                temp_re = qhmath_div_f(temp_im, X2_im);
                                temp_im = 0.0F;
                            }
                            else if (temp_im == 0.0F)
                            {
                                temp_re = 0.0F;
                                temp_im = qhmath_div_f(twid_re, X2_im);
                            }
                            else
                            {
                                temp_re = qhmath_div_f(temp_im, X2_im);
                                temp_im = qhmath_div_f(twid_re, X2_im);
                            }
                        }
                        else if (X2_im == 0.0F)
                        {
                            if (temp_im == 0.0F)
                            {
                                temp_re = qhmath_div_f(twid_re, twid_im);
                                temp_im = 0.0F;
                            }
                            else if (twid_re == 0.0F)
                            {
                                temp_re = 0.0F;
                                temp_im = -qhmath_div_f(temp_im, twid_im);
                            }
                            else
                            {
                                temp_re = qhmath_div_f(twid_re, twid_im);
                                temp_im = -qhmath_div_f(temp_im, twid_im);
                            }
                        }
                        else
                        {
                            Slew = qhmath_abs_f(X2_im);
                            temp_re = qhmath_abs_f(twid_im);
                            if (Slew > temp_re)
                            {
                                Slew = qhmath_div_f(twid_im, X2_im);
                                twid_im = Slew * twid_im + X2_im;
                                temp_re = qhmath_div_f(Slew * twid_re + temp_im,
                                                       twid_im);
                                temp_im = qhmath_div_f(twid_re - Slew * temp_im,
                                                       twid_im);
                            }
                            else if (temp_re == Slew)
                            {
                                X2_im = X2_im > 0.0F ? 0.5F : -0.5F;
                                twid_im = twid_im > 0.0F ? 0.5F : -0.5F;
                                temp_re = qhmath_div_f(temp_im * X2_im + twid_re
                                                       * twid_im, Slew);
                                temp_im = qhmath_div_f(twid_re * X2_im - temp_im
                                                       * twid_im, Slew);
                            }
                            else
                            {
                                Slew = qhmath_div_f(X2_im, twid_im);
                                twid_im += Slew * X2_im;
                                temp_re = qhmath_div_f(Slew * temp_im + twid_re,
                                                       twid_im);
                                temp_im = qhmath_div_f(Slew * twid_re - temp_im,
                                                       twid_im);
                            }
                        }

                        if (qhmath_hypot_f(temp_re, temp_im) > 0.001)
                        {
                            guard1 = true;
                        }
                        else
                        {
                            guard2 = true;
                        }
                    }
                    else
                    {
                        guard2 = true;
                    }

                    if (guard2)
                    {
                        if (ju + 1 == 1)
                        {
                            br_tmp = 5 * ju + ju;
                            if (qhmath_hypot_f(a[br_tmp].re, a[br_tmp].im) >
                                    2.22044605E-16F)
                            {
                                guard1 = true;
                            }
                        }
                    }

                    if (guard1)
                    {
                        /*  starting from 2nd row, if the conditioned psd is close to */
                        /*  zero, we should skip using this row for the next elimination */
                        /*  operation; similarly if the first input (G11) is zero, we */
                        /*  should skip using the first row */
                        /* '<S897>:1:41' mult = a(i,j)/a(j,j); */
                        br_tmp = 5 * ju + ix;
                        temp_im = a[br_tmp].re;
                        twid_re = a[br_tmp].im;
                        X2_im = a[5 * ju + ju].re;
                        twid_im = a[5 * ju + ju].im;
                        if (twid_im == 0.0F)
                        {
                            if (twid_re == 0.0F)
                            {
                                temp_re = qhmath_div_f(temp_im, X2_im);
                                temp_im = 0.0F;
                            }
                            else if (temp_im == 0.0F)
                            {
                                temp_re = 0.0F;
                                temp_im = qhmath_div_f(twid_re, X2_im);
                            }
                            else
                            {
                                temp_re = qhmath_div_f(temp_im, X2_im);
                                temp_im = qhmath_div_f(twid_re, X2_im);
                            }
                        }
                        else if (X2_im == 0.0F)
                        {
                            if (temp_im == 0.0F)
                            {
                                temp_re = qhmath_div_f(twid_re, twid_im);
                                temp_im = 0.0F;
                            }
                            else if (twid_re == 0.0F)
                            {
                                temp_re = 0.0F;
                                temp_im = -qhmath_div_f(temp_im, twid_im);
                            }
                            else
                            {
                                temp_re = qhmath_div_f(twid_re, twid_im);
                                temp_im = -qhmath_div_f(temp_im, twid_im);
                            }
                        }
                        else
                        {
                            Slew = qhmath_abs_f(X2_im);
                            temp_re = qhmath_abs_f(twid_im);
                            if (Slew > temp_re)
                            {
                                Slew = qhmath_div_f(twid_im, X2_im);
                                twid_im = Slew * twid_im + X2_im;
                                temp_re = qhmath_div_f(Slew * twid_re + temp_im,
                                                       twid_im);
                                temp_im = qhmath_div_f(twid_re - Slew * temp_im,
                                                       twid_im);
                            }
                            else if (temp_re == Slew)
                            {
                                X2_im = X2_im > 0.0F ? 0.5F : -0.5F;
                                twid_im = twid_im > 0.0F ? 0.5F : -0.5F;
                                temp_re = qhmath_div_f(temp_im * X2_im + twid_re
                                                       * twid_im, Slew);
                                temp_im = qhmath_div_f(twid_re * X2_im - temp_im
                                                       * twid_im, Slew);
                            }
                            else
                            {
                                Slew = qhmath_div_f(X2_im, twid_im);
                                twid_im += Slew * X2_im;
                                temp_re = qhmath_div_f(Slew * temp_im + twid_re,
                                                       twid_im);
                                temp_im = qhmath_div_f(Slew * twid_re - temp_im,
                                                       twid_im);
                            }
                        }

                        /* '<S897>:1:42' a(i,:) = a(i,:)-a(j,:)*mult; */
                        for (br_tmp = 0; br_tmp < 5; br_tmp++)
                        {
                            chan1Idx = 5 * br_tmp + ju;
                            iheight = 5 * br_tmp + ix;
                            twid_re = a[chan1Idx].re;
                            twid_im = a[chan1Idx].im;
                            a_0.re = a[iheight].re - (twid_re * temp_re -
                                twid_im * temp_im);
                            a_0.im = a[iheight].im - (twid_re * temp_im +
                                twid_im * temp_re);
                            a[iheight] = a_0;
                        }
                    }
                }
            }

            /* '<S897>:1:46' b = a; */
            /* '<S897>:1:18' Snn_Gauss = S_mod(N,N); */
            /* Gnn(i) = real(Snn_Gauss); */
            /* '<S897>:1:20' if S_data(N,N) > eps */
            if (Model_Target_DW.GXY[iDelta + 1560].re > 2.22044605E-16F)
            {
                /* '<S897>:1:21' c(i) = 1-real(Snn_Gauss)/real(S_data(N,N)); */
                temp_im = 1.0F - qhmath_div_f(a[24].re,
                    Model_Target_DW.GXY[iDelta + 1560].re);
            }
            else
            {
                /* '<S897>:1:22' else */
                /* '<S897>:1:23' c(i) = 1; */
                temp_im = 1.0F;
            }

            /* MATLAB Function: '<S894>/CoherenceModifier' */
            /* '<S896>:1:9' if u(i) > threshold */
            if (temp_im > 0.88)
            {
                /* '<S896>:1:10' u(i) = sqrt((u(i)-threshold)*(1-threshold)) + threshold; */
                temp_im = qhmath_sqrt_f((temp_im - 0.88F) * 0.12F) + 0.88F;
            }

            /* End of MATLAB Function: '<S894>/CoherenceModifier' */

            /* Merge: '<S889>/Merge' incorporates:
             *  Constant: '<S894>/Constant'
             *  MATLAB Function: '<S894>/GaussianElimination'
             *  MinMax: '<S894>/FloorValue'
             *  Product: '<S894>/Product1'
             *  Sum: '<S894>/Subtract1'
             */
            Model_Target_B.Merge_a[iDelta] = fmaxf((1.0F - temp_im) *
                Model_Target_DW.GXY[iDelta + 1560].re,
                Model_Target_PreAmp0.AudiopilotHfNoiseRefPowerMin);
        }

        /* End of Outputs for SubSystem: '<S889>/If Action Subsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S889>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S895>/Action Port'
         */
        /* Merge: '<S889>/Merge' incorporates:
         *  DataStoreRead: '<S889>/Data Store Read1'
         *  SignalConversion generated from: '<S895>/Gnn'
         */
        memcpy(&Model_Target_B.Merge_a[0], &Model_Target_DW.Gnn[0], 65U * sizeof
               (real32_T));

        /* End of Outputs for SubSystem: '<S889>/If Action Subsystem1' */
    }

    /* End of If: '<S889>/If' */

    /* DataStoreWrite: '<S883>/Data Store Write' */
    memcpy(&Model_Target_DW.Gnn[0], &Model_Target_B.Merge_a[0], 65U * sizeof
           (real32_T));

    /* MATLAB Function: '<S883>/GnnInitNoiseFloor' */
    /*  Initialize noise floor in Gnn based on ref_pow_min TOP  */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /GnnInitNoiseFloor': '<S890>:1' */
    /*  Flag */
    /*  Initialize the flag */
    /* '<S890>:1:8' if isempty(init_noise_floor) */
    /*  Initialize Gnn */
    /* '<S890>:1:13' if(~init_noise_floor) */
    if (!Model_Target_DW.init_noise_floor)
    {
        /* '<S890>:1:14' Gnn(:) = RefPowerMin; */
        for (iDelta = 0; iDelta < 65; iDelta++)
        {
            Model_Target_DW.Gnn[iDelta] =
                Model_Target_PreAmp0.AudiopilotHfNoiseRefPowerMin;
        }

        /* '<S890>:1:15' init_noise_floor = true; */
        Model_Target_DW.init_noise_floor = true;
    }

    /* End of MATLAB Function: '<S883>/GnnInitNoiseFloor' */

    /* MATLAB Function: '<S891>/ExtractMicLevel' incorporates:
     *  MATLAB Function: '<S883>/FormCoherenceMatrixGXY'
     */
    /*  This function generates a microphone level by  */
    /*  (1) Extracting Gyy from the cross-spectral density matrix */
    /*      It is the last entry (last column, last row) of the matrix. */
    /*  (2) Sum Gyy over all frequency bands */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /MicPsdLevel/ExtractMicLevel': '<S898>:1' */
    /* '<S898>:1:7' Gyy = CSD(:,end,end); */
    /* '<S898>:1:8' MicLevel = sum(Gyy); */
    Model_Target_B.MicLevel = Model_Target_DW.GXY[1560];
    for (k = 0; k < 64; k++)
    {
        Model_Target_B.MicLevel.re += Model_Target_DW.GXY[k + 1561].re;
        Model_Target_B.MicLevel.im += Model_Target_DW.GXY[k + 1561].im;
    }

    /* End of MATLAB Function: '<S891>/ExtractMicLevel' */
    /* S-Function (sdspmsumprod): '<S916>/MatrixSumPowCurr' incorporates:
     *  Merge: '<S889>/Merge'
     */
    temp_re = Model_Target_B.Merge_a[0];

    /* S-Function (sdspmsumprod): '<S916>/MatrixSumPowPrev' incorporates:
     *  Delay: '<S908>/Delay'
     */
    temp_im = Model_Target_DW.Delay_DSTATE_d[0];
    for (iDelta = 0; iDelta < 64; iDelta++)
    {
        /* S-Function (sdspmsumprod): '<S916>/MatrixSumPowCurr' incorporates:
         *  Merge: '<S889>/Merge'
         */
        temp_re += Model_Target_B.Merge_a[iDelta + 1];

        /* S-Function (sdspmsumprod): '<S916>/MatrixSumPowPrev' incorporates:
         *  Delay: '<S908>/Delay'
         */
        temp_im += Model_Target_DW.Delay_DSTATE_d[iDelta + 1];
    }

    /* Bias: '<S916>/Bias1' incorporates:
     *  Bias: '<S916>/Bias'
     *  Product: '<S916>/Divide1'
     *  S-Function (sdspmsumprod): '<S916>/MatrixSumPowCurr'
     *  S-Function (sdspmsumprod): '<S916>/MatrixSumPowPrev'
     */
    temp_im = qhmath_div_f(1.0F, temp_re + 2.22044605E-16F) * temp_im - 1.0F;

    /* Sum: '<S916>/Add6' incorporates:
     *  Bias: '<S916>/Bias2'
     *  Bias: '<S916>/Bias3'
     *  Delay: '<S908>/Delay2'
     *  Gain: '<S916>/Gain'
     *  Math: '<S916>/Math Function'
     *  Math: '<S916>/Math Function1'
     *  MinMax: '<S916>/MinMax1'
     *  Product: '<S916>/Product2'
     *  Product: '<S916>/Product3'
     *
     * About '<S916>/Math Function':
     *  Operator: magnitude^2
     *
     * About '<S916>/Math Function1':
     *  Operator: reciprocal
     */
    temp_re = fmaxf(qhmath_div_f(1.0F, temp_im * temp_im + 1.0F),
                    Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionMinstatMin)
        * (-Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionMinstatBeta +
           1.0F) +
        Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionMinstatBeta *
        Model_Target_DW.Delay2_DSTATE_b;
    for (iDelta = 0; iDelta < 65; iDelta++)
    {
        /* Bias: '<S917>/Bias1' incorporates:
         *  Bias: '<S917>/Bias'
         *  Delay: '<S908>/Delay'
         *  Delay: '<S908>/Delay1'
         *  Product: '<S917>/Divide2'
         */
        temp_im = qhmath_div_f(Model_Target_DW.Delay_DSTATE_d[iDelta],
                               Model_Target_DW.Delay1_DSTATE_n[iDelta] +
                               2.22044605E-16F) - 1.0F;

        /* MinMax: '<S914>/MinMax2' incorporates:
         *  Bias: '<S913>/Bias'
         *  Bias: '<S914>/Bias2'
         *  Bias: '<S917>/Bias2'
         *  Delay: '<S908>/Delay'
         *  Gain: '<S913>/Gain'
         *  Math: '<S917>/Math Function2'
         *  Merge: '<S889>/Merge'
         *  Product: '<S913>/Product'
         *  Product: '<S913>/Product1'
         *  Product: '<S914>/Divide'
         *  Sum: '<S913>/Add'
         *
         * About '<S917>/Math Function2':
         *  Operator: magnitude^2
         */
        temp_im = fmaxf(qhmath_div_f
                        (Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionMinstatAlphaFactor
                         * temp_re, (temp_im * temp_im + 1.0F) + 2.22044605E-16F),
                        Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionMinstatAlphaMin);
        rtb_u_h[iDelta] = (-temp_im + 1.0F) * Model_Target_B.Merge_a[iDelta] +
            temp_im * Model_Target_DW.Delay_DSTATE_d[iDelta];
    }

    /* MATLAB Function: '<S918>/ComputePmin' */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/PostProcessing/HfImpulseRejection/MinSearch/ComputePmin': '<S927>:1' */
    /* '<S927>:1:10' numFreqBins = size(P,1); */
    /*  Because of restrictions on vsriable-size arrays, this number is currently */
    /*  hard-coded. It is intended to be subWin. */
    /* '<S927>:1:14' numSubWin = 3; */
    /*  The minimum value of 1e-8, currently hard-coded, should also be variable */
    /*  or globally defined. */
    /* '<S927>:1:19' if isempty(IRMinCount) */
    /* '<S927>:1:20' if isempty(IRSubMin) */
    /* '<S927>:1:21' if isempty(IRPowMS) */
    /*  The following is a low-storage method for calculating a running minimum */
    /*  over a sliding window */
    /* '<S927>:1:25' IRMinCount = mod(IRMinCount + 1, numSubWin*subWinLen); */
    Model_Target_DW.IRMinCount = Model_Target_mod(Model_Target_DW.IRMinCount +
        1.0F, 3.0F *
        Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionSubWinLenSamples);

    /* '<S927>:1:26' currentSubWin = floor(IRMinCount / subWinLen) + 1; */
    temp_im = qhmath_floor_f(qhmath_div_f(Model_Target_DW.IRMinCount,
        Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionSubWinLenSamples));

    /* '<S927>:1:28' if mod(IRMinCount, subWinLen) == 0 */
    if (Model_Target_mod(Model_Target_DW.IRMinCount,
                         Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionSubWinLenSamples)
        == 0.0F)
    {
        /* '<S927>:1:29' IRSubMin(currentSubWin, :) = 1; */
        for (br_tmp = 0; br_tmp < 65; br_tmp++)
        {
            Model_Target_DW.IRSubMin[((int32_T)(temp_im + 1.0F) + 3 * br_tmp) -
                1] = 1.0F;
        }
    }

    /* '<S927>:1:32' IRSubMin(currentSubWin, :) = min(IRSubMin(currentSubWin, :), P.'); */
    for (k = 0; k < 65; k++)
    {
        IRGlobalMin[k] = fminf(Model_Target_DW.IRSubMin[((int32_T)(temp_im +
            1.0F) + 3 * k) - 1], rtb_u_h[k]);
    }

    /* '<S927>:1:33' IRGlobalMin = min(IRSubMin); */
    for (ju = 0; ju < 65; ju++)
    {
        Model_Target_DW.IRSubMin[((int32_T)(temp_im + 1.0F) + 3 * ju) - 1] =
            IRGlobalMin[ju];
        twid_re = Model_Target_DW.IRSubMin[3 * ju];
        br_tmp = 3 * ju + 1;
        if (twid_re > Model_Target_DW.IRSubMin[br_tmp])
        {
            twid_re = Model_Target_DW.IRSubMin[br_tmp];
        }

        twid_im = Model_Target_DW.IRSubMin[3 * ju + 2];
        if (twid_re > twid_im)
        {
            twid_re = twid_im;
        }

        IRGlobalMin[ju] = twid_re;
    }

    /*  Flatness Calculations */
    /*  Geometric mean over arithmatic mean */
    /* '<S927>:1:37' flatness = 10^(mean(log10(IRGlobalMin(flatIdx1:flatIdx2)))) / ... */
    /* '<S927>:1:38' 	(mean(IRGlobalMin(flatIdx1:flatIdx2))+eps); */
    if (Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessLowIndex >
        Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessHighIndex)
    {
        chan1Idx = 1;
        iy = 0;
    }
    else
    {
        chan1Idx = (int32_T)
            Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessLowIndex;
        iy = (int32_T)
            Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessHighIndex;
    }

    if (Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessLowIndex >
        Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessHighIndex)
    {
        br_tmp = 0;
        iDelta = 0;
    }
    else
    {
        br_tmp = (int32_T)
            Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessLowIndex
            - 1;
        iDelta = (int32_T)
            Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessHighIndex;
    }

    ju = iy - chan1Idx;
    iy = ju + 1;
    for (ix = 0; ix <= ju; ix++)
    {
        b_x_data[ix] = IRGlobalMin[(chan1Idx + ix) - 1];
        b_x_data[ix] = qhmath_log10_f(b_x_data[ix]);
    }

    if (ju + 1 == 0)
    {
        temp_im = 0.0F;
    }
    else
    {
        temp_im = b_x_data[0];
        for (ix = 2; ix <= iy; ix++)
        {
            temp_im += b_x_data[ix - 1];
        }
    }

    chan1Idx = iDelta - br_tmp;
    if (chan1Idx == 0)
    {
        twid_re = 0.0F;
    }
    else
    {
        twid_re = IRGlobalMin[br_tmp];
        for (ix = 2; ix <= chan1Idx; ix++)
        {
            twid_re += IRGlobalMin[(br_tmp + ix) - 1];
        }
    }

    temp_im = qhmath_div_f(qhmath_pow_f(10.0F, qhmath_div_f(temp_im, (real32_T)
        (ju + 1))), qhmath_div_f(twid_re, (real32_T)chan1Idx) + 2.22044605E-16F);

    /* '<S927>:1:40' if flatness >= flatThresh */
    if (temp_im >=
            Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionFlatnessThresh)
    {
        /*  accept new value */
        /* '<S927>:1:42' IRPowMS = powMSCoef*IRPowMS + (1-powMSCoef)*IRGlobalMin; */
        for (br_tmp = 0; br_tmp < 65; br_tmp++)
        {
            Model_Target_DW.IRPowMS[br_tmp] = (1.0F -
                Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionMinSearchCoef)
                * IRGlobalMin[br_tmp] +
                Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionMinSearchCoef
                * Model_Target_DW.IRPowMS[br_tmp];
        }
    }
    else
    {
        /* '<S927>:1:43' else */
        /*  else, take the smaller of the current sample and the storage */
        /* '<S927>:1:45' IRPowMS = min(IRPowMS, IRGlobalMin); */
        for (iDelta = 0; iDelta < 65; iDelta++)
        {
            Model_Target_DW.IRPowMS[iDelta] = fminf
                (Model_Target_DW.IRPowMS[iDelta], IRGlobalMin[iDelta]);
        }
    }

    /* '<S927>:1:48' powMin = single(IRPowMS.'*minGain); */
    Model_Target_B.flatness = temp_im;

    /* Sum: '<S908>/Sum of Elements' */
    temp_im = -0.0F;
    for (ju = 0; ju < 65; ju++)
    {
        /* MATLAB Function: '<S918>/ComputePmin' */
        twid_re = Model_Target_DW.IRPowMS[ju] *
            Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionMinSearchMinGain;

        /* Sum: '<S908>/Sum of Elements' */
        temp_im += twid_re;

        /* MATLAB Function: '<S918>/ComputePmin' */
        IRGlobalMin[ju] = twid_re;
    }

    /* Sum: '<S908>/Sum of Elements' */
    Model_Target_B.SumofElements = temp_im;

    /* Sqrt: '<S908>/Sqrt' */
    temp_im = qhmath_sqrt_f(Model_Target_B.SumofElements);

    /* Switch: '<S920>/Switch' incorporates:
     *  Constant: '<S920>/Constant'
     *  Delay: '<S920>/Delay'
     *  RelationalOperator: '<S920>/Relational Operator'
     */
    if (temp_im < Model_Target_DW.Delay_DSTATE_n0)
    {
        twid_re = 1.0F;
    }
    else
    {
        twid_re =
            Model_Target_PreAmp0.AudiopilotHfNoiseImpulseRejectionLevelUpdateCoef;
    }

    /* End of Switch: '<S920>/Switch' */

    /* Sum: '<S920>/Add1' incorporates:
     *  Bias: '<S920>/Bias'
     *  Delay: '<S920>/Delay'
     *  Gain: '<S920>/Gain'
     *  Product: '<S920>/Product'
     *  Product: '<S920>/Product1'
     */
    temp_im = (-twid_re + 1.0F) * Model_Target_DW.Delay_DSTATE_n0 + temp_im *
        twid_re;

    /* Sum: '<S908>/Add' incorporates:
     *  Constant: '<S915>/Constant'
     *  Gain: '<S915>/Gain'
     *  Math: '<S915>/Magsq'
     *  Math: '<S915>/log10'
     *  Sum: '<S915>/Sum1'
     *
     * About '<S915>/Magsq':
     *  Operator: magnitude^2
     *
     * About '<S915>/log10':
     *  Operator: log10
     */
    Model_Target_B.Add_o = qhmath_log10_f((temp_im + 2.22044605E-16F) * (temp_im
        + 2.22044605E-16F)) * 10.0F +
        Model_Target_PreAmp0.AudiopilotHfNoiseOffsetDb;

    /* MATLAB Function: '<S909>/Slew' incorporates:
     *  Constant: '<S909>/init'
     */
    /* MATLAB Function 'Slew': '<S936>:1' */
    /* '<S936>:1:5' if isempty(PrevChange) */
    /* '<S936>:1:6' if isempty(PrevDelta) */
    /* '<S936>:1:7' if isempty(PrevPostSlew) */
    if (!Model_Target_DW.PrevPostSlew_not_empty_c)
    {
        /* '<S936>:1:7' ; */
        /* '<S936>:1:7' PrevPostSlew = single(SlewInit); */
        Model_Target_DW.PrevPostSlew_b = 20.0F;
        Model_Target_DW.PrevPostSlew_not_empty_c = true;
    }

    /* '<S936>:1:9' Delta = PreSlew - PrevPostSlew; */
    twid_re = Model_Target_B.Add_o - Model_Target_DW.PrevPostSlew_b;

    /* '<S936>:1:11' if Delta > 0 */
    if (twid_re > 0.0F)
    {
        /*  setup for positive delta */
        /* '<S936>:1:12' Change = min(SlewAttack, Delta); */
        twid_im = fminf
            (Model_Target_PreAmp0.AudiopilotHfNoiseSlewAttackDbPerSample,
             twid_re);

        /* '<S936>:1:13' SlowSlew = min(SlowSlew, Delta); */
    }
    else
    {
        /* '<S936>:1:14' else */
        /*  setup for negative delta */
        /* '<S936>:1:15' Change = max(SlewDecay, Delta); */
        twid_im = fmaxf
            (Model_Target_PreAmp0.AudiopilotHfNoiseSlewDecayDbPerSample, twid_re);

        /* '<S936>:1:16' SlowSlew = max(-SlowSlew, Delta); */
    }

    /* '<S936>:1:19' if PrevDelta*Delta > 0 */
    if (Model_Target_DW.PrevDelta_p * twid_re > 0.0F)
    {
        /*  did we reach our target? */
        /* '<S936>:1:20' Slew = single(PrevChange); */
        Slew = Model_Target_DW.PrevChange_c;

        /*  no, continue the current path */
    }
    else
    {
        /* '<S936>:1:21' else */
        /*  otherwise, we have reached our target */
        /* '<S936>:1:22' Slew = single(0); */
        Slew = 0.0F;

        /*  no slew in the dead zone */
    }

    /* '<S936>:1:25' if SpeedBoundFlag && Slew == 0 */
    /* '<S936>:1:29' if (abs(Delta) <= SlewThreshold) ...		% are we within the zone? */
    /* '<S936>:1:30' 		&& (abs(Slew) < abs(Change)) */
    if ((qhmath_abs_f(twid_re) <=
            Model_Target_PreAmp0.AudiopilotHfNoiseSlewThresholdDb) &&
            (qhmath_abs_f(Slew) < qhmath_abs_f(twid_im)))
    {
        /* 		% are we within the zone? */
        /*  is change still bigger than slew? */
        /*  (offshoot protection)x */
        /* '<S936>:1:32' Change = Slew; */
        twid_im = Slew;

        /*  freeze or continue the current */
    }

    /* '<S936>:1:35' PrevDelta = Delta; */
    Model_Target_DW.PrevDelta_p = twid_re;

    /* '<S936>:1:36' PrevChange = Change; */
    Model_Target_DW.PrevChange_c = twid_im;

    /* '<S936>:1:38' PrevPostSlew = PrevPostSlew + Change; */
    Model_Target_DW.PrevPostSlew_b += twid_im;

    /* '<S936>:1:39' PostSlew = PrevPostSlew; */
    Model_Target_B.PostSlew_j = Model_Target_DW.PrevPostSlew_b;

    /* End of MATLAB Function: '<S909>/Slew' */
    /* RateTransition: '<S879>/LFNoise postSmooth Rate Transition' */
    twid_re =
        Model_Target_DW.LFNoisepostSmoothRateTransition_Buffer[Model_Target_DW.LFNoisepostSmoothRateTransition_ActiveBufIdx];

    /* RateTransition: '<S879>/LFNoise preSmooth Rate Transition' */
    twid_im =
        Model_Target_DW.LFNoisepreSmoothRateTransition_Buffer[Model_Target_DW.LFNoisepreSmoothRateTransition_ActiveBufIdx];

    /* RateTransition: '<S879>/Speed Rate Transition' */
    Model_Target_DW.SpeedRateTransition_semaphoreTaken = 1;
    Slew = Model_Target_DW.SpeedRateTransition_Buffer0;
    Model_Target_DW.SpeedRateTransition_semaphoreTaken = 0;

    /* MATLAB Function: '<S1036>/APLFUP' */
    /*  This function is to check if the low freq noise goes up when the high */
    /*  freq noise is going up. Only when both noise go up, the flag is set to */
    /*  enable the ratio change and tuning adjustment */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/RatioCalculation/APLFUP/APLFUP': '<S1045>:1' */
    /* '<S1045>:1:14' if isempty(prev) */
    /* '<S1045>:1:15' if isempty(counter) */
    /* '<S1045>:1:16' if isempty(counter2) */
    /* '<S1045>:1:17' if isempty(LFUP) */
    /* '<S1045>:1:19' if ((LF >= prev + noiseUpThresh) && (speed >= SpeedThresh)) */
    if ((twid_re >= Model_Target_DW.prev +
            Model_Target_PreAmp0.AudiopilotRatioUpdateLfNoiseUpdateThreshDb) &&
            (Slew >=
             Model_Target_PreAmp0.AudiopilotRatioUpdateSpeedUpdateThreshMph))
    {
        /* '<S1045>:1:20' LFUP = single(1); */
        Model_Target_DW.LFUP = 1.0F;

        /* '<S1045>:1:21' counter = single(0); */
        Model_Target_DW.counter_j = 0.0F;

        /*  If low freq noise goes up by more than noiseUpThresh dB and the speed */
        /*  is above the SpeedThresh, set the flag ON and reset the counter, this */
        /*  is usually the case when the windows roll down */
    }
    else if ((Model_Target_DW.LFUP == 1.0F) && (Model_Target_DW.counter_j <
              Model_Target_PreAmp0.AudiopilotRatioUpdateFlagHoldTimeSamples))
    {
        /* '<S1045>:1:25' elseif (LFUP == 1) && (counter < HoldTime1) */
        /* '<S1045>:1:26' counter = counter + 1; */
        Model_Target_DW.counter_j++;

        /*  elseif the flag is ON and the hold period has not expired, update the */
        /*  counter for hold time1 */
    }
    else
    {
        /* '<S1045>:1:29' else */
        /* '<S1045>:1:30' LFUP = single(0); */
        Model_Target_DW.LFUP = 0.0F;

        /* '<S1045>:1:31' counter = single(0); */
        Model_Target_DW.counter_j = 0.0F;

        /*  else, reset the flag and the counter */
    }

    /* '<S1045>:1:35' if (LF > LFUPThresh) && (speed >= SpeedThresh) || (HF > HFUPThresh) */
    if (((twid_re > Model_Target_PreAmp0.AudiopilotRatioUpdateLfNoiseThreshDbspl)
         && (Slew >=
             Model_Target_PreAmp0.AudiopilotRatioUpdateSpeedUpdateThreshMph)) ||
        (Model_Target_B.PostSlew_j >
            Model_Target_PreAmp0.AudiopilotRatioUpdateHfNoiseThreshDbspl))
    {
        /* '<S1045>:1:36' LFUP = single(1); */
        Model_Target_DW.LFUP = 1.0F;

        /* '<S1045>:1:37' counter = HoldTime1 - 2; */
        Model_Target_DW.counter_j =
            Model_Target_PreAmp0.AudiopilotRatioUpdateFlagHoldTimeSamples - 2.0F;

        /*  In another case, if the low freq noise level is above LFUPThresh and */
        /*  the high freq noise is above HFUPThresh and the speed is above */
        /*  SpeedThresh, set the flag ON. This usually happens when the window is */
        /*  already down and vehicle starts to speed up */
    }

    /*  to prevent too small variations in low freq noise, we only update the low */
    /*  freq noise reading every HoldTime2 seconds. */
    /* '<S1045>:1:46' if counter2 == HoldTime2 - 1 */
    if (Model_Target_PreAmp0.AudiopilotRatioUpdateLfNoiseUpdatePeriodSamples -
            1.0F == Model_Target_DW.counter2)
    {
        /* '<S1045>:1:47' prev = LF; */
        Model_Target_DW.prev = twid_re;

        /* '<S1045>:1:48' counter2 = single(0); */
        Model_Target_DW.counter2 = 0.0F;
    }
    else
    {
        /* '<S1045>:1:49' else */
        /* '<S1045>:1:50' counter2 = counter2 + 1; */
        Model_Target_DW.counter2++;
    }

    /* '<S1045>:1:53' LFUPFlag = LFUP; */
    Model_Target_B.LFUPFlag = Model_Target_DW.LFUP;

    /* End of MATLAB Function: '<S1036>/APLFUP' */
    /* MATLAB Function: '<S1043>/RatioSmoother' incorporates:
     *  Gain: '<S1056>/Gain'
     *  Gain: '<S1062>/Gain'
     *  Math: '<S1056>/Math Function'
     *  Math: '<S1062>/Math Function'
     *  MinMax: '<S1043>/MinMax'
     *  MinMax: '<S1043>/MinMax1'
     *  RateTransition: '<S882>/Rate Transition'
     *  RateTransition: '<S882>/Rate Transition1'
     *  Sum: '<S1043>/Subtract'
     */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/RatioCalculation/RatioSmoother/RatioSmoother': '<S1061>:1' */
    /* '<S1061>:1:11' if isempty(PreRatioLinLP) */
    /* '<S1061>:1:12' if isempty(ImpFiltState) */
    /* '<S1061>:1:13' if isempty(ImpRejFiltOut) */
    if (!Model_Target_DW.ImpRejFiltOut_not_empty)
    {
        /* '<S1061>:1:13' ; */
        /* '<S1061>:1:13' ImpRejFiltOut = single(ImpRejFiltOutInit); */
        Model_Target_DW.ImpRejFiltOut = qhmath_pow_f(10.0F, 0.05F *
            Model_Target_DW.RateTransition1_Buffer);
        Model_Target_DW.ImpRejFiltOut_not_empty = true;
    }

    /*  Energy Conversion */
    /* '<S1061>:1:16' PreRatioLinLP = PreRatioLinLP*RatioCoef ... */
    /* '<S1061>:1:17'     + abs(PreRatioLinear)*(1-RatioCoef); */
    Model_Target_DW.PreRatioLinLP = qhmath_pow_f(10.0F, fminf(fmaxf(twid_im -
        Model_Target_B.Add_o, Model_Target_DW.RateTransition_Buffer),
        Model_Target_DW.RateTransition1_Buffer) * 0.05F) * (1.0F -
        Model_Target_PreAmp0.AudiopilotRatioEnergyLpfCoef) +
        Model_Target_DW.PreRatioLinLP *
        Model_Target_PreAmp0.AudiopilotRatioEnergyLpfCoef;

    /*  Instantaneous Noise Estimate */
    /* '<S1061>:1:20' RatioInstant = abs(PreRatioLinLP); */
    twid_re = qhmath_abs_f(Model_Target_DW.PreRatioLinLP);

    /*  Impulse Estimate */
    /*  Double application of 1st order LPF (A Dublin hack) */
    /* '<S1061>:1:24' ImpFiltState(1) = ImpFiltState(1)*RatioFiltCoef ... */
    /* '<S1061>:1:25'     + RatioInstant*(1-RatioFiltCoef); */
    Model_Target_DW.ImpFiltState[0] = (1.0F -
        Model_Target_PreAmp0.AudiopilotRatioImpulseRejectionImpulseVarianceLpfCoef)
        * twid_re + Model_Target_DW.ImpFiltState[0] *
        Model_Target_PreAmp0.AudiopilotRatioImpulseRejectionImpulseVarianceLpfCoef;

    /* '<S1061>:1:26' ImpFiltState(2) = ImpFiltState(2)*RatioFiltCoef ... */
    /* '<S1061>:1:27'     + ImpFiltState(1)*(1-RatioFiltCoef); */
    Model_Target_DW.ImpFiltState[1] = (1.0F -
        Model_Target_PreAmp0.AudiopilotRatioImpulseRejectionImpulseVarianceLpfCoef)
        * Model_Target_DW.ImpFiltState[0] + Model_Target_DW.ImpFiltState[1] *
        Model_Target_PreAmp0.AudiopilotRatioImpulseRejectionImpulseVarianceLpfCoef;

    /*  Variances */
    /* '<S1061>:1:30' noiseVar = NoiseScale * ImpFiltState(2)^2; */
    twid_im = Model_Target_DW.ImpFiltState[1] * Model_Target_DW.ImpFiltState[1] *
        Model_Target_PreAmp0.AudiopilotRatioImpulseRejectionNoiseVarianceScale;

    /* '<S1061>:1:31' impulseVar = ImpulseScale ... */
    /* '<S1061>:1:32'     * (min(0,RatioInstant-ImpFiltState(2)))^2; */
    Slew = fminf(0.0F, twid_re - Model_Target_DW.ImpFiltState[1]);

    /* '<S1061>:1:33' totalVar = noiseVar + max(0,impulseVar); */
    /*  Gamma correction */
    /* '<S1061>:1:36' impRejFiltCoef = (1 - GammaCorr*noiseVar/(totalVar+eps)); */
    twid_im = 1.0F - qhmath_div_f
        (Model_Target_PreAmp0.AudiopilotRatioImpulseRejectionGamma0 * twid_im,
         (fmaxf(0.0F, Slew * Slew *
                Model_Target_PreAmp0.AudiopilotRatioImpulseRejectionImpulseVarianceScale)
          + twid_im) + 2.22044605E-16F);

    /*  Impulse Reject Filter */
    /*  If the new value is larger than the current value, use the new value for */
    /*  update.  Otherwise, if the new value is smaller, then update only if the */
    /*  update flag is also raised. */
    /* '<S1061>:1:42' if (RatioInstant >= ImpRejFiltOut) || ((RatioInstant < ImpRejFiltOut)&& UpdateFlag) */
    if ((twid_re >= Model_Target_DW.ImpRejFiltOut) || (Model_Target_B.LFUPFlag
            != 0.0F))
    {
        /* '<S1061>:1:43' ImpRejFiltOut = impRejFiltCoef*ImpRejFiltOut+RatioInstant*(1-impRejFiltCoef); */
        Model_Target_DW.ImpRejFiltOut = (1.0F - twid_im) * twid_re + twid_im *
            Model_Target_DW.ImpRejFiltOut;
    }

    /* Sum: '<S1063>/Sum1' incorporates:
     *  Constant: '<S1063>/Constant'
     *  Constant: '<S882>/RatioOutputLowBound'
     *  MATLAB Function: '<S1043>/RatioSmoother'
     */
    /*  dBSPL Conversion and microphone energy check */
    /* '<S1061>:1:47' RatioLinear = max(ImpRejFiltOut+eps, PreRatioMin); */
    twid_re = fmaxf(Model_Target_DW.ImpRejFiltOut + 2.22044605E-16F, 100.0F) +
        2.22044605E-16F;

    /* Sum: '<S1063>/Sum2' incorporates:
     *  Gain: '<S1063>/Gain'
     *  Math: '<S1063>/Magsq'
     *  Math: '<S1063>/log10'
     *
     * About '<S1063>/Magsq':
     *  Operator: magnitude^2
     *
     * About '<S1063>/log10':
     *  Operator: log10
     */
    Model_Target_B.Sum2 = qhmath_log10_f(twid_re * twid_re) * 10.0F;

    /* MATLAB Function: '<S1042>/Slew' incorporates:
     *  RateTransition: '<S882>/Rate Transition1'
     */
    /* MATLAB Function 'Slew': '<S1052>:1' */
    /* '<S1052>:1:5' if isempty(PrevChange) */
    /* '<S1052>:1:6' if isempty(PrevDelta) */
    /* '<S1052>:1:7' if isempty(PrevPostSlew) */
    if (!Model_Target_DW.PrevPostSlew_not_empty)
    {
        /* '<S1052>:1:7' ; */
        /* '<S1052>:1:7' PrevPostSlew = single(SlewInit); */
        Model_Target_DW.PrevPostSlew = Model_Target_DW.RateTransition1_Buffer;
        Model_Target_DW.PrevPostSlew_not_empty = true;
    }

    /* '<S1052>:1:9' Delta = PreSlew - PrevPostSlew; */
    twid_re = Model_Target_B.Sum2 - Model_Target_DW.PrevPostSlew;

    /* '<S1052>:1:11' if Delta > 0 */
    if (twid_re > 0.0F)
    {
        /*  setup for positive delta */
        /* '<S1052>:1:12' Change = min(SlewAttack, Delta); */
        twid_im = fminf
            (Model_Target_PreAmp0.AudiopilotRatioSlewAttackDbPerSample, twid_re);

        /* '<S1052>:1:13' SlowSlew = min(SlowSlew, Delta); */
    }
    else
    {
        /* '<S1052>:1:14' else */
        /*  setup for negative delta */
        /* '<S1052>:1:15' Change = max(SlewDecay, Delta); */
        twid_im = fmaxf(Model_Target_PreAmp0.AudiopilotRatioSlewDecayDbPerSample,
                        twid_re);

        /* '<S1052>:1:16' SlowSlew = max(-SlowSlew, Delta); */
    }

    /* '<S1052>:1:19' if PrevDelta*Delta > 0 */
    if (Model_Target_DW.PrevDelta * twid_re > 0.0F)
    {
        /*  did we reach our target? */
        /* '<S1052>:1:20' Slew = single(PrevChange); */
        Slew = Model_Target_DW.PrevChange;

        /*  no, continue the current path */
    }
    else
    {
        /* '<S1052>:1:21' else */
        /*  otherwise, we have reached our target */
        /* '<S1052>:1:22' Slew = single(0); */
        Slew = 0.0F;

        /*  no slew in the dead zone */
    }

    /* '<S1052>:1:25' if SpeedBoundFlag && Slew == 0 */
    /* '<S1052>:1:29' if (abs(Delta) <= SlewThreshold) ...		% are we within the zone? */
    /* '<S1052>:1:30' 		&& (abs(Slew) < abs(Change)) */
    if ((qhmath_abs_f(twid_re) <=
            Model_Target_PreAmp0.AudiopilotRatioSlewThresholdDb) &&
            (qhmath_abs_f(Slew) < qhmath_abs_f(twid_im)))
    {
        /* 		% are we within the zone? */
        /*  is change still bigger than slew? */
        /*  (offshoot protection)x */
        /* '<S1052>:1:32' Change = Slew; */
        twid_im = Slew;

        /*  freeze or continue the current */
    }

    /* '<S1052>:1:35' PrevDelta = Delta; */
    Model_Target_DW.PrevDelta = twid_re;

    /* '<S1052>:1:36' PrevChange = Change; */
    Model_Target_DW.PrevChange = twid_im;

    /* '<S1052>:1:38' PrevPostSlew = PrevPostSlew + Change; */
    Model_Target_DW.PrevPostSlew += twid_im;

    /* '<S1052>:1:39' PostSlew = PrevPostSlew; */
    Model_Target_B.PostSlew = Model_Target_DW.PrevPostSlew;

    /* End of MATLAB Function: '<S1042>/Slew' */
    /* RateTransition: '<S664>/Rate Transition2' */
    Model_Target_DW.RateTransition2_Buffer[Model_Target_DW.RateTransition2_ActiveBufIdx
        == 0] = Model_Target_B.PostSlew;
    Model_Target_DW.RateTransition2_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition2_ActiveBufIdx == 0);

    /* RateTransition: '<S664>/Rate Transition6' */
    Model_Target_DW.RateTransition6_Buffer[Model_Target_DW.RateTransition6_ActiveBufIdx
        == 0] = Model_Target_B.PostSlew_j;
    Model_Target_DW.RateTransition6_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition6_ActiveBufIdx == 0);

    /* End of Outputs for SubSystem: '<S655>/AudioPilot35' */

    /* Update for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* Update for M-S-Function: '<S899>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoiseMicPsdLevel '<S899>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 18, &Model_Target_B.MicLevel);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S892>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoisePowerSpectralDensity '<S892>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 20, &Model_Target_B.Merge_a[0]);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for Delay: '<S908>/Delay2' */
    Model_Target_DW.Delay2_DSTATE_b = temp_re;

    /* Update for Delay: '<S908>/Delay' incorporates:
     *  Sum: '<S913>/Add'
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_d[0], &rtb_u_h[0], 65U * sizeof
           (real32_T));

    /* Update for Delay: '<S908>/Delay1' */
    memcpy(&Model_Target_DW.Delay1_DSTATE_n[0], &IRGlobalMin[0], 65U * sizeof
           (real32_T));

    /* Update for Delay: '<S920>/Delay' */
    Model_Target_DW.Delay_DSTATE_n0 = temp_im;

    /* Update for M-S-Function: '<S910>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoisePostSlew '<S910>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 19, &Model_Target_B.PostSlew_j);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S911>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoisePreSlew '<S911>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 21, &Model_Target_B.Add_o);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S919>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoiseImpulseRejectionPmin '<S919>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 17, &Model_Target_B.SumofElements);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S928>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoiseImpulseRejectionFlatness '<S928>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 16, &Model_Target_B.flatness);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1040>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotRatioPostSlew '<S1040>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 42, &Model_Target_B.PostSlew);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1041>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotRatioPreSlew '<S1041>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 43, &Model_Target_B.Sum2);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1044>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotRatioUpdateFlag '<S1044>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 44, &Model_Target_B.LFUPFlag);

#endif                                 //TSP_ENABLE_ADVANCED

    /* End of Update for SubSystem: '<S655>/AudioPilot35' */
}

/* Model step function for TID7 */
void Model_Target_step7(void)    /* Sample time: [0.18488888888888888s, 0.0s] */
{
    creal32_T y_p[31];
    int32_T b_i;
    int32_T iDelta;
    int32_T ix;
    int32_T iy;
    int32_T j;
    int32_T ju;
    real32_T y_la[31];
    real32_T Slew;
    real32_T ar;
    real32_T rtb_RateTransition3;
    real32_T rtb_Switch_a4;
    real32_T temp_re;
    real32_T twid_im;
    static const real32_T b[129] =
    {
        1.0F, 0.999698818F, 0.99879545F, 0.997290432F, 0.99518472F, 0.992479563F,
        0.989176512F, 0.985277653F, 0.980785251F, 0.975702107F, 0.970031261F,
        0.963776052F, 0.956940353F, 0.949528158F, 0.941544056F, 0.932992816F,
        0.923879504F, 0.914209723F, 0.903989315F, 0.893224299F, 0.881921232F,
        0.870086968F, 0.857728601F, 0.84485358F, 0.831469595F, 0.817584813F,
        0.803207517F, 0.78834641F, 0.773010433F, 0.757208824F, 0.740951121F,
        0.724247098F, 0.707106769F, 0.689540565F, 0.671559F, 0.653172851F,
        0.634393334F, 0.615231633F, 0.59569931F, 0.575808227F, 0.555570245F,
        0.534997642F, 0.514102757F, 0.492898226F, 0.471396744F, 0.449611336F,
        0.427555084F, 0.40524134F, 0.382683456F, 0.359895051F, 0.336889863F,
        0.313681751F, 0.290284663F, 0.266712785F, 0.242980197F, 0.219101235F,
        0.195090324F, 0.170961902F, 0.146730468F, 0.122410677F, 0.0980171412F,
        0.0735645667F, 0.0490676761F, 0.024541229F, 0.0F, -0.024541229F,
        -0.0490676761F, -0.0735645667F, -0.0980171412F, -0.122410677F,
        -0.146730468F, -0.170961902F, -0.195090324F, -0.219101235F,
        -0.242980197F, -0.266712785F, -0.290284663F, -0.313681751F,
        -0.336889863F, -0.359895051F, -0.382683456F, -0.40524134F, -0.427555084F,
        -0.449611336F, -0.471396744F, -0.492898226F, -0.514102757F,
        -0.534997642F, -0.555570245F, -0.575808227F, -0.59569931F, -0.615231633F,
        -0.634393334F, -0.653172851F, -0.671559F, -0.689540565F, -0.707106769F,
        -0.724247098F, -0.740951121F, -0.757208824F, -0.773010433F, -0.78834641F,
        -0.803207517F, -0.817584813F, -0.831469595F, -0.84485358F, -0.857728601F,
        -0.870086968F, -0.881921232F, -0.893224299F, -0.903989315F,
        -0.914209723F, -0.923879504F, -0.932992816F, -0.941544056F,
        -0.949528158F, -0.956940353F, -0.963776052F, -0.970031261F,
        -0.975702107F, -0.980785251F, -0.985277653F, -0.989176512F,
        -0.992479563F, -0.99518472F, -0.997290432F, -0.99879545F, -0.999698818F,
        -1.0F
    };

    static const real32_T c[129] =
    {
        0.0F, -0.024541229F, -0.0490676761F, -0.0735645667F, -0.0980171412F,
        -0.122410677F, -0.146730468F, -0.170961902F, -0.195090324F,
        -0.219101235F, -0.242980197F, -0.266712785F, -0.290284663F,
        -0.313681751F, -0.336889863F, -0.359895051F, -0.382683456F, -0.40524134F,
        -0.427555084F, -0.449611336F, -0.471396744F, -0.492898226F,
        -0.514102757F, -0.534997642F, -0.555570245F, -0.575808227F, -0.59569931F,
        -0.615231633F, -0.634393334F, -0.653172851F, -0.671559F, -0.689540565F,
        -0.707106769F, -0.724247098F, -0.740951121F, -0.757208824F,
        -0.773010433F, -0.78834641F, -0.803207517F, -0.817584813F, -0.831469595F,
        -0.84485358F, -0.857728601F, -0.870086968F, -0.881921232F, -0.893224299F,
        -0.903989315F, -0.914209723F, -0.923879504F, -0.932992816F,
        -0.941544056F, -0.949528158F, -0.956940353F, -0.963776052F,
        -0.970031261F, -0.975702107F, -0.980785251F, -0.985277653F,
        -0.989176512F, -0.992479563F, -0.99518472F, -0.997290432F, -0.99879545F,
        -0.999698818F, -1.0F, -0.999698818F, -0.99879545F, -0.997290432F,
        -0.99518472F, -0.992479563F, -0.989176512F, -0.985277653F, -0.980785251F,
        -0.975702107F, -0.970031261F, -0.963776052F, -0.956940353F,
        -0.949528158F, -0.941544056F, -0.932992816F, -0.923879504F,
        -0.914209723F, -0.903989315F, -0.893224299F, -0.881921232F,
        -0.870086968F, -0.857728601F, -0.84485358F, -0.831469595F, -0.817584813F,
        -0.803207517F, -0.78834641F, -0.773010433F, -0.757208824F, -0.740951121F,
        -0.724247098F, -0.707106769F, -0.689540565F, -0.671559F, -0.653172851F,
        -0.634393334F, -0.615231633F, -0.59569931F, -0.575808227F, -0.555570245F,
        -0.534997642F, -0.514102757F, -0.492898226F, -0.471396744F,
        -0.449611336F, -0.427555084F, -0.40524134F, -0.382683456F, -0.359895051F,
        -0.336889863F, -0.313681751F, -0.290284663F, -0.266712785F,
        -0.242980197F, -0.219101235F, -0.195090324F, -0.170961902F,
        -0.146730468F, -0.122410677F, -0.0980171412F, -0.0735645667F,
        -0.0490676761F, -0.024541229F, -0.0F
    };

    creal32_T *tmp;

    /* Outputs for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* RateTransition: '<S881>/Rate Transition' */
    if (Model_Target_M->Timing.RateInteraction.TID7_8)
    {
        /* RateTransition: '<S881>/Rate Transition' */
        Model_Target_B.RateTransition = Model_Target_DW.RateTransition_Buffer0;
    }

    /* End of RateTransition: '<S881>/Rate Transition' */

    /* RateTransition: '<S881>/Rate Transition3' */
    Model_Target_DW.RateTransition3_semaphoreTaken = 1;
    rtb_RateTransition3 = Model_Target_DW.RateTransition3_Buffer0;
    Model_Target_DW.RateTransition3_semaphoreTaken = 0;

    /* MATLAB Function: '<S1022>/SpeedBounds' incorporates:
     *  S-Function (TOP_MEX): '<S1032>/TOP'
     *  S-Function (TOP_MEX): '<S1033>/TOP'
     *  S-Function (TOP_MEX): '<S1034>/TOP'
     */
    /*  Apply speed bounds to the noise */
    /*  Set up speed bound flag for slewing */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/SpeedBoundsAndNoiseSlew/SpeedBounds/SpeedBounds': '<S1031>:1' */
    /* '<S1031>:1:7' if SpeedBoundOn > 0 */
    if (Model_Target_PreAmp0.AudiopilotLfNoiseSpeedBoundsOn > 0.0F)
    {
        /*  limit input speed to the range of indices in the table */
        /* '<S1031>:1:9' Speed = min(Speed, SpeedAxis(end)); */
        /* '<S1031>:1:10' Speed = max(Speed, SpeedAxis(1)); */
        temp_re = fmaxf(fminf(rtb_RateTransition3,
                              Model_Target_PreAmp0.AudiopilotLfNoiseSpeedBoundsAxis
                              [127]),
                        Model_Target_PreAmp0.AudiopilotLfNoiseSpeedBoundsAxis[0]);

        /*  interpolate if speed does not match indices exactly */
        /* '<S1031>:1:12' CurrNoiseBoundL = interp1(SpeedAxis, BoundLow, Speed, 'linear'); */
        rtb_RateTransition3 = Model_Target_interp1_m
            (&(Model_Target_PreAmp0.AudiopilotLfNoiseSpeedBoundsAxis[0]),
             &(Model_Target_PreAmp0.AudiopilotLfNoiseSpeedBoundsMinDbspl[0]),
             temp_re);

        /* '<S1031>:1:13' CurrNoiseBoundH = interp1(SpeedAxis, BoundHigh, Speed, 'linear'); */
        Slew = Model_Target_interp1_m
            (&(Model_Target_PreAmp0.AudiopilotLfNoiseSpeedBoundsAxis[0]),
             &(Model_Target_PreAmp0.AudiopilotLfNoiseSpeedBoundsMaxDbspl[0]),
             temp_re);

        /*  apply speed bounds */
        /* '<S1031>:1:15' NoisePreSlew = single(max(Noise, CurrNoiseBoundL)); */
        /* '<S1031>:1:16' NoisePreSlew = single(min(NoisePreSlew, CurrNoiseBoundH)); */
        temp_re = fminf(fmaxf(0.0F, rtb_RateTransition3), Slew);

        /*  set up speed bounds flag */
        /* '<S1031>:1:19' if (NoisePreSlew ~= Noise) */
        if (temp_re != 0.0F)
        {
            /* '<S1031>:1:20' SpeedBoundFlag = 1; */
            Model_Target_B.SpeedBoundFlag = 1.0;
        }
        else
        {
            /* '<S1031>:1:21' else */
            /* '<S1031>:1:22' SpeedBoundFlag = 0; */
            Model_Target_B.SpeedBoundFlag = 0.0;
        }
    }
    else
    {
        /* '<S1031>:1:24' else */
        /*  else: pass noise through */
        /*  unset speed bound flag */
        /* '<S1031>:1:27' NoisePreSlew = single(Noise); */
        temp_re = 0.0F;

        /* '<S1031>:1:28' SpeedBoundFlag = 0; */
        Model_Target_B.SpeedBoundFlag = 0.0;

        /* '<S1031>:1:29' CurrNoiseBoundL = single(0); */
        rtb_RateTransition3 = 0.0F;

        /* '<S1031>:1:30' CurrNoiseBoundH = single(0); */
        Slew = 0.0F;
    }

    Model_Target_B.NoisePreSlew = temp_re;
    Model_Target_B.CurrNoiseBoundL = rtb_RateTransition3;
    Model_Target_B.CurrNoiseBoundH = Slew;

    /* End of MATLAB Function: '<S1022>/SpeedBounds' */
    /* MATLAB Function: '<S1021>/Slew' */
    /* MATLAB Function 'Slew': '<S1025>:1' */
    /* '<S1025>:1:5' if isempty(PrevChange) */
    /* '<S1025>:1:6' if isempty(PrevDelta) */
    /* '<S1025>:1:7' if isempty(PrevPostSlew) */
    if (!Model_Target_DW.PrevPostSlew_not_empty_i)
    {
        /* '<S1025>:1:7' ; */
        /* '<S1025>:1:7' PrevPostSlew = single(SlewInit); */
        Model_Target_DW.PrevPostSlew_h =
            Model_Target_PreAmp0.AudiopilotLfNoiseSpeedBoundsMinBoundsLowestValDbspl;
        Model_Target_DW.PrevPostSlew_not_empty_i = true;
    }

    /* '<S1025>:1:9' Delta = PreSlew - PrevPostSlew; */
    rtb_Switch_a4 = Model_Target_B.NoisePreSlew - Model_Target_DW.PrevPostSlew_h;

    /* '<S1025>:1:11' if Delta > 0 */
    if (rtb_Switch_a4 > 0.0F)
    {
        /*  setup for positive delta */
        /* '<S1025>:1:12' Change = min(SlewAttack, Delta); */
        rtb_RateTransition3 = fminf
            (Model_Target_PreAmp0.AudiopilotLfNoiseSlewAttackDbPerSample,
             rtb_Switch_a4);

        /* '<S1025>:1:13' SlowSlew = min(SlowSlew, Delta); */
        temp_re = fminf
            (Model_Target_PreAmp0.AudiopilotLfNoiseSlewSlowDbPerSample,
             rtb_Switch_a4);
    }
    else
    {
        /* '<S1025>:1:14' else */
        /*  setup for negative delta */
        /* '<S1025>:1:15' Change = max(SlewDecay, Delta); */
        rtb_RateTransition3 = fmaxf
            (Model_Target_PreAmp0.AudiopilotLfNoiseSlewDecayDbPerSample,
             rtb_Switch_a4);

        /* '<S1025>:1:16' SlowSlew = max(-SlowSlew, Delta); */
        temp_re = fmaxf
            (-Model_Target_PreAmp0.AudiopilotLfNoiseSlewSlowDbPerSample,
             rtb_Switch_a4);
    }

    /* '<S1025>:1:19' if PrevDelta*Delta > 0 */
    if (Model_Target_DW.PrevDelta_b * rtb_Switch_a4 > 0.0F)
    {
        /*  did we reach our target? */
        /* '<S1025>:1:20' Slew = single(PrevChange); */
        Slew = Model_Target_DW.PrevChange_n;

        /*  no, continue the current path */
    }
    else
    {
        /* '<S1025>:1:21' else */
        /*  otherwise, we have reached our target */
        /* '<S1025>:1:22' Slew = single(0); */
        Slew = 0.0F;

        /*  no slew in the dead zone */
    }

    /* '<S1025>:1:25' if SpeedBoundFlag && Slew == 0 */
    if ((Model_Target_B.SpeedBoundFlag != 0.0) && (Slew == 0.0F))
    {
        /*  are we speed-bounded? */
        /* '<S1025>:1:26' Slew = SlowSlew; */
        Slew = temp_re;

        /*  yes, change to a slow slew */
    }

    /* '<S1025>:1:29' if (abs(Delta) <= SlewThreshold) ...		% are we within the zone? */
    /* '<S1025>:1:30' 		&& (abs(Slew) < abs(Change)) */
    if ((qhmath_abs_f(rtb_Switch_a4) <=
            Model_Target_PreAmp0.AudiopilotLfNoiseSlewThresholdDb) &&
            (qhmath_abs_f(Slew) < qhmath_abs_f(rtb_RateTransition3)))
    {
        /* 		% are we within the zone? */
        /*  is change still bigger than slew? */
        /*  (offshoot protection)x */
        /* '<S1025>:1:32' Change = Slew; */
        rtb_RateTransition3 = Slew;

        /*  freeze or continue the current */
    }

    /* '<S1025>:1:35' PrevDelta = Delta; */
    Model_Target_DW.PrevDelta_b = rtb_Switch_a4;

    /* '<S1025>:1:36' PrevChange = Change; */
    Model_Target_DW.PrevChange_n = rtb_RateTransition3;

    /* '<S1025>:1:38' PrevPostSlew = PrevPostSlew + Change; */
    Model_Target_DW.PrevPostSlew_h += rtb_RateTransition3;

    /* '<S1025>:1:39' PostSlew = PrevPostSlew; */
    Model_Target_B.PostSlew_l = Model_Target_DW.PrevPostSlew_h;

    /* End of MATLAB Function: '<S1021>/Slew' */

    /* RateTransition: '<S879>/LFNoise postSmooth Rate Transition' */
    Model_Target_DW.LFNoisepostSmoothRateTransition_Buffer[Model_Target_DW.LFNoisepostSmoothRateTransition_ActiveBufIdx
        == 0] = Model_Target_B.PostSlew_l;
    Model_Target_DW.LFNoisepostSmoothRateTransition_ActiveBufIdx = (int8_T)
        (Model_Target_DW.LFNoisepostSmoothRateTransition_ActiveBufIdx == 0);

    /* RateTransition: '<S879>/LFNoise preSmooth Rate Transition' */
    Model_Target_DW.LFNoisepreSmoothRateTransition_Buffer[Model_Target_DW.LFNoisepreSmoothRateTransition_ActiveBufIdx
        == 0] = Model_Target_B.RateTransition;
    Model_Target_DW.LFNoisepreSmoothRateTransition_ActiveBufIdx = (int8_T)
        (Model_Target_DW.LFNoisepreSmoothRateTransition_ActiveBufIdx == 0);

    /* RateTransition: '<S881>/Rate Transition6' */
    Model_Target_DW.RateTransition6_semaphoreTaken = 1;
    rtb_Switch_a4 = Model_Target_DW.RateTransition6_Buffer0;
    Model_Target_DW.RateTransition6_semaphoreTaken = 0;

    /* MinMax: '<S961>/MinMax1' incorporates:
     *  Bias: '<S961>/Bias'
     *  Gain: '<S961>/Gain'
     *  Sum: '<S961>/Add'
     */
    rtb_Switch_a4 = fmaxf(fmaxf(Model_Target_B.PostSlew_l, rtb_Switch_a4),
                          (Model_Target_B.PostSlew_l + rtb_Switch_a4) * 0.5F +
                          3.7F);

    /* Buffer: '<S978>/Buffer' */
    ix = 0;
    iy = Model_Target_DW.Buffer_outBufPtrIdx_i - 128;
    if (Model_Target_DW.Buffer_outBufPtrIdx_i - 128 < 0)
    {
        iy = Model_Target_DW.Buffer_outBufPtrIdx_i + 384;
    }

    b_i = 256;
    if (iy > 256)
    {
        for (iDelta = 0; iDelta < 512 - iy; iDelta++)
        {
            Model_Target_B.u[iDelta] = Model_Target_DW.Buffer_CircBuf_d[iy +
                iDelta];
        }

        ix = 512 - iy;
        b_i = iy - 256;
        iy = 0;
    }

    for (iDelta = 0; iDelta < b_i; iDelta++)
    {
        Model_Target_B.u[ix + iDelta] = Model_Target_DW.Buffer_CircBuf_d[iy +
            iDelta];
    }

    ix += b_i;
    iy = Model_Target_DW.Buffer_outBufPtrIdx_i - 128;
    if (Model_Target_DW.Buffer_outBufPtrIdx_i - 128 < 0)
    {
        iy = Model_Target_DW.Buffer_outBufPtrIdx_i + 384;
    }

    b_i = 256;
    if (iy > 256)
    {
        for (iDelta = 0; iDelta < 512 - iy; iDelta++)
        {
            Model_Target_B.u[ix + iDelta] = Model_Target_DW.Buffer_CircBuf_d[(iy
                + iDelta) + 512];
        }

        ix = (ix - iy) + 512;
        b_i = iy - 256;
        iy = 0;
    }

    for (iDelta = 0; iDelta < b_i; iDelta++)
    {
        Model_Target_B.u[ix + iDelta] = Model_Target_DW.Buffer_CircBuf_d[(iy +
            iDelta) + 512];
    }

    iy += b_i;
    if (iy == 512)
    {
        iy = 0;
    }

    Model_Target_DW.Buffer_outBufPtrIdx_i = iy;

    /* End of Buffer: '<S978>/Buffer' */

    /* MATLAB Function: '<S982>/Windowing' incorporates:
     *  Constant: '<S978>/const'
     */
    /*  Get sizes */
    /* MATLAB Function 'RfftWindowing/Windowing': '<S984>:1' */
    /* '<S984>:1:4' [~, numChannels] = size(u); */
    /*  Loop since array-vector multiply operation doesn't work here */
    /*  Input/Output have the same variable name for in-place processing */
    /* '<S984>:1:8' for i = 1:numChannels */
    for (iDelta = 0; iDelta < 2; iDelta++)
    {
        /* '<S984>:1:9' u(:, i) = u(:,i) .* win; */
        for (ix = 0; ix < 256; ix++)
        {
            iy = (iDelta << 8) + ix;
            Model_Target_B.u[iy] *= Model_Target_ConstP.pooled66[ix];
        }
    }

    /* End of MATLAB Function: '<S982>/Windowing' */

    /* MATLAB Function: '<S986>/MATLAB Function1' */
    /* MATLAB Function 'Rfft/Rfft/Generic/MATLAB Function1': '<S987>:1' */
    /* '<S987>:1:3' y = RfftProcessSim(u, fftSize); */
    /*  Calculates the FFT of a purely real input signal. Uses an optimized 2 for */
    /*  1 Rfft algorithm.  */
    /*  Inputs: */
    /*        u: input of size (fftSize x numChannels) */
    /*        fftSize: Size of FFT */
    /*  Output: */
    /*        y: array of size (fftSize/2 + 1 x numChannels) number of unique FFT */
    /*            coefficients of the input */
    /* -------------------------------------------------------------------------- */
    /*  Function for simulation */
    /* 'RfftProcessSim:14' half_spectrum_size = (fftSize/2) + 1; */
    /* 'RfftProcessSim:15' numChannels = size(u,2); */
    /* 'RfftProcessSim:16' numChannelPairs = floor(numChannels/2); */
    /* 'RfftProcessSim:17' extraChannel = numChannels - numChannelPairs*2; */
    /*  Initialize output */
    /* 'RfftProcessSim:21' y = single(complex(zeros(half_spectrum_size,size(u,2)))); */
    memset(&Model_Target_B.y_o[0], 0, 258U * sizeof(creal32_T));

    /*  Calculate 2 Channel Real FFT for every channel pair */
    /* 'RfftProcessSim:24' for pairIdx = 1: numChannelPairs */
    /* 'RfftProcessSim:25' chan1Idx = pairIdx*2-1; */
    /* 'RfftProcessSim:26' chan2Idx = chan1Idx + 1; */
    /* 'RfftProcessSim:27' [X1, X2] = Rfft2ChanProcessSim(u(:,chan1Idx), u(:,chan2Idx), fftSize); */
    /*  Computes the Real FFT of a Two Channel Signal.  */
    /*  This is the Generic C Variant. */
    /*  Computation of Two Real FFTs is done using a single complex FFT. */
    /*  Channel 1 is loaded into the real part and Channel 2 into imag. */
    /*  Complex FFT is computed. */
    /*  FFT of channel 1 is extracted as the conjugate symmetric part  */
    /*  FFT of channel 3 is extracted as the conjugate anti-symmetric part . */
    /*  Inputs: */
    /*      x1 - purely real channel 1  */
    /*      x2 - purely real channel 2 */
    /*      fftSize - length of x1 and x2. Also the size of FFT/ */
    /*  Outputs: */
    /*      X1 - FFT of x1 */
    /*      X2 - FFT of x2 */
    /*  ------------------------------------------------------------------------- */
    /*  Output size equal to number of independent FFT coefficients */
    /* 'Rfft2ChanProcessSim:19' half_spectrum_size = (fftSize/2) + 1; */
    /*  Compute Complex FFT */
    /* 'Rfft2ChanProcessSim:22' X = fft(complex(x1, x2)); */
    for (ix = 0; ix < 256; ix++)
    {
        Model_Target_B.x[ix].re = Model_Target_B.u[ix];
        Model_Target_B.x[ix].im = Model_Target_B.u[ix + 256];
    }

    iy = 0;
    ju = 0;
    for (iDelta = 0; iDelta < 255; iDelta++)
    {
        boolean_T rtb_RateTransition1_ml;
        Model_Target_B.X[iy] = Model_Target_B.x[iDelta];
        iy = 256;
        rtb_RateTransition1_ml = true;
        while (rtb_RateTransition1_ml)
        {
            iy >>= 1;
            ju ^= iy;
            rtb_RateTransition1_ml = ((ju & iy) == 0);
        }

        iy = ju;
    }

    Model_Target_B.X[iy] = Model_Target_B.x[255];
    for (iDelta = 0; iDelta <= 254; iDelta += 2)
    {
        rtb_RateTransition3 = Model_Target_B.X[iDelta + 1].re;
        temp_re = Model_Target_B.X[iDelta + 1].im;
        Model_Target_B.X[iDelta + 1].re = Model_Target_B.X[iDelta].re -
            rtb_RateTransition3;
        Model_Target_B.X[iDelta + 1].im = Model_Target_B.X[iDelta].im - temp_re;
        Model_Target_B.X[iDelta].re += rtb_RateTransition3;
        Model_Target_B.X[iDelta].im += temp_re;
    }

    iDelta = 2;
    ix = 4;
    ju = 64;
    iy = 253;
    while (ju > 0)
    {
        int32_T istart;
        int32_T temp_re_tmp;
        for (b_i = 0; b_i < iy; b_i += ix)
        {
            temp_re_tmp = b_i + iDelta;
            temp_re = Model_Target_B.X[temp_re_tmp].re;
            rtb_RateTransition3 = Model_Target_B.X[temp_re_tmp].im;
            Model_Target_B.X[temp_re_tmp].re = Model_Target_B.X[b_i].re -
                temp_re;
            Model_Target_B.X[temp_re_tmp].im = Model_Target_B.X[b_i].im -
                rtb_RateTransition3;
            Model_Target_B.X[b_i].re += temp_re;
            Model_Target_B.X[b_i].im += rtb_RateTransition3;
        }

        istart = 1;
        for (j = ju; j < 128; j += ju)
        {
            int32_T ihi;
            Slew = b[j];
            twid_im = c[j];
            b_i = istart;
            ihi = istart + iy;
            while (b_i < ihi)
            {
                temp_re_tmp = b_i + iDelta;
                rtb_RateTransition3 = Model_Target_B.X[temp_re_tmp].im;
                ar = Model_Target_B.X[temp_re_tmp].re;
                temp_re = ar * Slew - rtb_RateTransition3 * twid_im;
                rtb_RateTransition3 = rtb_RateTransition3 * Slew + ar * twid_im;
                Model_Target_B.X[temp_re_tmp].re = Model_Target_B.X[b_i].re -
                    temp_re;
                Model_Target_B.X[temp_re_tmp].im = Model_Target_B.X[b_i].im -
                    rtb_RateTransition3;
                Model_Target_B.X[b_i].re += temp_re;
                Model_Target_B.X[b_i].im += rtb_RateTransition3;
                b_i += ix;
            }

            istart++;
        }

        ju /= 2;
        iDelta = ix;
        ix += ix;
        iy -= iDelta;
    }

    /*  Temporary variable for calculating outputs */
    /* 'Rfft2ChanProcessSim:25' Z = conj(circshift(flip(X),1)); */
    memcpy(&Model_Target_B.x[0], &Model_Target_B.X[0], sizeof(creal32_T) << 8U);
    for (iDelta = 0; iDelta < 128; iDelta++)
    {
        temp_re = Model_Target_B.x[iDelta].re;
        rtb_RateTransition3 = Model_Target_B.x[iDelta].im;
        Model_Target_B.x[iDelta] = Model_Target_B.x[255 - iDelta];
        Model_Target_B.x[255 - iDelta].re = temp_re;
        Model_Target_B.x[255 - iDelta].im = rtb_RateTransition3;
    }

    memcpy(&Model_Target_B.a[0], &Model_Target_B.x[0], sizeof(creal32_T) << 8U);
    for (iDelta = 254; iDelta >= 0; iDelta--)
    {
        Model_Target_B.a[iDelta + 1] = Model_Target_B.a[iDelta];
    }

    Model_Target_B.a[0] = Model_Target_B.x[255];

    /*  % Nullcopy copies type, size, and complexity to output */
    /* 'Rfft2ChanProcessSim:28' X1 = complex(single(zeros(half_spectrum_size, 1))); */
    /* 'Rfft2ChanProcessSim:29' X2 = complex(single(zeros(half_spectrum_size, 1))); */
    /*  Apply FFT properties of symmetry to extract FFT of even and imag channel */
    /* 'Rfft2ChanProcessSim:32' X1(1:half_spectrum_size) = (X(1:half_spectrum_size) + Z(1:half_spectrum_size))/2; */
    /* 'Rfft2ChanProcessSim:33' X2(1:half_spectrum_size) = (X(1:half_spectrum_size) - Z(1:half_spectrum_size))/2j; */
    /* 'RfftProcessSim:28' y(:,chan1Idx)   = X1(:); */
    /* 'RfftProcessSim:29' y(:,chan2Idx)   = X2(:); */
    for (iDelta = 0; iDelta < 129; iDelta++)
    {
        real32_T ai;
        rtb_RateTransition3 = Model_Target_B.X[iDelta].re;
        temp_re = Model_Target_B.X[iDelta].im;
        Slew = Model_Target_B.a[iDelta].re;
        twid_im = -Model_Target_B.a[iDelta].im;
        ar = rtb_RateTransition3 + Slew;
        ai = temp_re + twid_im;
        if (ai == 0.0F)
        {
            Model_Target_B.y_o[iDelta].re = qhmath_div_f(ar, 2.0F);
            Model_Target_B.y_o[iDelta].im = 0.0F;
        }
        else if (ar == 0.0F)
        {
            Model_Target_B.y_o[iDelta].re = 0.0F;
            Model_Target_B.y_o[iDelta].im = qhmath_div_f(ai, 2.0F);
        }
        else
        {
            Model_Target_B.y_o[iDelta].re = qhmath_div_f(ar, 2.0F);
            Model_Target_B.y_o[iDelta].im = qhmath_div_f(ai, 2.0F);
        }

        ar = rtb_RateTransition3 - Slew;
        ai = temp_re - twid_im;
        if (ar == 0.0F)
        {
            Model_Target_B.y_o[iDelta + 129].re = qhmath_div_f(ai, 2.0F);
            Model_Target_B.y_o[iDelta + 129].im = 0.0F;
        }
        else if (ai == 0.0F)
        {
            Model_Target_B.y_o[iDelta + 129].re = 0.0F;
            Model_Target_B.y_o[iDelta + 129].im = -qhmath_div_f(ar, 2.0F);
        }
        else
        {
            Model_Target_B.y_o[iDelta + 129].re = qhmath_div_f(ai, 2.0F);
            Model_Target_B.y_o[iDelta + 129].im = -qhmath_div_f(ar, 2.0F);
        }
    }

    /* End of MATLAB Function: '<S986>/MATLAB Function1' */

    /* S-Function (sdspsubmtrx): '<S977>/BandLimitingMic' */
    /*  if numChannels is odd, there is an extra channel, Calculate RFFT normally */
    /* 'RfftProcessSim:33' if extraChannel == 1 */
    memcpy(&Model_Target_B.BandLimitingMic[0], &Model_Target_B.y_o[135], 31U *
           sizeof(creal32_T));

    /* S-Function (sdspsubmtrx): '<S977>/BandLimitingRef' */
    memcpy(&Model_Target_B.BandLimitingRef[0], &Model_Target_B.y_o[6], 31U *
           sizeof(creal32_T));

    /* MATLAB Function: '<S977>/CrossPSD' incorporates:
     *  Constant: '<S977>/WelchSize'
     */
    /*  This function forms the power spectral density over */
    /*  LFWELCHSIZE frames. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfMusicNoiseSeparation/Coherence/CrossPSD': '<S979>:1' */
    /* '<S979>:1:5' K = LFWELCHSIZE; */
    /*  Double States */
    /*  Holds the PSD accumulation */
    /*  Contains the previous PSD */
    /* '<S979>:1:12' if isempty(counter) */
    /* '<S979>:1:13' if isempty(Psd) */
    /* '<S979>:1:14' if isempty(prevout) */
    /*  Increment the counter */
    /* '<S979>:1:17' counter = counter + 1; */
    Model_Target_DW.counter_l++;

    /*  The output is the previous PSD for K frames until */
    /*  the next PSD is ready */
    /* '<S979>:1:21' if counter < K */
    if (Model_Target_DW.counter_l < 3.0)
    {
        /* '<S979>:1:22' Psd = Psd + u/K; */
        /* '<S979>:1:23' y = prevout; */
        for (ix = 0; ix < 31; ix++)
        {
            /* Math: '<S977>/Math Function' incorporates:
             *  S-Function (sdspsubmtrx): '<S977>/BandLimitingMic'
             */
            rtb_RateTransition3 = Model_Target_B.BandLimitingMic[ix].re;
            temp_re = -Model_Target_B.BandLimitingMic[ix].im;

            /* Product: '<S977>/Product3' incorporates:
             *  S-Function (sdspsubmtrx): '<S977>/BandLimitingRef'
             */
            Slew = Model_Target_B.BandLimitingRef[ix].re;
            twid_im = Model_Target_B.BandLimitingRef[ix].im;
            ar = Slew * rtb_RateTransition3 - twid_im * temp_re;
            temp_re = Slew * temp_re + twid_im * rtb_RateTransition3;
            if (temp_re == 0.0F)
            {
                rtb_RateTransition3 = qhmath_div_f(ar, 3.0F);
                temp_re = 0.0F;
            }
            else if (ar == 0.0F)
            {
                rtb_RateTransition3 = 0.0F;
                temp_re = qhmath_div_f(temp_re, 3.0F);
            }
            else
            {
                rtb_RateTransition3 = qhmath_div_f(ar, 3.0F);
                temp_re = qhmath_div_f(temp_re, 3.0F);
            }

            Model_Target_DW.Psd[ix].re += rtb_RateTransition3;
            Model_Target_DW.Psd[ix].im += temp_re;
            y_p[ix] = Model_Target_DW.prevout[ix];
        }
    }
    else if (Model_Target_DW.counter_l == 3.0)
    {
        /* '<S979>:1:24' elseif counter ==K */
        /* '<S979>:1:25' y = Psd; */
        /* '<S979>:1:26' prevout = Psd; */
        /* '<S979>:1:27' Psd = complex(single(zeros(size(u)))); */
        for (iDelta = 0; iDelta < 31; iDelta++)
        {
            y_p[iDelta] = Model_Target_DW.Psd[iDelta];
            Model_Target_DW.prevout[iDelta] = Model_Target_DW.Psd[iDelta];
            Model_Target_DW.Psd[iDelta].re = 0.0F;
            Model_Target_DW.Psd[iDelta].im = 0.0F;
        }

        /* '<S979>:1:28' counter = 0; */
        Model_Target_DW.counter_l = 0.0;
    }
    else
    {
        /* '<S979>:1:29' else */
        /* '<S979>:1:30' y = prevout; */
        memcpy(&y_p[0], &Model_Target_DW.prevout[0], 31U * sizeof(creal32_T));
    }

    /* End of MATLAB Function: '<S977>/CrossPSD' */

    /* MATLAB Function: '<S977>/RefPSD ' incorporates:
     *  Constant: '<S977>/WelchSize'
     *  Math: '<S977>/Math Function2'
     *
     * About '<S977>/Math Function2':
     *  Operator: magnitude^2
     */
    /*  This function forms the power spectral density over */
    /*  LFWELCHSIZE frames. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfMusicNoiseSeparation/Coherence/RefPSD ': '<S981>:1' */
    /* '<S981>:1:5' K = LFWELCHSIZE; */
    /*  Double States */
    /*  Holds the PSD accumulation */
    /*  Contains the previous PSD */
    /* '<S981>:1:12' if isempty(counter) */
    /* '<S981>:1:13' if isempty(Psd) */
    /* '<S981>:1:14' if isempty(prevout) */
    /*  Increment the counter */
    /* '<S981>:1:17' counter = counter + 1; */
    Model_Target_DW.counter_f++;

    /*  The output is the previous PSD for K frames until */
    /*  the next PSD is ready */
    /* '<S981>:1:21' if counter < K */
    if (Model_Target_DW.counter_f < 3.0)
    {
        /* '<S981>:1:22' Psd = Psd + u/K; */
        /* '<S981>:1:23' y = prevout; */
        for (ix = 0; ix < 31; ix++)
        {
            /* Math: '<S977>/Math Function2' incorporates:
             *  Math: '<S977>/Math Function3'
             *  S-Function (sdspsubmtrx): '<S977>/BandLimitingMic'
             *  S-Function (sdspsubmtrx): '<S977>/BandLimitingRef'
             *
             * About '<S977>/Math Function2':
             *  Operator: magnitude^2
             *
             * About '<S977>/Math Function3':
             *  Operator: magnitude^2
             */
            tmp = &Model_Target_B.BandLimitingRef[ix];
            Model_Target_DW.Psd_g[ix] += qhmath_div_f(tmp->re * tmp->re +
                tmp->im * tmp->im, 3.0F);
            y_la[ix] = Model_Target_DW.prevout_j[ix];
        }
    }
    else if (Model_Target_DW.counter_f == 3.0)
    {
        /* '<S981>:1:24' elseif counter ==K */
        /* '<S981>:1:25' y = Psd; */
        /* '<S981>:1:26' prevout = Psd; */
        /* '<S981>:1:27' Psd = single(zeros(size(u))); */
        for (iDelta = 0; iDelta < 31; iDelta++)
        {
            y_la[iDelta] = Model_Target_DW.Psd_g[iDelta];
            Model_Target_DW.prevout_j[iDelta] = Model_Target_DW.Psd_g[iDelta];
            Model_Target_DW.Psd_g[iDelta] = 0.0F;
        }

        /* '<S981>:1:28' counter = 0; */
        Model_Target_DW.counter_f = 0.0;
    }
    else
    {
        /* '<S981>:1:29' else */
        /* '<S981>:1:30' y = prevout; */
        memcpy(&y_la[0], &Model_Target_DW.prevout_j[0], 31U * sizeof(real32_T));
    }

    /* End of MATLAB Function: '<S977>/RefPSD ' */

    /* DownSample: '<S977>/DownsampleGxx' incorporates:
     *  DownSample: '<S977>/DownsampleGyx'
     */
    if (Model_Target_M->Timing.RateInteraction.TID7_8)
    {
        /* DownSample: '<S977>/DownsampleGxx' */
        memcpy(&Model_Target_B.DownsampleGxx[0], &y_la[0], 31U * sizeof(real32_T));

        /* DownSample: '<S977>/DownsampleGyx' */
        memcpy(&Model_Target_B.DownsampleGyx[0], &y_p[0], 31U * sizeof(creal32_T));
    }

    /* End of DownSample: '<S977>/DownsampleGxx' */

    /* MATLAB Function: '<S977>/MicPSD' incorporates:
     *  Constant: '<S977>/WelchSize'
     *  Math: '<S977>/Math Function3'
     *
     * About '<S977>/Math Function3':
     *  Operator: magnitude^2
     */
    /*  This function forms the power spectral density over */
    /*  LFWELCHSIZE frames. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfMusicNoiseSeparation/Coherence/MicPSD': '<S980>:1' */
    /* '<S980>:1:5' K = LFWELCHSIZE; */
    /*  Double States */
    /*  Holds the PSD accumulation */
    /*  Contains the previous PSD */
    /* '<S980>:1:12' if isempty(counter) */
    /* '<S980>:1:13' if isempty(Psd) */
    /* '<S980>:1:14' if isempty(prevout) */
    /*  Increment the counter */
    /* '<S980>:1:17' counter = counter + 1; */
    Model_Target_DW.counter_fg++;

    /*  The output is the previous PSD for K frames until */
    /*  the next PSD is ready */
    /* '<S980>:1:21' if counter < K */
    if (Model_Target_DW.counter_fg < 3.0)
    {
        /* '<S980>:1:22' Psd = Psd + u/K; */
        /* '<S980>:1:23' y = prevout; */
        for (ix = 0; ix < 31; ix++)
        {
            /* Math: '<S977>/Math Function3' incorporates:
             *  Math: '<S977>/Math Function2'
             *  S-Function (sdspsubmtrx): '<S977>/BandLimitingMic'
             *  S-Function (sdspsubmtrx): '<S977>/BandLimitingRef'
             *
             * About '<S977>/Math Function3':
             *  Operator: magnitude^2
             *
             * About '<S977>/Math Function2':
             *  Operator: magnitude^2
             */
            tmp = &Model_Target_B.BandLimitingMic[ix];
            Model_Target_DW.Psd_h[ix] += qhmath_div_f(tmp->re * tmp->re +
                tmp->im * tmp->im, 3.0F);
            y_la[ix] = Model_Target_DW.prevout_c[ix];
        }
    }
    else if (Model_Target_DW.counter_fg == 3.0)
    {
        /* '<S980>:1:24' elseif counter ==K */
        /* '<S980>:1:25' y = Psd; */
        /* '<S980>:1:26' prevout = Psd; */
        /* '<S980>:1:27' Psd = single(zeros(size(u))); */
        for (iDelta = 0; iDelta < 31; iDelta++)
        {
            y_la[iDelta] = Model_Target_DW.Psd_h[iDelta];
            Model_Target_DW.prevout_c[iDelta] = Model_Target_DW.Psd_h[iDelta];
            Model_Target_DW.Psd_h[iDelta] = 0.0F;
        }

        /* '<S980>:1:28' counter = 0; */
        Model_Target_DW.counter_fg = 0.0;
    }
    else
    {
        /* '<S980>:1:29' else */
        /* '<S980>:1:30' y = prevout; */
        memcpy(&y_la[0], &Model_Target_DW.prevout_c[0], 31U * sizeof(real32_T));
    }

    /* End of MATLAB Function: '<S977>/MicPSD' */

    /* DownSample: '<S977>/DownsampleGyy' */
    if (Model_Target_M->Timing.RateInteraction.TID7_8)
    {
        /* DownSample: '<S977>/DownsampleGyy' */
        memcpy(&Model_Target_B.DownsampleGyy[0], &y_la[0], 31U * sizeof(real32_T));
    }

    /* End of DownSample: '<S977>/DownsampleGyy' */
    /* RateTransition: '<S664>/Rate Transition1' */
    Model_Target_DW.RateTransition1_Buffer_k[Model_Target_DW.RateTransition1_ActiveBufIdx
        == 0] = Model_Target_B.PostSlew_l;
    Model_Target_DW.RateTransition1_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition1_ActiveBufIdx == 0);

    /* RateTransition: '<S664>/Rate Transition11' */
    Model_Target_DW.RateTransition11_Buffer[Model_Target_DW.RateTransition11_ActiveBufIdx
        == 0] = rtb_Switch_a4;
    Model_Target_DW.RateTransition11_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition11_ActiveBufIdx == 0);

    /* RateTransition: '<S664>/Rate Transition9' */
    Model_Target_DW.RateTransition9_Buffer[Model_Target_DW.RateTransition9_ActiveBufIdx
        == 0] = rtb_Switch_a4;
    Model_Target_DW.RateTransition9_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition9_ActiveBufIdx == 0);

    /* End of Outputs for SubSystem: '<S655>/AudioPilot35' */

    /* Update for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* Update for M-S-Function: '<S971>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoisePostSlew '<S971>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 35, &Model_Target_B.PostSlew_l);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S972>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoisePreSlew '<S972>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 36, &Model_Target_B.NoisePreSlew);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S973>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoisePreSpeedBound '<S973>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 37, &Model_Target_B.RateTransition);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1028>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseSpeedBoundsCurrMax '<S1028>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 38, &Model_Target_B.CurrNoiseBoundH);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1029>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseSpeedBoundsCurrMin '<S1029>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 39, &Model_Target_B.CurrNoiseBoundL);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1030>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseSpeedBoundsFlag '<S1030>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 40, &Model_Target_B.SpeedBoundFlag);

#endif                                 //TSP_ENABLE_ADVANCED

    /* End of Update for SubSystem: '<S655>/AudioPilot35' */
}

/* Model step function for TID8 */
void Model_Target_step8(void)    /* Sample time: [0.55466666666666664s, 0.0s] */
{
    creal32_T *tmp;
    int32_T i;
    real32_T ImpRejFiltCoef;
    real32_T TotalVar;
    real32_T rtb_PreNoisedBSPL;
    real32_T rtb_Sqrt;
    real32_T rtb_Sqrt1;
    real32_T u0;

    /* Outputs for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* Sum: '<S962>/Sum of Elements3' */
    rtb_Sqrt1 = -0.0F;

    /* Sum: '<S962>/Sum of Elements2' */
    rtb_Sqrt = -0.0F;
    for (i = 0; i < 31; i++)
    {
        /* Sum: '<S962>/Sum of Elements3' incorporates:
         *  DownSample: '<S977>/DownsampleGyy'
         */
        rtb_Sqrt1 += Model_Target_B.DownsampleGyy[i];

        /* Math: '<S977>/Math Function1' incorporates:
         *  DownSample: '<S977>/DownsampleGyx'
         *
         * About '<S977>/Math Function1':
         *  Operator: magnitude^2
         */
        tmp = &Model_Target_B.DownsampleGyx[i];

        /* Product: '<S977>/Divide' incorporates:
         *  Constant: '<S977>/DivideByZero'
         *  DownSample: '<S977>/DownsampleGxx'
         *  DownSample: '<S977>/DownsampleGyy'
         *  Math: '<S977>/Math Function1'
         *  Product: '<S977>/Product'
         *  Sum: '<S977>/Add1'
         *
         * About '<S977>/Math Function1':
         *  Operator: magnitude^2
         */
        u0 = qhmath_div_f(1.0F, Model_Target_B.DownsampleGxx[i] *
                          Model_Target_B.DownsampleGyy[i] + 2.22044605E-16F) *
            (tmp->re * tmp->re + tmp->im * tmp->im);

        /* Saturate: '<S977>/Saturation' */
        if (u0 > 1.0F)
        {
            u0 = 1.0F;
        }
        else if (u0 < 0.0F)
        {
            u0 = 0.0F;
        }

        /* Sum: '<S962>/Sum of Elements2' incorporates:
         *  Constant: '<S962>/Constant1'
         *  DownSample: '<S977>/DownsampleGyy'
         *  Product: '<S962>/Product'
         *  Saturate: '<S977>/Saturation'
         *  Sum: '<S962>/Subtract1'
         */
        rtb_Sqrt += (1.0F - u0) * Model_Target_B.DownsampleGyy[i];
    }

    /* Gain: '<S962>/Gain3' incorporates:
     *  Sqrt: '<S962>/Sqrt2'
     */
    Model_Target_B.Gain3 = 0.0078125F * qhmath_sqrt_f(rtb_Sqrt1);

    /* Gain: '<S962>/Gain2' incorporates:
     *  Constant: '<S962>/Constant'
     *  MinMax: '<S962>/Max'
     *  Sqrt: '<S962>/Sqrt1'
     *  Sum: '<S962>/Subtract2'
     */
    Model_Target_B.Gain2 = qhmath_sqrt_f(fmaxf(rtb_Sqrt1 - rtb_Sqrt, 0.0F)) *
        0.0078125F;

    /* Gain: '<S962>/Gain' incorporates:
     *  Sqrt: '<S962>/Sqrt'
     */
    Model_Target_B.Gain = 0.0078125F * qhmath_sqrt_f(rtb_Sqrt);

    /* MATLAB Function: '<S881>/LfNoiseEnergyCalculation' */
    /*  Energy salculation has been simplified from before */
    /*  This is now just a smoothing of the output from the */
    /*  coherence calculations. */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfNoiseEnergyCalculation': '<S963>:1' */
    /*  States  */
    /*  Initialization */
    /* '<S963>:1:11' if isempty(MusicLPState) */
    /* '<S963>:1:14' if isempty(NoiseLPState) */
    /* '<S963>:1:17' if isempty(MicLPState) */
    /*  Energy Conversion */
    /* '<S963>:1:22' MusicLPState     = MusicLPState*EngyFiltCoef ... */
    /* '<S963>:1:23' 	+ abs(Music)*(1-EngyFiltCoef); */
    Model_Target_DW.MusicLPState = (1.0F -
        Model_Target_PreAmp0.AudiopilotLfNoiseEnergyLpfCoef) * qhmath_abs_f
        (Model_Target_B.Gain2) + Model_Target_DW.MusicLPState *
        Model_Target_PreAmp0.AudiopilotLfNoiseEnergyLpfCoef;

    /* '<S963>:1:24' NoiseLPState     = NoiseLPState*EngyFiltCoef ... */
    /* '<S963>:1:25' 	+ abs(Noise)*(1-EngyFiltCoef); */
    Model_Target_DW.NoiseLPState = (1.0F -
        Model_Target_PreAmp0.AudiopilotLfNoiseEnergyLpfCoef) * qhmath_abs_f
        (Model_Target_B.Gain) + Model_Target_DW.NoiseLPState *
        Model_Target_PreAmp0.AudiopilotLfNoiseEnergyLpfCoef;

    /* '<S963>:1:26' MicLPState       = MicLPState*EngyFiltCoef ... */
    /* '<S963>:1:27' 	+ abs(Mic)*(1-EngyFiltCoef); */
    Model_Target_DW.MicLPState = (1.0F -
        Model_Target_PreAmp0.AudiopilotLfNoiseEnergyLpfCoef) * qhmath_abs_f
        (Model_Target_B.Gain3) + Model_Target_DW.MicLPState *
        Model_Target_PreAmp0.AudiopilotLfNoiseEnergyLpfCoef;

    /* S-Function (TOP_MEX): '<S992>/TOP' */
    /*  Output */
    /* '<S963>:1:30' MusicLP = MusicLPState; */
    /* '<S963>:1:31' NoiseLP = NoiseLPState; */
    /* '<S963>:1:32' MicLP = MicLPState; */
    /* MATLAB Function: '<S964>/NoiseCalculations' incorporates:
     *  MATLAB Function: '<S881>/LfNoiseEnergyCalculation'
     */
    /*  Function that conditions the noise energy. */
    /*  Performs impulse rejection */
    /*  Microphone energy check */
    /*  Convert to dBSPL */
    /*  Also outputs various intermediate check points */
    /* MATLAB Function 'PreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfNoiseImpulseRejection/NoiseCalculations': '<S996>:1' */
    /*  States */
    /*  Initialize to zero */
    /* '<S996>:1:19' if isempty(ImpFiltState) */
    /* '<S996>:1:22' if isempty(FiltOut) */
    if (!Model_Target_DW.FiltOut_not_empty)
    {
        /* '<S996>:1:23' FiltOut   = single(ImpRejFiltOutMin); */
        Model_Target_DW.FiltOut =
            Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionOutputMin;
        Model_Target_DW.FiltOut_not_empty = true;
    }

    /*  Impulse Estimate */
    /*  A First-Order Filter is applied twice */
    /* '<S996>:1:28' ImpFiltState(1) = ImpFiltState(1)*ImpFiltCoef ... */
    /* '<S996>:1:29' 	+ ErrorLP*(1-ImpFiltCoef); */
    Model_Target_DW.ImpFiltState_a[0] = (1.0F -
        Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceFilterCoef)
        * Model_Target_DW.NoiseLPState + Model_Target_DW.ImpFiltState_a[0] *
        Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceFilterCoef;

    /* '<S996>:1:30' ImpFiltState(2) = ImpFiltState(2)*ImpFiltCoef ... */
    /* '<S996>:1:31' 	+ ImpFiltState(1)*(1-ImpFiltCoef); */
    Model_Target_DW.ImpFiltState_a[1] = (1.0F -
        Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceFilterCoef)
        * Model_Target_DW.ImpFiltState_a[0] + Model_Target_DW.ImpFiltState_a[1] *
        Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceFilterCoef;

    /*  Variances & Scaling */
    /* '<S996>:1:34' MusicVar = MusicScale * MusicLP^2; */
    rtb_Sqrt = Model_Target_DW.MusicLPState * Model_Target_DW.MusicLPState *
        Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionMusicVarianceScale;

    /* '<S996>:1:35' NoiseVar = NoiseScale * ImpFiltState(2)^2; */
    rtb_Sqrt1 = Model_Target_DW.ImpFiltState_a[1] *
        Model_Target_DW.ImpFiltState_a[1] *
        Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionNoiseVarianceScale;

    /* '<S996>:1:36' ImpulseVar = ImpulseScale ... */
    /* '<S996>:1:37' 	* (max(0, ErrorLP-ImpFiltState(2)))^2; */
    u0 = fmaxf(0.0F, Model_Target_DW.NoiseLPState -
               Model_Target_DW.ImpFiltState_a[1]);
    u0 = u0 * u0 *
        Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceScale;

    /* '<S996>:1:38' TotalVar = NoiseVar + max(0, MusicVar+ImpulseVar); */
    TotalVar = fmaxf(0.0F, rtb_Sqrt + u0) + rtb_Sqrt1;

    /*  Gamma correction */
    /* '<S996>:1:41' ImpRejFiltCoef = 1 - Gamma0*NoiseVar/(TotalVar+eps); */
    ImpRejFiltCoef = 1.0F - qhmath_div_f
        (Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionGamma0 *
         rtb_Sqrt1, TotalVar + 2.22044605E-16F);

    /*  Impulse Reject Filter */
    /* '<S996>:1:44' FiltOut = ImpRejFiltCoef*FiltOut+ErrorLP*(1-ImpRejFiltCoef); */
    Model_Target_DW.FiltOut = (1.0F - ImpRejFiltCoef) *
        Model_Target_DW.NoiseLPState + ImpRejFiltCoef * Model_Target_DW.FiltOut;

    /*  Set Minimum Bound */
    /* '<S996>:1:47' FiltOut = max(FiltOut, ImpRejFiltOutMin); */
    Model_Target_DW.FiltOut = fmaxf(Model_Target_DW.FiltOut,
        Model_Target_PreAmp0.AudiopilotLfNoiseImpulseRejectionOutputMin);

    /*  Filter Output */
    /* '<S996>:1:50' FilterOut = FiltOut; */
    Model_Target_B.FilterOut = Model_Target_DW.FiltOut;

    /*  dBSPL Conversion and Microphone Energy Check */
    /* '<S996>:1:53' PreNoisedBSPL = db20(FiltOut+eps)... */
    /* '<S996>:1:54' 	+ NoiseOffsetDbspl + SysMaxDbspl; */
    /* '<S996>:1:63' y = 20*log10(abs(x)); */
    rtb_PreNoisedBSPL = (qhmath_log10_f(qhmath_abs_f(Model_Target_DW.FiltOut +
                           2.22044605E-16F)) * 20.0F +
                         Model_Target_PreAmp0.AudiopilotLfNoiseOffsetDb) +
        Model_Target_PreAmp0.AudiopilotLfNoiseSysMaxDbspl;

    /*  Microphone Level */
    /* '<S996>:1:57' MicDbspl= db20(MicLP)+SysMaxDbspl+NoiseOffsetDbspl; */
    /* '<S996>:1:63' y = 20*log10(abs(x)); */
    Model_Target_B.MicDbspl = (20.0F * qhmath_log10_f(qhmath_abs_f
        (Model_Target_DW.MicLPState)) +
        Model_Target_PreAmp0.AudiopilotLfNoiseSysMaxDbspl) +
        Model_Target_PreAmp0.AudiopilotLfNoiseOffsetDb;
    Model_Target_B.ImpRejFiltCoef = ImpRejFiltCoef;
    Model_Target_B.ImpulseVar = u0;
    Model_Target_B.MusicVar = rtb_Sqrt;
    Model_Target_B.NoiseVar = rtb_Sqrt1;
    Model_Target_B.TotalVar = TotalVar;

    /* End of MATLAB Function: '<S964>/NoiseCalculations' */
    /* RateTransition: '<S881>/Rate Transition' */
    Model_Target_DW.RateTransition_Buffer0 = rtb_PreNoisedBSPL;

    /* End of Outputs for SubSystem: '<S655>/AudioPilot35' */

    /* Update for Atomic SubSystem: '<S655>/AudioPilot35' */
    /* Update for M-S-Function: '<S966>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseMicLevel '<S966>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 31, &Model_Target_B.MicDbspl);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S967>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseMicOut '<S967>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 32, &Model_Target_B.Gain3);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S968>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseMusicOut '<S968>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 33, &Model_Target_B.Gain2);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S970>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseNoiseOut '<S970>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 34, &Model_Target_B.Gain);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S988>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionFilterOut '<S988>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 26, &Model_Target_B.FilterOut);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S990>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionFiltCoef '<S990>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 25, &Model_Target_B.ImpRejFiltCoef);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S991>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionImpulseVariance '<S991>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 27, &Model_Target_B.ImpulseVar);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S994>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionMusicVariance '<S994>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 28, &Model_Target_B.MusicVar);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S997>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionNoiseVariance '<S997>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 29, &Model_Target_B.NoiseVar);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1000>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionTotalVariance '<S1000>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0000, 30, &Model_Target_B.TotalVar);

#endif                                 //TSP_ENABLE_ADVANCED

    /* End of Update for SubSystem: '<S655>/AudioPilot35' */
}

/* Model initialize function */
void Model_Target_initialize(void)
{
    {
        int32_T i;

        /* SystemInitialize for Atomic SubSystem: '<Root>/NEAR' */

        /* user code (Initialize function Body) */

        /* InitTriggerControl '<S47>/ITC1' */
        InitTrigger_Model_340_172_156();

        /* InitTriggerControl '<S59>/ITC1' */
        InitTrigger_Model_457_172_156();

        /* InitTriggerControl '<S166>/ITC1' */
        InitTrigger_Model_787_143_65();

        /* Start for If: '<S30>/If' */
        Model_Target_DW.If_ActiveSubsystem = -1;

        /* SystemInitialize for Atomic SubSystem: '<S268>/Ramping_Subsystem' */
        /* SystemInitialize for IfAction SubSystem: '<S282>/ifActionSubsystem' */
        /* InitializeConditions for DiscreteFilter: '<S285>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_n = 1U;

        /* End of SystemInitialize for SubSystem: '<S282>/ifActionSubsystem' */
        /* End of SystemInitialize for SubSystem: '<S268>/Ramping_Subsystem' */

        /* SystemInitialize for Atomic SubSystem: '<S348>/Ramping_Subsystem' */
        /* SystemInitialize for IfAction SubSystem: '<S362>/ifActionSubsystem' */
        /* InitializeConditions for DiscreteFilter: '<S365>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_d = 1U;

        /* End of SystemInitialize for SubSystem: '<S362>/ifActionSubsystem' */
        /* End of SystemInitialize for SubSystem: '<S348>/Ramping_Subsystem' */

        /* SystemInitialize for Atomic SubSystem: '<S428>/Ramping_Subsystem' */
        /* SystemInitialize for IfAction SubSystem: '<S442>/ifActionSubsystem' */
        /* InitializeConditions for DiscreteFilter: '<S445>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_p = 1U;

        /* End of SystemInitialize for SubSystem: '<S442>/ifActionSubsystem' */
        /* End of SystemInitialize for SubSystem: '<S428>/Ramping_Subsystem' */

        /* SystemInitialize for Atomic SubSystem: '<S508>/Ramping_Subsystem' */
        /* SystemInitialize for IfAction SubSystem: '<S522>/ifActionSubsystem' */
        /* InitializeConditions for DiscreteFilter: '<S525>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_m = 1U;

        /* End of SystemInitialize for SubSystem: '<S522>/ifActionSubsystem' */
        /* End of SystemInitialize for SubSystem: '<S508>/Ramping_Subsystem' */

        /* SystemInitialize for MATLAB Function: '<S197>/InnerLink' */
        Model_Target_InnerLink_Init(&Model_Target_DW.sf_InnerLink);

        /* SystemInitialize for MATLAB Function: '<S205>/InnerLink' */
        Model_Target_InnerLink_Init(&Model_Target_DW.sf_InnerLink_g);

        /* SystemInitialize for MATLAB Function: '<S213>/InnerLink' */
        Model_Target_InnerLink_Init(&Model_Target_DW.sf_InnerLink_d);

        /* SystemInitialize for MATLAB Function: '<S221>/InnerLink' */
        Model_Target_InnerLink_Init(&Model_Target_DW.sf_InnerLink_o);

        /* SystemInitialize for IfAction SubSystem: '<S30>/Subsystem' */
        /* '<S42>:1:17' delayIndex = int32(0); */
        /* '<S54>:1:17' delayIndex = int32(0); */

        /* user code (Initialize function Body) */

        /* InitTriggerControl '<S91>/ITC1' */
        InitTrigger_Model_607_172_156();

        /* InitTriggerControl '<S103>/ITC1' */
        InitTrigger_Model_644_172_156();

        /* '<S86>:1:17' delayIndex = int32(0); */
        /* '<S98>:1:17' delayIndex = int32(0); */

        /* End of SystemInitialize for SubSystem: '<S30>/Subsystem' */

        /* SystemInitialize for MATLAB Function: '<S31>/MATLAB Function' */
        Model_Target_MATLABFunction_e_Init(&Model_Target_DW.sf_MATLABFunction_n);

        /* SystemInitialize for MATLAB Function: '<S31>/MATLAB Function1' */
        Model_Target_MATLABFunction_e_Init(&Model_Target_DW.sf_MATLABFunction1);

        /* SystemInitialize for MATLAB Function: '<S31>/MATLAB Function2' */
        Model_Target_MATLABFunction_e_Init(&Model_Target_DW.sf_MATLABFunction2);

        /* SystemInitialize for MATLAB Function: '<S31>/MATLAB Function3' */
        Model_Target_MATLABFunction_e_Init(&Model_Target_DW.sf_MATLABFunction3);

        /* SystemInitialize for MATLAB Function: '<S31>/MATLAB Function4' */
        Model_Target_MATLABFunction_e_Init(&Model_Target_DW.sf_MATLABFunction4);

        /* SystemInitialize for MATLAB Function: '<S31>/MATLAB Function5' */
        Model_Target_MATLABFunction_e_Init(&Model_Target_DW.sf_MATLABFunction5);

        /* SystemInitialize for MATLAB Function: '<S31>/MATLAB Function6' */
        Model_Target_MATLABFunction_e_Init(&Model_Target_DW.sf_MATLABFunction6);

        /* SystemInitialize for MATLAB Function: '<S31>/MATLAB Function7' */
        Model_Target_MATLABFunction_e_Init(&Model_Target_DW.sf_MATLABFunction7);

        /* SystemInitialize for Atomic SubSystem: '<S4>/SrcDownAnn' */
        /* '<S165>:1:12' States = single(zeros(FilterLength + FrameSize*2 + 2, NumChannels)); */
        Model_Target_SrcDownAnn_Init();

        /* End of SystemInitialize for SubSystem: '<S4>/SrcDownAnn' */

        /* End of SystemInitialize for SubSystem: '<Root>/NEAR' */

        /* SystemInitialize for Atomic SubSystem: '<Root>/PostProcess' */

        /* SystemInitialize for Atomic SubSystem: '<S6>/PostProcess' */
        Model_Target_PostProcess_Init();

        /* End of SystemInitialize for SubSystem: '<S6>/PostProcess' */

        /* End of SystemInitialize for SubSystem: '<Root>/PostProcess' */

        /* SystemInitialize for Atomic SubSystem: '<S655>/AudioPilot35' */

        /* InitializeConditions for Buffer: '<S901>/Buffer' */
        /* Full-cycle Table lookup */
        /* This code only executes when block is re-enabled in an
           enabled subsystem when the enabled subsystem states on
           re-enabling are set to 'Reset' */
        /* Reset to time zero on re-enable */
        /* Full-cycle Table lookup */
        Model_Target_DW.Buffer_inBufPtrIdx_e = 256;
        Model_Target_DW.Buffer_outBufPtrIdx_d = 128;

        /* InitializeConditions for Buffer: '<S965>/BufferMic' */
        Model_Target_DW.BufferMic_inBufPtrIdx = 64;

        /* InitializeConditions for Buffer: '<S965>/BufferRef' */
        Model_Target_DW.BufferRef_inBufPtrIdx = 64;

        /* InitializeConditions for Buffer: '<S978>/Buffer' */
        Model_Target_DW.Buffer_inBufPtrIdx_g = 256;
        Model_Target_DW.Buffer_outBufPtrIdx_i = 128;

        /* InitializeConditions for Delay: '<S908>/Delay1' */
        for (i = 0; i < 65; i++)
        {
            Model_Target_DW.Delay1_DSTATE_n[i] = 1.0F;
        }

        /* End of InitializeConditions for Delay: '<S908>/Delay1' */

        /* InitializeConditions for Delay: '<S920>/Delay' */
        Model_Target_DW.Delay_DSTATE_n0 = 0.5F;

        /* SystemInitialize for MATLAB Function: '<S918>/ComputePmin' */
        /* Initialize phase index */
        /* Initialize input buffer values */
        /* Initialize phase index */
        /* Initialize input buffer values */
        /* Initialize phase index */
        /* Initialize input buffer values */
        /* '<S890>:1:9' init_noise_floor = false; */
        /* '<S888>:1:12' GXY=complex(single(zeros(L,M,M))); */
        /* '<S888>:1:15' frame_counter=int16(0); */
        /* '<S927>:1:19' ; */
        /* '<S927>:1:19' IRMinCount	= single(-1); */
        Model_Target_DW.IRMinCount = -1.0F;

        /* '<S927>:1:20' ; */
        /* '<S927>:1:20' IRSubMin	= single(ones(numSubWin, numFreqBins))*1e-8; */
        for (i = 0; i < 195; i++)
        {
            Model_Target_DW.IRSubMin[i] = 1.0E-8F;
        }

        /* '<S927>:1:21' ; */
        /* '<S927>:1:21' IRPowMS		= single(ones(1, numFreqBins))*1e-8; */
        for (i = 0; i < 65; i++)
        {
            Model_Target_DW.IRPowMS[i] = 1.0E-8F;
        }

        /* End of SystemInitialize for MATLAB Function: '<S918>/ComputePmin' */

        /* SystemInitialize for MATLAB Function: '<S1079>/InnerLink' */
        /* '<S936>:1:5' ; */
        /* '<S936>:1:5' PrevChange = single(0); */
        /* '<S936>:1:6' ; */
        /* '<S936>:1:6' PrevDelta = single(0); */
        /* '<S959>:1:17' delayIndex = int32(0); */
        /* '<S979>:1:12' counter = 0; */
        /* '<S979>:1:13' Psd = complex(single(zeros(size(u)))); */
        /* '<S979>:1:14' prevout = complex(single(zeros(size(u)))); */
        /* '<S980>:1:12' counter = 0; */
        /* '<S980>:1:13' Psd = single(zeros(size(u))); */
        /* '<S980>:1:14' prevout = single(zeros(size(u))); */
        /* '<S981>:1:12' counter = 0; */
        /* '<S981>:1:13' Psd = single(zeros(size(u))); */
        /* '<S981>:1:14' prevout = single(zeros(size(u))); */
        /* '<S963>:1:12' MusicLPState = single(0); */
        /* '<S963>:1:15' NoiseLPState = single(0); */
        /* '<S963>:1:18' MicLPState = single(0); */
        /* '<S996>:1:20' ImpFiltState = single([0 0]); */
        /* '<S1020>:1:17' delayIndex = int32(0); */
        /* '<S1025>:1:5' ; */
        /* '<S1025>:1:5' PrevChange = single(0); */
        /* '<S1025>:1:6' ; */
        /* '<S1025>:1:6' PrevDelta = single(0); */
        /* '<S1045>:1:14' ; */
        /* '<S1045>:1:14' prev = single(0); */
        /* '<S1045>:1:15' ; */
        /* '<S1045>:1:15' counter = single(0); */
        /* '<S1045>:1:16' ; */
        /* '<S1045>:1:16' counter2 = single(0); */
        /* '<S1045>:1:17' ; */
        /* '<S1045>:1:17' LFUP = single(0); */
        /* '<S1052>:1:5' ; */
        /* '<S1052>:1:5' PrevChange = single(0); */
        /* '<S1052>:1:6' ; */
        /* '<S1052>:1:6' PrevDelta = single(0); */
        /* '<S1061>:1:11' ; */
        /* '<S1061>:1:11' PreRatioLinLP = single(0); */
        /* '<S1061>:1:12' ; */
        /* '<S1061>:1:12' ImpFiltState = single([0 0]); */
        /* '<S715>:1:17' delayIndex = int32(0); */
        /* '<S864>:1:11' dyneq_boost_gain_prev = single(0); */
        /* '<S864>:1:15' audiopilot_boost_gain_prev = single(0); */
        Model_Target_InnerLink_i_Init(&Model_Target_DW.sf_InnerLink_p);

        /* SystemInitialize for MATLAB Function: '<S1092>/InnerLink' */
        Model_Target_InnerLink_i_Init(&Model_Target_DW.sf_InnerLink_a);

        /* '<S1101>:1:17' delayIndex = int32(0); */

        /* End of SystemInitialize for SubSystem: '<S655>/AudioPilot35' */

        /* SystemInitialize for Atomic SubSystem: '<S1137>/Medusa5H1 Part 1' */
        Model_Target_Medusa5H1Part1_Init();

        /* End of SystemInitialize for SubSystem: '<S1137>/Medusa5H1 Part 1' */

        /* SystemInitialize for Atomic SubSystem: '<S1137>/Medusa5H1 Part 2' */
        Model_Target_Medusa5H1Part2_Init();

        /* End of SystemInitialize for SubSystem: '<S1137>/Medusa5H1 Part 2' */

        /* SystemInitialize for Atomic SubSystem: '<S1137>/Medusa5H1 Part 3' */
        Model_Target_Medusa5H1Part3_Init();

        /* End of SystemInitialize for SubSystem: '<S1137>/Medusa5H1 Part 3' */

        /* SystemInitialize for Atomic SubSystem: '<S1137>/Medusa5H1 Part 4' */
        Model_Target_Medusa5H1Part4_Init();

        /* End of SystemInitialize for SubSystem: '<S1137>/Medusa5H1 Part 4' */

        /* SystemInitialize for Atomic SubSystem: '<S1137>/Medusa5H1 Part 5' */
        Model_Target_Medusa5H1Part5_Init();

        /* End of SystemInitialize for SubSystem: '<S1137>/Medusa5H1 Part 5' */

        /* SystemInitialize for Atomic SubSystem: '<S1137>/Medusa5H1 Part 6' */
        Model_Target_Medusa5H1Part6_Init();

        /* End of SystemInitialize for SubSystem: '<S1137>/Medusa5H1 Part 6' */

        /* SystemInitialize for Atomic SubSystem: '<S663>/MedusaPostHoligram' */

        /* SystemInitialize for Atomic SubSystem: '<S1138>/MedusaPostHoligram' */
        Model_Target_MedusaPostHoligram_Init();

        /* End of SystemInitialize for SubSystem: '<S1138>/MedusaPostHoligram' */

        /* End of SystemInitialize for SubSystem: '<S663>/MedusaPostHoligram' */

        /* SystemInitialize for Atomic SubSystem: '<S663>/NearWiggleFilters' */

        /* user code (Initialize function Body) */

        /* InitTriggerControl '<S1813>/ITC1' */
        InitTrigger_Model_1112_65();

        /* '<S1808>:1:10' currentFadeInd = 0; */
        /* '<S1808>:1:11' currentSig = uint32(0); */
        /* '<S1812>:1:12' States = single(zeros(FilterLength + FrameSize*2 + 2, NumChannels)); */

        /* End of SystemInitialize for SubSystem: '<S663>/NearWiggleFilters' */

        /* SystemInitialize for Atomic SubSystem: '<S663>/PreAmpPart2' */
        Model_Target_PreAmpPart2_Init();

        /* End of SystemInitialize for SubSystem: '<S663>/PreAmpPart2' */

        /* SystemInitialize for Atomic SubSystem: '<S663>/VLS' */
        Model_Target_VLS_Init();

        /* End of SystemInitialize for SubSystem: '<S663>/VLS' */

        /* SystemInitialize for Atomic SubSystem: '<S7>/PreAmpPart1' */
        Model_Target_PreAmpPart1_Init();

        /* End of SystemInitialize for SubSystem: '<S7>/PreAmpPart1' */

        /* SystemInitialize for Atomic SubSystem: '<S7>/SrcDownEnt' */
        Model_Target_SrcDownEnt_Init();

        /* End of SystemInitialize for SubSystem: '<S7>/SrcDownEnt' */

        /* SystemInitialize for Atomic SubSystem: '<S7>/SrcDownMic' */
        Model_Target_SrcDownMic_Init();

        /* End of SystemInitialize for SubSystem: '<S7>/SrcDownMic' */

        /* SystemInitialize for Atomic SubSystem: '<S7>/SrcUp' */
        Model_Target_SrcUp_Init();

        /* End of SystemInitialize for SubSystem: '<S7>/SrcUp' */
    }
}

/* Model terminate function */
void Model_Target_terminate(void)
{
    /* Terminate for Atomic SubSystem: '<S7>/SrcUp' */
    Model_Target_SrcUp_Term();

    /* End of Terminate for SubSystem: '<S7>/SrcUp' */

    /* Terminate for Atomic SubSystem: '<Root>/NEAR' */
    /* Terminate for Atomic SubSystem: '<S4>/SrcDownAnn' */
    Model_Target_SrcDownAnn_Term();

    /* End of Terminate for SubSystem: '<S4>/SrcDownAnn' */
    /* End of Terminate for SubSystem: '<Root>/NEAR' */

    /* Terminate for Atomic SubSystem: '<S7>/SrcDownEnt' */
    Model_Target_SrcDownEnt_Term();

    /* End of Terminate for SubSystem: '<S7>/SrcDownEnt' */

    /* Terminate for Atomic SubSystem: '<S7>/SrcDownMic' */
    Model_Target_SrcDownMic_Term();

    /* End of Terminate for SubSystem: '<S7>/SrcDownMic' */
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
