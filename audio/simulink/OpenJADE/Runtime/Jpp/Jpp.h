/*******************************************************************************
*  BOSE CORPORATION
*  COPYRIGHT (c) BOSE CORPORATION ALL RIGHTS RESERVED
*  This program may not be reproduced, in whole or in part in any
*  form or any means whatsoever without the written permission of:
*     BOSE CORPORATION
*     The Mountain
*     Framingham, MA 01701-9168
*******************************************************************************/
/****************************************************
 * @file Jpp.h
 * 
 * @ingroup Jpp
 *
 * @brief Implementation of the Class Jpp       
 *
 * @author: cb1037694                     
 ****************************************************/

#if !defined(BC_Jpp__INCLUDED_)
#define BC_Jpp__INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <string.h>
#define JPP_MAX_NUM_PING_PONG 10
#define MY_CORE_NUMBER 0
#include "Jpp_Buffer_Type.h"

#include "Jpp_Control.h"
#include "Jpp_Specification.h"
#include "Jpp_Off_Chip_Spec.h"
#include "Jpp_Transfer_Spec.h"


/**
 * @ingroup Jpp
 *
 * @brief This structure holds information for each ping pong buffer.
 * All buffers systemwide (all cores) are represented to allow for
 * quick array-based access by buffer number.
 * 
 * @author cb1037694
 * 
 * @version 1.0
 */
typedef struct Jpp
{
	/**
	 * @ingroup Jpp
	 *
	 * @brief Overall number of ping pong buffers
	 */
	uint32_t num_buffers;

	/**
	 * @ingroup Jpp
	 *
	 * @brief Table to hold dynamic ping pong control data and constant buffer pointers
	 */
	Jpp_Control *control[JPP_MAX_NUM_PING_PONG];

	/**
	 * @ingroup Jpp
	 *
	 * @brief Specification table for buffer sizes, call rates, model access pointer, and transfer address
	 */
	Jpp_Specification *specification[JPP_MAX_NUM_PING_PONG];

	/**
	 * @ingroup Jpp
	 *
	 * @brief Number of transfers originating on this core and received by another core on this same chip
	 */
	uint32_t num_local_src;

	/**
	 * @ingroup Jpp
	 *
	 * @brief Number of transfers received by this core and originating from another core on this same chip
	 */
	uint32_t num_local_dst;

	/**
	 * @ingroup Jpp
	 *
	 * @brief Number of transfers originating on this chip (on any core) and
	 * received by any core on a different chip
	 */
	uint32_t num_cross_src;

	/**
	 * @ingroup Jpp
	 *
	 * @brief Number of  transfers received by this chip (on any core) and
	 * originating from any core on a different chip
	 */
	uint32_t num_cross_dst;

	/**
	 * @ingroup Jpp
	 *
	 * @brief Transfer List for Chip-Local Received Buffers
	 */
	uint32_t local_dst[JPP_MAX_NUM_PING_PONG];

	/**
	 * @ingroup Jpp
	 *
	 * @brief Transfer List for Chip-Local Sourced Buffers
	 */
	uint32_t local_src[JPP_MAX_NUM_PING_PONG];

	/**
	 * @ingroup Jpp
	 *
	 * @brief Transfer List for Cross-Chip Received Buffers
	 */
	Jpp_Off_Chip_Spec cross_dst[JPP_MAX_NUM_PING_PONG];

	/**
	 * @ingroup Jpp
	 *
	 * @brief Transfer List for Cross-Chip Sourced Buffers
	 */
	Jpp_Off_Chip_Spec cross_src[JPP_MAX_NUM_PING_PONG];

	/**
	 * @ingroup Jpp
	 *
	 * @brief There is a cross chip master, which means that this core is expected to
	 * manage cross-chip transfers among SOCs
	 * The cross chip master core continuously receives the ping-pong state of the lazy sister core (on
	 * this same chip).
	 * The sister_control ping-pong buffer holds a copy of the lazy sister's control table.
	 */
	Jpp_Control sister_control[2][JPP_MAX_NUM_PING_PONG];

	/**
	 * @ingroup Jpp
	 *
	 * @brief The sister_active pointer is used to access the correct sister_control ping-pong buffer
	 */
	Jpp_Control* sister_active;
} Jpp;

/**
 * @ingroup Jpp
 *
 * @brief This API adds a new transfer buffer to the Jpp structure
 * 
 * @param this
 * 
 * @param buffer_type This enumeration type tells if the buffer is source or destination, local or
 * cross-core
 * 
 * @param control Pointer to the buffer control structure
 * 
 * @param specification Pointer to the buffer transfer specification
 * 
 * @param core_number Number of the core that owns the buffer
 */
uint32_t Jpp_add_buffer(Jpp* this, Jpp_Buffer_Type buffer_type, Jpp_Control* control, Jpp_Specification* specification, uint32_t core_number);

/**
 * @ingroup Jpp
 *
 * @brief This API adds to the Jpp structure all the buffers generated by a multicore Talaria deployment
 * 
 * @param this
 */
void Jpp_add_talaria_buffers(Jpp* this);

/**
 * @ingroup Jpp
 *
 * @brief Initialize active ping pong model access pointers
 * 
 * @param this
 */
void Jpp_initialize(Jpp* this);

/**
 * @ingroup Jpp
 *
 * @brief This API sets up the model_ptr and transfer_address for this frame.
 * After capturing these values, the counters are stepped forward to
 * prepare for the next frame and allow for "early access" to next frame's
 * pointers when needed (e.g. for for prelaunch of local-chip-RX)
 * 
 * @param this
 */
void Jpp_step(Jpp* this);

/**
 * @ingroup Jpp
 *
 * @brief Returns the overall number of ping pong buffers
 * 
 * @param this
 */
uint32_t Jpp_get_num_buffers(Jpp* this);

/**
 * @ingroup Jpp
 *
 * @brief Returns number of transfers originating on this core and received by another core on this same chip
 * 
 * @param this
 */
uint32_t Jpp_get_num_local_src(Jpp* this);

/**
 * @ingroup Jpp
 *
 * @brief Returns number of transfers received by this core and originating from another core on this same
 * chip
 * 
 * @param this
 */
uint32_t Jpp_get_num_local_dst(Jpp* this);

/**
 * @ingroup Jpp
 *
 * @brief Returns number of transfers originating on this chip (on any core) and
 * received by any core on a different chip
 * 
 * @param this
 */
uint32_t Jpp_get_num_cross_src(Jpp* this);

/**
 * @ingroup Jpp
 *
 * @brief returns number of  transfers received by this chip (on any core) and
 * originating from any core on a different chip
 * 
 * @param this
 */
uint32_t Jpp_get_num_cross_dst(Jpp* this);

/**
 * @ingroup Jpp
 *
 * @brief This API retrieves buffer information for transfers
 * originating on this core and received by another core on this same chip
 * return address and size of the specified buffer
 * 
 * @param this
 * 
 * @param index
 */
Jpp_Transfer_Spec Jpp_get_local_src(Jpp* this, uint32_t index);

/**
 * @ingroup Jpp
 *
 * @brief This API retrieves NEXT-FRAME buffer information for transfers
 * received by this core and originating from another core on this same chip.
 * Note that the swap_count and transfer_index have already been positioned
 * for the next frame, so this method performs an early harvest of what happens
 * initially in the <a href="$feature://{4068F630-5B56-4d95-9944-B65CDFBB91BD}"><font
 * color="#0000ff"><u>step(Jpp*)</u></font></a>  API
 * 
 * @param this
 * 
 * @param index he index of the buffer between 0 and get_num_local_dst()-1
 */
Jpp_Transfer_Spec Jpp_get_local_dst_next(Jpp* this, uint32_t index);

/**
 * @ingroup Jpp
 *
 * @brief This API retrieves buffer information for transfers
 * ginating on this chip (on any core) and received by any core on a different chip
 * 
 * @param this
 * 
 * @param index The index of the buffer between 0 and get_num_cross_src()- 1
 */
Jpp_Transfer_Spec Jpp_get_cross_src(Jpp* this, uint32_t index);

/**
 * @ingroup Jpp
 *
 * @brief This API retrieves buffer information for transfers
 * received by this chip (on any core) and originating from any core on a different chip
 * 
 * @param this
 * 
 * @param index The index of the buffer between 0 and get_num_cross_dst()- 1
 */
Jpp_Transfer_Spec Jpp_get_cross_dst(Jpp* this, uint32_t index);

/**
 * @ingroup Jpp
 *
 * @brief This API returns the pointer that the model should operate on
 * 
 * @param this
 * 
 * @param index The index of the buffer between 0 and get_num_buffers()- 1
 */
void* Jpp_get_model_ptr(Jpp* this, uint32_t index); 



#ifdef __cplusplus
}
#endif


#endif /*!defined(BC_Jpp__INCLUDED_)*/
