/*******************************************************************************
*  BOSE CORPORATION
*  COPYRIGHT (c) BOSE CORPORATION ALL RIGHTS RESERVED
*  This program may not be reproduced, in whole or in part in any
*  form or any means whatsoever without the written permission of:
*     BOSE CORPORATION
*     The Mountain
*     Framingham, MA 01701-9168
*******************************************************************************/
/****************************************************
 * @file Jpp.h
 * 
 * @brief Implementation of the Class Jpp       
 *
 * @author: cb1037694                     
 ****************************************************/

#include "Jpp.h"

/**
 * @ingroup Jpp
 *
 * @brief @param this
 * 
 * @param control
 * 
 * @param specification
 */
void* Jpp_get_transfer_ptr(Jpp* this, Jpp_Control* control, Jpp_Specification* specification);

/**
 * @ingroup Jpp
 *
 * @brief This API does the work for both get_cross_src() and get_cross_dst() based on a provided
 * off_chip_spec
 * 
 * @param this
 * 
 * @param off_chip_spec
 */
Jpp_Transfer_Spec Jpp_get_cross_transfer_spec(Jpp* this, Jpp_Off_Chip_Spec* off_chip_spec);

/**
 * This API adds a new transfer buffer to the Jpp structure
 */
uint32_t Jpp_add_buffer(Jpp* this, Jpp_Buffer_Type buffer_type, Jpp_Control* control, Jpp_Specification* specification, uint32_t core_number)
{
	if ( this->num_buffers >= (JPP_MAX_NUM_PING_PONG - 1)){
	    return 1; // Error: no buffers left
	}
	
	switch ( buffer_type ) {
		case JPP_BUFFER_TYPE_LOCAL_SRC: 
	    this->num_local_src++;
	    this->local_src[this->num_local_src] = this->num_buffers+1;
	    break;
		case JPP_BUFFER_TYPE_LOCAL_DST: 
	    this->num_local_dst++;
	    this->local_dst[this->num_local_dst] = this->num_buffers+1;
	    break;
		case JPP_BUFFER_TYPE_CROSS_SRC: 
	    this->num_cross_src++;
	    this->cross_src[this->num_cross_src].buffer_number = this->num_buffers+1;
	    this->cross_src[this->num_cross_src].core_number = core_number;
	    break;
		case JPP_BUFFER_TYPE_CROSS_DST: 
	    this->num_cross_dst++;
	    this->cross_dst[this->num_cross_dst].buffer_number = this->num_buffers+1;
	    this->cross_dst[this->num_cross_dst].core_number = core_number;
	    break;
	default:
	    return 2; // Error: invalid argument
	}
	this->control[this->num_buffers+1] = control;
	this->specification[this->num_buffers+1] = specification;
	this->num_buffers++;
	return 0;
}

/**
 * This API adds to the Jpp structure all the buffers generated by a multicore Talaria deployment
 */
void Jpp_add_talaria_buffers(Jpp* this)
{
	
}

/**
 * Initialize active ping pong model access pointers
 */
void Jpp_initialize(Jpp* this)
{
	uint32_t i;
	for ( i = 0; i < this->num_buffers; i++ ) {
	    if ( this->control[i] && this->specification[i] ) {
	        // Reset all swap counts to perch them one step away from arriving at a swap
	        this->control[i]->swap_count = this->specification[i]->swap_factor - 1;
	            
	        // Reset all ping pong transfer index values 0, ready to swap to 1 after one step
	        this->control[i]->transfer_index = 0;
	    }
	}
	
	// Clear local buffer to receive sister core buffer control information
	memset(&this->sister_control[0][0], 0, sizeof(this->sister_control));
	
}

/**
 * This API sets up the model_ptr and transfer_address for this frame.
 * After capturing these values, the counters are stepped forward to
 * prepare for the next frame and allow for "early access" to next frame's
 * pointers when needed (e.g. for for prelaunch of local-chip-RX)
 */
void Jpp_step(Jpp* this)
{
	int i;
	for (i = 0; i < this->num_buffers; i++)// swap all normal buffers
	{
	  // Harvest buffer addresses and pointers for use in the current frame.
	  // The ping pong counters are already set up for us
	  Jpp_Control* control = this->control[i];
	  Jpp_Specification* specification = this->specification[i];
		
	  // transfer address: either a source or destination for a data transfer among cores
	  specification->transfer_address = Jpp_get_transfer_ptr(this, control, specification);
		
	  // model pointer: update the pointer that the generated model source code uses during processing
	  if (specification->model_ptr ) {
	    *specification->model_ptr = control->buffers[control->transfer_index^1];
	  }
		
	  // Now update the counters for use in the next frame
	  control->swap_count++;
	  if (control->swap_count >= specification->swap_factor) {
	    // swap the buffers to their other storage locations
	    control->transfer_index = control->transfer_index ^ 1;
		
	    // reset the swap count
	    control->swap_count = 0;
	  }
	}
}

/**
 * Returns the overall number of ping pong buffers
 */
uint32_t Jpp_get_num_buffers(Jpp* this)
{
	return  this->num_buffers;
}

/**
 * Returns number of transfers originating on this core and received by another core on this same chip
 */
uint32_t Jpp_get_num_local_src(Jpp* this)
{
	return  this->num_local_src;
}

/**
 * Returns number of transfers received by this core and originating from another core on this same
 * chip
 */
uint32_t Jpp_get_num_local_dst(Jpp* this)
{
	return  this->num_local_dst;
}

/**
 * Returns number of transfers originating on this chip (on any core) and
 * received by any core on a different chip
 */
uint32_t Jpp_get_num_cross_src(Jpp* this)
{
	return  this->num_cross_src;
}

/**
 * returns number of  transfers received by this chip (on any core) and
 * originating from any core on a different chip
 */
uint32_t Jpp_get_num_cross_dst(Jpp* this)
{
	return  this->num_cross_dst;
}

/**
 * This API retrieves buffer information for transfers
 * originating on this core and received by another core on this same chip
 * return address and size of the specified buffer
 */
Jpp_Transfer_Spec Jpp_get_local_src(Jpp* this, uint32_t index)
{
	Jpp_Transfer_Spec retVal = { 0 };
		
	if (index < this->num_local_src) {
	  uint8_t bufferNumber = this->local_src[index];
	  Jpp_Specification* specification = this->specification[bufferNumber];
	  retVal.byte_size = specification->transfer_size;
	  retVal.core_number = MY_CORE_NUMBER;
		
	  // Return the transfer buffer already calculated for this frame (in StepPingPongs)
	  retVal.buffer = specification->transfer_address;
	}
		
	return retVal;                       // shallow copy of the transfer spec struct
}

/**
 * This API retrieves NEXT-FRAME buffer information for transfers
 * received by this core and originating from another core on this same chip.
 * Note that the swap_count and transfer_index have already been positioned
 * for the next frame, so this method performs an early harvest of what happens
 * initially in the <a href="$feature://{4068F630-5B56-4d95-9944-B65CDFBB91BD}"><font
 * color="#0000ff"><u>step(Jpp*)</u></font></a>  API
 */
Jpp_Transfer_Spec Jpp_get_local_dst_next(Jpp* this, uint32_t index)
{
	Jpp_Transfer_Spec retVal = { 0 };
		
	if (index < this->num_local_dst) {
	  uint8_t bufferNumber = this->local_dst[index];
	  Jpp_Specification* specification = this->specification[bufferNumber];
	  retVal.byte_size = specification->transfer_size;
	  retVal.core_number = MY_CORE_NUMBER;
		
	  // Jpp_step() has calculated the transfer buffer for THIS frame, but we want
	  // to know about next frame. Happily, the ping pong step has also calculated the index
	  // and counter to calculate the pointer here ourselves:
	  Jpp_Control* control = this->control[bufferNumber];
	  retVal.buffer = Jpp_get_transfer_ptr(this, control,specification);
	}
		
	return retVal; // shallow copy of the transfer spec struct
}

/**
 * This API retrieves buffer information for transfers
 * ginating on this chip (on any core) and received by any core on a different chip
 */
Jpp_Transfer_Spec Jpp_get_cross_src(Jpp* this, uint32_t index)
{
	Jpp_Transfer_Spec retVal = { 0 };
		
	if (index < this->num_cross_src) {
	  Jpp_Off_Chip_Spec* off_chip_spec = &this->cross_src[index];
	  return Jpp_get_cross_transfer_spec(this, off_chip_spec);
	}
		
	return retVal;
}

/**
 * This API retrieves buffer information for transfers
 * received by this chip (on any core) and originating from any core on a different chip
 */
Jpp_Transfer_Spec Jpp_get_cross_dst(Jpp* this, uint32_t index)
{
	Jpp_Transfer_Spec retVal = { 0 };
		
	if (index < this->num_cross_dst) {
	  Jpp_Off_Chip_Spec* off_chip_spec = &this->cross_dst[index];
	  return Jpp_get_cross_transfer_spec(this, off_chip_spec);
	}
		
	return retVal;  // shallow copy of the transfer spec struct
}

/**
 * This API returns the pointer that the model should operate on
 */
void* Jpp_get_model_ptr(Jpp* this, uint32_t index)
{
	Jpp_Specification* specification = this->specification[index];
	if (specification) {
	    return specification->model_ptr;
	}
	return  NULL;
}

void* Jpp_get_transfer_ptr(Jpp* this, Jpp_Control* control, Jpp_Specification* specification)
{
	void* theTransferBuffer;
	uint8_t* transBase = ((uint8_t*)control->buffers[control->transfer_index]);
	if (transBase) {
	  theTransferBuffer = transBase + (control->swap_count *
	    specification->transfer_size);
	} else {
	  theTransferBuffer = 0;
	}
		
	return theTransferBuffer;
}

/**
 * This API does the work for both get_cross_src() and get_cross_dst() based on a provided
 * off_chip_spec
 */
Jpp_Transfer_Spec Jpp_get_cross_transfer_spec(Jpp* this, Jpp_Off_Chip_Spec* off_chip_spec)
{
	Jpp_Transfer_Spec retVal = { 0 };
		
	uint8_t bufferNumber = off_chip_spec->buffer_number;
	Jpp_Specification* specification = this->specification[bufferNumber];
	retVal.byte_size = specification->transfer_size;
	retVal.core_number = off_chip_spec->core_number;
		
	// Does this transfer involve our local core?
	if (off_chip_spec->core_number == MY_CORE_NUMBER) {
	  // yes: the transfer address has already been prepared!
	  retVal.buffer = specification->transfer_address;
	} else if (this->sister_active) {
	  // no: try calculating from our SISTERCORE control data
	  Jpp_Control* control = &this->sister_active[bufferNumber];
	  retVal.buffer = Jpp_get_transfer_ptr(this, control,specification);
	}
		
	return retVal;
} 

