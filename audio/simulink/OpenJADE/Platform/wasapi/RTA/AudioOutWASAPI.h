#if defined(WASAPI)

#pragma once
#include <windows.h>
#include "AudioClient.h" //WASAPI
#include "Mmdeviceapi.h"
#include "Avrt.h"

//size of each buffer in double buffer;
//should be NUM_CHANNELS * BLOCK_SZIE
#define WASAPI_BUFFER_LENGTH (1024)

//double buffer for input stream
typedef struct {
	float bufferA[WASAPI_BUFFER_LENGTH];
	float bufferB[WASAPI_BUFFER_LENGTH];

	float *readPtr; //pointer to next location to be read
	UINT32 indR; //index of next location to be read
	float *writePtr; //pointer to next location to be written to
	UINT32 indW; //index of next location to be written to

	//flags to keep track of which buffer is being read/written to
	//A = 0, B = 1
	UINT32 buffW;
	UINT32 buffR;

} proxyBuffer;

class AudioOutWASAPI
{
public:
	AudioOutWASAPI();
	~AudioOutWASAPI();

	void Initialize(void(*aStepfunction)(), float* inputBuff, float *outputBuff,
		DWORD numChannels = 2, DWORD deviceFrameSamples = 512, DWORD sampleRate = 44100,
		DWORD modelFrameSamples = 32);
	bool Start();
	void Stop();

private:
	bool BeginPlayback();
	bool StopPlayback();
	void outputBufferLoop();
	void inputBufferLoop();
	static void outputThreadFunc(AudioOutWASAPI* theGeneratorIn); //process input and buffer output
	static void inputThreadFunc(AudioOutWASAPI* theGeneratorIn); //buffer input
	void processWriteOverflow(int nextBuffWrite, float *nextWritePtr, UINT32 numSent); //manage write of double buffer
	void processReadSwitch(int nextBuffRead, float *nextReadPtr, float *tempPtr); //manage read of double buffer

    IMMDevice* enumerateAndChooseDevice(EDataFlow captureOrRender);

private:
	static const int NUM_BUFFER_BLOCKS = 3;

	void(*stepfcn)();

	DWORD m_samplesPerBlock;
	DWORD m_bytesPerBlock;
	DWORD frameSize; //WASAPI frame size
	DWORD inputFrameSize; //simulink frame size (must be <= frameSize)
	WAVEFORMATEX m_waveFormat;

	float* SysInPtr; //pointer to buffer generated by simulink
	float* SysOutPtr; // pointer to output buffer generated by simulink

	proxyBuffer proxy_buf; //proxy double buffer between input and output endpoint buffers

	bool m_running; //flag for signaling stop of input stream
	UINT32 outputBufferSize; //size of output buffer, dictated by WASAPI
	REFERENCE_TIME frameLen; //frame length in WASAPI time units

	IAudioClient *m_outputClient; //WASAPI audio output manager
	IAudioClient *m_inputClient; //WASAPI audio input manager
	IAudioRenderClient *m_WASRender; //WASAPI output buffer
	IAudioCaptureClient *m_WASCapture; //WASAPI input buffer
    IMMDevice* m_inputDevice;
    IMMDevice* m_outputDevice;
    IMMDeviceEnumerator *m_pEnumerator;

	HWND m_hWnd; // Window handle
	HANDLE m_hNotifyEvent; //for buffer callback
	HANDLE m_hThread; //ouput buffer thread
	HANDLE priorityTask; //for elevating priority of output thread
	HANDLE m_iThread; //input buffer thread

	HANDLE fillProxy[4]; //for signaling switches in double buffer
};

#endif

