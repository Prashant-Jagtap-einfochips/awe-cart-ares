
// Bose Advanced Audio Sample (BAAS).
// This file will be autogenerated and moved to 
// artifacts folder - OpenJADE\out. 
// This file should only have the functionality that
// is to be delivered to the client.

#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <stdarg.h>
#include <malloc.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>

//#define VERBOSE_LOGGING

#define LOG_ID_STRING "lib_bose: "

#ifdef VERBOSE_LOGGING
const char *build_str = LOG_ID_STRING "Built: "  " " __DATE__ " " __TIME__;
#else
const char *build_str = LOG_ID_STRING;
#endif

#ifdef PLATFORM_MULTIRATE_AUDIOTHREADS
// Make it a runtime option based on some cfg? Undefine for Gain.
#define MULTIRATE_AUDIOTHREADS
#endif

#ifdef MULTIRATE_AUDIOTHREADS
#include <pthread.h>
#include <sched.h>
#include <sys/neutrino.h>
#include <semaphore.h>
#endif

#include "ipc.h"
#include "BAF_Message_Id.h"
#include "CART_Message.h"
#include "BAF.h"
#include "Error_Id.h"
#include "baas.h"

#if !defined(PLATFORM_BASETHREADLEVEL)
#define PLATFORM_BASETHREADLEVEL 0
#endif

#define CMD_THREAD_PRIORITY 150
#define CMD_THREAD_STACK_SIZE 4096

#ifdef MULTIRATE_AUDIOTHREADS
// 255 is the highest priority in ptheads.
#define BASE_THREAD_PRIORITY 200

#define BACKGROUND_THREAD_PRIORITY 100

#define THREAD_STACK_SIZE 4096 
#endif

// Define the maximum number of threads. Autogenerating this will be read from 
// model. 
#define PLATFORM_NUM_AUDIOTHREADS      (12)
#define PLATFORM_NUM_BACKGROUND_TASKS  (10)

/* ---- Typedefs -----------------------------------------------------------------------*/

// Module configuration structure, e.g. read from filesystem
typedef struct
{
    chconfig_t const * ChanConfig;               /**< Input/Output Frame length in samples */
    unsigned int uSamplesPerFrame;               /**< Input/Output Frame length in samples */
    unsigned int uInternalBufLen;                /**< Internal per channel buffer length in samples */
    uint32_t     uSampleRate;                    /**< Sample rate (Hz) */
} module_config_t;


// #define MODEL_CHAN_COUNT ()
// the platform provides 4 chan of input and 8 chan of output in ezkit. 
// if we are asked to read/write less than platform number. 
// if asked for more, we onyl supply max upto the waht the platform provides.



/* ---- Channel Map Definitions --------------------------------------------------------*/

// In this made up example, we support these channel configurations:
//  2in, 2out (2 variations)
//  2in, 4out
static snd_pcm_chmap_t const chmap_stereo    = { .channels = 2, .pos = { SND_CHMAP_FL, SND_CHMAP_FR } };
static snd_pcm_chmap_t const chmap_mono_lfe  = { .channels = 2, .pos = { SND_CHMAP_MONO, SND_CHMAP_LFE } };
static snd_pcm_chmap_t const chmap_4ch       = { .channels = 4, .pos = { SND_CHMAP_FL, SND_CHMAP_FR, SND_CHMAP_RL, SND_CHMAP_RR } };

static chconfig_t const chconfig_2in2out_a = { .src_chmap = &chmap_stereo, .dst_chmap = &chmap_stereo };
static chconfig_t const chconfig_2in2out_b = { .src_chmap = &chmap_mono_lfe, .dst_chmap = &chmap_mono_lfe };
static chconfig_t const chconfig_2in4out   = { .src_chmap = &chmap_stereo, .dst_chmap = &chmap_4ch };

static chconfig_t const * const chconfig_list[] = { &chconfig_2in2out_a, NULL };


static const module_config_t default_config = 
{
    .ChanConfig = &chconfig_2in2out_a, // Change the GetSupportedChannelConfigs accordingly.
    .uSamplesPerFrame = 32,
    .uInternalBufLen = 0, 
    .uSampleRate = 48000,
};

// Structure of allocation functions to use
// - defaults to the C standard library functions
static module_allocator_t g_allocator =
{
    .malloc        = malloc,
    .realloc       = realloc,
    .calloc        = calloc,
    .aligned_alloc = NULL, // aligned_alloc is supposed to be in malloc.h but does not compile.
    .free          = free,
};

#define HEAP_SIZE 0x4000

typedef void (*Platform_Func_audio_thread_handler)(void *arg, uint32_t thread_level);

static int16_t PipeData( void * hHandle, size_t ulSize, void * pData );

// IPC message header size.
const size_t headerSize = CART_MESSAGE_HEADER_BYTES;

typedef struct Platform_Thread
{
    // Could pass module_t* or module_baas_t* for example.
    void* hModule; 

    // Thread level and priority value will be different for pthreads.
    uint32_t thread_level; 
    
    sem_t semaphore;

    unsigned char exec;

    sem_t wait;

    unsigned char stop;

    pthread_t threadHandle;

}  Platform_Thread_t;

// Module to wrap BAAS.
typedef struct
{
    // Memory for Bose algorithm internal usage. 
    uint32_t heap_buffer[HEAP_SIZE/sizeof(uint32_t)];
  
    uint32_t baf_enable;

    BAF* baf;

    Platform_Func_audio_thread_handler audio_thread_handler;

    Platform_Thread_t thread[PLATFORM_NUM_AUDIOTHREADS];

    Platform_Thread_t cmdThread;

    int cmdFiledesc;
	
    shmem_t* commandIpcPtr;

    CART_Phy_Message* cmdMsg;

    // Command processing critical section is protected from concurrent access.
    sem_t pipeDataLock;

#ifdef VERBOSE_LOGGING
    uint32_t cnt;
#endif

} module_baas_t;

// Module instance struct
typedef struct
{
    bool bCreated;

    bool bInited;

    float *pInputBuffer;

    float *pOutputBuffer;

    module_config_t Config;

    module_baas_t baas;
} module_t;


/* ---- Function Declarations ----------------------------------------------------------*/

static int16_t Deinitialize( void * hHandle );
static int16_t Reset( void * hHandle );

int BAF_printf(char* fmt, ...)
{
    va_list args;
    int val;

    va_start(args, fmt);
    val = printf(fmt, args);
    va_end(args);

    return val;
}

void notification_handler(BAF* baf, BAF_Message *message)
{
   // uint32_t * data = message->data;

   // BAF_printf("\n  !!: Got msg reply notification %x %x %x %x. \n", message->id, message->size, data[0], data[1]);
}


void BAF_Callback_post(uint32_t thread_level, void* arg) 
{
#ifdef MULTIRATE_AUDIOTHREADS    
    // Could have just passed module_baas_t or even just Platform_Thread_t.
    module_t* me = (module_t*)arg;

    Platform_Thread_t *pThread = &(me->baas.thread[thread_level]);

    pThread->exec = 1;

    sem_post(&(pThread->semaphore));
#endif  // MULTIRATE_AUDIOTHREADS
}


uint32_t BAF_Callback_clock(void) 
{
    return 0;
}

void  BAF_Callback_sys_process_ctx(uint32_t proc_Id, uint32_t frame_size,
      uint32_t num_chan_in, uint32_t num_chan_out, void *src, void *dst, void* arg) 
{
    module_t* me = (module_t*)arg;

    uint32_t copy_size = 0;

    switch (proc_Id)
    {
		case 0:
            // Memcpy not just samples for channel, but all channels at the same time.
            copy_size = me->Config.ChanConfig->src_chmap->channels * me->Config.uSamplesPerFrame * sizeof(float);

            // Expect caller to provide scaled or normalized data. Pass it to the processing model.
            memcpy(dst, (void *)me->pInputBuffer, copy_size);

            break;

        case 1:     
            // Memcpy not just samples for channel, but all channels at the same time.
            copy_size = me->Config.ChanConfig->dst_chmap->channels * me->Config.uSamplesPerFrame * sizeof(float);

            // Copy the data from the algorithm buffer to the context buffer pointer, which is the caller/io-audio buffer.
            memcpy((void *)me->pOutputBuffer, src, copy_size);

            break;
        
        default:
            printf("BAF_Callback_sys_process_ctx unexpected ID  %u", proc_Id);
            break;
    }
}

/* ---- Function Definitions -----------------------------------------------------------*/

/** Retrieve version information.
 *
 *  This function is used to retrieve library version information.  An instance of the
 *  library does not have to exist, i.e. you can call qwaSfoGetVersion() before qwaSfoCreate().
 *  If any parameter is NULL, the corresponding data is not retrieved.
 *
 *  @ingroup SFOAPI
 *
 *  @param   pusVersionArray   Version array.
 *  @param   pszVersionString  Version string
 *                             (the same information as psVersionArray but in string format).
 *  @param   pszVersionComment Optional version comment string.
 */
/*======================================================================================*/
static void GetVersion( const char ** pszVersionString )
{
   if (NULL != pszVersionString)
   {
      *pszVersionString = "X Module 0.0.20000.0";
   }
}

/** Specify the allocator that the module should use
 *
 *  This should be called prior to Create()
 *
 *  @ingroup SFOAPI
 *
 *  @param   allocator   Structure allocator functions to use
 */
/*======================================================================================*/
static int16_t SetAllocator( module_allocator_t* allocator )
{
    if ( (allocator == NULL) ||
         (allocator->malloc == NULL) ||
         (allocator->realloc == NULL) ||
         (allocator->calloc == NULL) ||
         (allocator->aligned_alloc == NULL) ||
         (allocator->free == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    g_allocator.malloc        = allocator->malloc;
    g_allocator.realloc       = allocator->realloc;
    g_allocator.calloc        = allocator->calloc;
    g_allocator.aligned_alloc = allocator->aligned_alloc;
    g_allocator.free          = allocator->free;

    return ERR_OK;
}


/** Library constructor.  Creates instance of the library.  First stage of the two-stage initialization of the library
 *
 *  @param   phHandle      Pointer to handle which will be created by this function.
 *                         Must not be NULL
 *
 *  @return  Result status
 *  @retval  #ERR_OK                      No error.
 *  ...
 */
/*======================================================================================*/
static int16_t Create( void ** phHandle )
{ 
    BAF_Resource *resource;

    // We will be storing BAF/CART context in here. Make sure it is not NULL.
    if (phHandle == NULL)
    {
        return ERR_NULL_POINTER;
    }

    *phHandle = g_allocator.malloc(sizeof(module_t));
    if (*phHandle == NULL)
    {
        printf("Error: malloc failure\n");
        return ERR_ALLOC;
    }

    // Initialize members
    module_t *pModule = (module_t*)(*phHandle);
    pModule->bCreated = true;
    pModule->bInited = false;

    pModule->baas.baf = BAF_create(NULL);

    resource = BAF_resource(pModule->baas.baf);

    if (resource->memory_size < HEAP_SIZE) 
    {
        resource->memory_pointer = pModule->baas.heap_buffer;

        // Remove all code generated for logging in runtime.
        resource->memory_log_pointer = NULL;

        resource->base_thread = PLATFORM_BASETHREADLEVEL;
    } 
    else 
    {
        printf("Error: BAF not enough memory req %d supplied %d\n", 
                resource->memory_size, HEAP_SIZE);

        return ERR_ALLOC;
    }

    printf("Shared library version %s, threads %u.\n",
           BAF_version(pModule->baas.baf),
           resource->num_threads);

    return ERR_OK;
}

/** Library destructor
 *
 *  This function destroys the instance of the library.
 *
 *  @ingroup SFOAPI
 *
 *  @param   phHandle      Pointer to the handle created in Create().
 *                         Calling this function with @a *phSfo set to NULL
 *                         is possible without causing an error.
 *
 *  @return  Result status
 *  @retval  #ERR_OK                         No error.
 *  ...
 */
/*======================================================================================*/
static int16_t Destroy( void ** phHandle )
{
    if ((phHandle != NULL) && (*phHandle != NULL))
    {
        module_t* pModule = (module_t*)(*phHandle);

        if( pModule->bCreated )
        {
            if( pModule->bInited ) 
            {
                Deinitialize( *phHandle );
            }

#ifdef MULTIRATE_AUDIOTHREADS
            BAF_Resource *resource = BAF_resource(pModule->baas.baf);

            const uint32_t threadCount = resource->num_threads;

            for (int i =0; i < threadCount; i++)
            {
                Platform_Thread_t *pThread = &(pModule->baas.thread[i]);

#if DETACH_IS_QUESTIONABLE

                uint32_t returnValue = 0;

                // Deal with threads first.
                if (EOK != pthread_detach(pThread->threadHandle))
                {
                    printf(" Failed to detach thread %u. \n ", i);
                }

                if (EOK != (returnValue = pthread_abort(pThread->threadHandle)))
                {
                    printf(" Failed to abort thread %u handle %d Errno %u Returned %u. \n ",
                           i, pThread->threadHandle, errno, returnValue);
                }
#endif

                if (EOK != sem_destroy(&(pThread->semaphore)))
                {
                    printf(" Failed to destroy semaphore for thread %u. \n ", i);
                }

                if (EOK != sem_destroy(&(pThread->wait)))
                {
                    printf(" Failed to destroy semaphore for thread %u. \n ", i);
                }  
            }
#endif  // MULTIRATE_AUDIOTHREADS

            pModule->bCreated = false;

            g_allocator.free( (void*)pModule );
        }

        pModule = NULL;
    }

    printf("Shared Ojbect destroyed(). \n");

    return ERR_OK;
}


void* cmdThreadFunction(void *thread_arg)
{
    Platform_Thread_t *pThread = (Platform_Thread_t *)thread_arg;

    module_t* hModule = (module_t*)(pThread->hModule);

#ifdef VERBOSE_LOGGING
    printf("%s cmdThreadFunction():  handle %u arg %p\n",
           LOG_ID_STRING, pThread->threadHandle, thread_arg);
#endif

    while (1)
    {
        while (sem_wait(&(hModule->baas.commandIpcPtr->initiateRequest)) && (errno == EINTR))
        {
        }

        if (pThread->stop == 1)
        {
            break;
        }
        else
        {
            PipeData((void *)hModule, 
                     (size_t)MAX_MSG_SIZE, 
                     (void *)(hModule->baas.cmdMsg));

            int value = 0;

            if (EOK != (value = sem_post(&(hModule->baas.commandIpcPtr->requestComplete))))
            {
                printf(" Request complete sem_post failed. Return value %x. %s.\n",
                        value, strerror(errno));
            }
        }
    }

#ifdef VERBOSE_LOGGING
    printf("%s cmdThreadFunction() exiting\n", LOG_ID_STRING);
#endif 
    
    pthread_exit(NULL);
}


#ifdef MULTIRATE_AUDIOTHREADS
void* thread_function(void *thread_arg)
{
    Platform_Thread_t *pThread = (Platform_Thread_t *)thread_arg;

    uint32_t level = pThread->thread_level; 
    
    module_t* hModule = (module_t*)(pThread->hModule);
    
    BAF* hBaf = hModule->baas.baf;

    while (1)
    {
        while (sem_wait(&(pThread->semaphore)) && (errno == EINTR))
        {
        }

        if (pThread->stop == 1)
        {
            break;
        }
        else
        {
            BAF_exec(hBaf, level, hModule);

            sem_post(&(pThread->wait));
        }
    }
    
#ifdef VERBOSE_LOGGING
    printf("Exiting thread level %u.", level);
#endif 

    pthread_exit(NULL);
}

static int16_t initialize_threads(module_t* hModule)
{
    int retVal = EOK;

    BAF_Resource *resource = BAF_resource(hModule->baas.baf);

    uint32_t threadCount = resource->num_threads;

    pthread_attr_t thread_attr;

	pthread_attr_init(&thread_attr);
    
    int newprio = BASE_THREAD_PRIORITY;

	sched_param_t param;

    size_t stackSize = 0;

	uint32_t BAFThreadLevel = 0;

	/* safe to get existing scheduling param */
	if (EOK != (retVal = pthread_attr_getschedparam (&thread_attr, &param)))
	{
		printf("Main: Thread: failed to get param \n."); 
        return ERR_NOT_INIT;
	}
	else if (EOK != (retVal = pthread_attr_setschedpolicy(&thread_attr, SCHED_RR)))
	{
		printf("Main: Thread: failed to set policy \n."); 
        return ERR_NOT_INIT;
	}
	else if (EOK != (retVal = pthread_attr_setstacksize(&thread_attr, THREAD_STACK_SIZE)))
	{
		printf("Main: Thread: failed to set stack size %d \n.", THREAD_STACK_SIZE); 
        return ERR_NOT_INIT;
	}

	// Create threads.
	for (int i =0; i < threadCount; i++)
	{        
        Platform_Thread_t *pThread = &(hModule->baas.thread[i]);

		pThread->thread_level = BAFThreadLevel;

	    pThread->exec = 0;

		pThread->stop = 0;

        pThread->hModule = hModule;

		// Base thread has highest priority:
        if (i < PLATFORM_BASETHREADLEVEL )
        {
            // Fixed priority of all tasks before base thread as they all are background thread?:
            param.sched_priority = BACKGROUND_THREAD_PRIORITY;
        }
        else if (i == PLATFORM_BASETHREADLEVEL)
        {
            param.sched_priority = BASE_THREAD_PRIORITY;
        }
        else
        {
            param.sched_priority = --newprio;
        }

		/* setting the new scheduling param */
		if (EOK != (retVal = pthread_attr_setschedparam (&thread_attr, &param)))
		{
			printf("Main: Thread: failed to set priority \n."); 
            return ERR_NOT_INIT;
		}
        else if (EOK != (retVal = sem_init(&(pThread->semaphore), 0, 0)))
        {
            printf("Main: Thread: failed to init semaphore \n.");
            return ERR_NOT_INIT;
        }
        else if (EOK != (retVal = sem_init(&(pThread->wait), 0, 0)))
        {
            printf("Main: Thread: failed to init semaphore \n.");
            return ERR_NOT_INIT;
        }
		else if (EOK != (retVal = pthread_create(&(pThread->threadHandle), &thread_attr,(void*) &thread_function, pThread)))
		{
			printf("Main: failed to pthread_create \n."); 
            return ERR_NOT_INIT;
		}
		else
		{
		    char name[80];

		    memset((void*) name, 0, 80);

		    snprintf( name, 80, "thread-%u.",i );

		    if (EOK != (retVal = pthread_setname_np(pThread->threadHandle, name)))
            {
		        printf("Main: failed to name pthread\n.");
                return ERR_NOT_INIT;
            }
		    else
		    {
                pthread_attr_getstacksize(&thread_attr, &stackSize);

#ifdef VERBOSE_LOGGING
                printf("Creating thread # %u with priority %u stack size %lu - %s has sem %p\n",
                       i,
                       param.sched_priority,
                       stackSize,
                       name,
                       &(pThread->semaphore));
#endif
                BAFThreadLevel++;
		    }
		}
	}

    return retVal;
}
#endif  //  MULTIRATE_AUDIOTHREADS


static int16_t initializeCommandThread(module_t* hModule)
{
    int retVal = EOK;

    pthread_attr_t thread_attr;

	pthread_attr_init(&thread_attr);
    
    int newprio = CMD_THREAD_PRIORITY;

	sched_param_t param;

    size_t stackSize = 0;

	/* safe to get existing scheduling param */
	if (EOK != (retVal = pthread_attr_getschedparam (&thread_attr, &param)))
	{
		printf("Main: Thread: failed to get param \n."); 
        return ERR_NOT_INIT;
	}
	else if (EOK != (retVal = pthread_attr_setschedpolicy(&thread_attr, SCHED_RR)))
	{
		printf("Main: Thread: failed to set policy \n."); 
        return ERR_NOT_INIT;
	}
	else if (EOK != (retVal = pthread_attr_setstacksize(&thread_attr, CMD_THREAD_STACK_SIZE)))
	{
		printf("Main: Thread: failed to set stack size %d \n.", CMD_THREAD_STACK_SIZE); 
        return ERR_NOT_INIT;
	}

    Platform_Thread_t *pThread = &(hModule->baas.cmdThread);

    // Not used in commands.
    pThread->thread_level = 0;

    pThread->stop = 0;

    pThread->hModule = hModule;

    param.sched_priority = newprio;

    /* setting the new scheduling param */
    if (EOK != (retVal = pthread_attr_setschedparam (&thread_attr, &param)))
    {
        printf("%s failed to set priority for cmd thread. \n.", LOG_ID_STRING);
        return ERR_NOT_INIT;
    }
    else if (EOK != (retVal = sem_init(&(pThread->semaphore), 0, 0)))
    {
        printf("%s failed to sem_init for cmd thread. \n.", LOG_ID_STRING);
        return ERR_NOT_INIT;
    }
    else if (EOK != (retVal = pthread_create(&(pThread->threadHandle), &thread_attr, &cmdThreadFunction, pThread)))
    {
        printf("%s failed to create cmd thread. \n.", LOG_ID_STRING);
        return ERR_NOT_INIT;
    }
    else
    {
        char name[80];

        memset((void*) name, 0, 80);

        memcpy((void*) name, "cmd-thread.", sizeof("cmd-thread."));

        if (EOK != (retVal = pthread_setname_np(pThread->threadHandle, name)))
        {
            printf("%s failed to setname for cmd thread. \n.", LOG_ID_STRING);
            return ERR_NOT_INIT;
        }
        else
        {
            pthread_attr_getstacksize(&thread_attr, &stackSize);

#ifdef VERBOSE_LOGGING
            printf("%s Creating %s with priority %u stack size %lu handle %u - has sem %p arg %p\n",
                   LOG_ID_STRING,
                   name,
                   param.sched_priority,
                   stackSize,
                   pThread->threadHandle,
                   &(pThread->semaphore),
                   pThread);
#endif
        }
    }

    return ERR_OK;
}

static int16_t initialize_ipc(module_t* hModule)
{
    int retVal = EOK;

    // Unlink any existing ones from past runs that were not cleaned.
    shm_unlink(SHARED_MEM_NAME);

    /* Create the shared memory object */
    hModule->baas.cmdFiledesc = shm_open(SHARED_MEM_NAME, O_RDWR | O_CREAT, 0777);

    if (hModule->baas.cmdFiledesc == -1)
    {
        printf("%s error creating the shared memory object for IPC: %s.\n",
                LOG_ID_STRING,  strerror(errno));

        retVal = ERR_NOT_INIT;

        return retVal;

    }

    if (EOK == retVal)
    {
        if (EOK != (retVal = ftruncate(hModule->baas.cmdFiledesc, moduleIpcInfoSize)))
        {
            printf("%s error setting size of the shared memory object for IPC %s.\n",
                    LOG_ID_STRING,  strerror(errno));
        }
        else if (MAP_FAILED == (hModule->baas.commandIpcPtr =
                (shmem_t*)mmap(0, moduleIpcInfoSize, PROT_READ|PROT_WRITE, MAP_SHARED, hModule->baas.cmdFiledesc, 0)))
        {
            printf("%s error mapping shared memory object for IPC %s.\n",
                    LOG_ID_STRING,  strerror(errno));
        }
        else if (EOK != (retVal = sem_init(&(hModule->baas.commandIpcPtr->initiateRequest), 1, 0)))
        {
            printf("Main: Thread: failed to init request semaphore \n.");
            return ERR_NOT_INIT;
        }
        else if (EOK != (retVal = sem_init(&(hModule->baas.commandIpcPtr->requestComplete), 1, 0)))
        {
            printf("Main: Thread: failed to init requestComplete semaphore \n.");
            return ERR_NOT_INIT;
        }
        else if (EOK != (retVal = sem_init(&(hModule->baas.pipeDataLock), 1, 1)))
        {
            printf("Main: Thread: failed to init pipeDataLock semaphore \n.");
            return ERR_NOT_INIT;
        }
        else
        {
            uint8_t *phyMsg = ((uint8_t *)(hModule->baas.commandIpcPtr) + (moduleIpcInfoSize - MAX_MSG_SIZE));

            hModule->baas.cmdMsg = (CART_Phy_Message*)phyMsg;

            // Initialize to identifiable value for diagnostics.
            hModule->baas.cmdMsg->id = 0xFACEFACE; 
            hModule->baas.cmdMsg->size = MAX_MSG_SIZE - 8; 
            memset((void*)hModule->baas.cmdMsg->data, 0xAD, MAX_MSG_SIZE);

#ifdef VERBOSE_LOGGING
            printf("%s mapping shared memory object for IPC mapped at %p.\n",
                    LOG_ID_STRING,  hModule->baas.commandIpcPtr);
#endif
            retVal = initializeCommandThread(hModule);
        }
    }

    return retVal;
}


/** Library initialization.  Final stage of the two-stage initialization of the library
 *
 *  @param   hHandle       Handle created via Create().
 *  @param   pConfig       Pointer to configuration structure.
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t Initialize( void * hHandle, const void * pConfig )
{
    int32_t error;

    if (hHandle == NULL)
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);

    if (!pModule->bCreated)
    {
        return ERR_NOT_CREATED;
    }
    if (pModule->bInited)
    {
        return ERR_ALREADY_INIT;
    }

    error = BAF_init(pModule->baas.baf);

    if (error) 
    {
        printf("Error: init failure %08X\n", error);
        return ERR_NOT_INIT;
    }

    // Message format not defined in APX yet.
    BAF_register_notify((void*)(pModule->baas.baf), notification_handler);

    pModule->baas.baf_enable = 1;

    // Save config params
    if (pConfig == NULL)
    {
        pModule->Config = default_config;
    }
    else
    {
        pModule->Config = *(module_config_t*)(pConfig);
    }

#if defined(MULTIRATE_AUDIOTHREADS)
   if (ERR_OK != initialize_threads(pModule))
   {
        return ERR_NOT_INIT;
   }
#endif

    if (0 != initialize_ipc(pModule))
    {
       return ERR_NOT_INIT; 
    }

   pModule->bInited = true;

#ifdef VERBOSE_LOGGING
    pModule->baas.cnt = 0;

    printf("Init complete.");
#endif 
    return ERR_OK;
}

/** Library reset to initial conditions of current initialization configuration
 *  i.e. resets internal buffers to zeroes
 *
 *  @param   hHandle       Handle created via Create() and initialized via Initialize().
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t Reset( void * hHandle )
{
#ifdef TBD_RESET_CONTEXT
    if ( hHandle == NULL )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }

    // Reset control quantities
    // - this can be done for a created but not initialized instance
    pModule->bMuted = false;
    pModule->fLinearGain = 1.0f;

    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    // Clear internal buffers
    assert ( pModule->pChannelBufs );
    if ( pModule->pChannelBufs )
    {
        memset( pModule->pChannelBufs[0], 0, pModule->Config.uInternalBufLen * pModule->Config.ChanConfig->src_chmap->channels * sizeof(float) );
    }
#endif 
    return ERR_OK;
}

/** Library deinitialization.
 *
 *  @param   hHandle       Handle created via Create().
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t Deinitialize( void * hHandle )
{
#ifdef VERBOSE_LOGGING
    printf("Deinitialize() begin.\n");
#endif

    int retVal = EOK;

    if (hHandle != NULL)
    {
        module_t* pModule = (module_t*)(hHandle);
        if( pModule->bInited )
        {
            Platform_Thread_t *pThread = &(pModule->baas.cmdThread);

            pThread->stop = 1;

            do
            {
                if (EOK != (retVal = sem_post(&(pModule->baas.commandIpcPtr->initiateRequest))))
                {
                    printf("%s sem_post failed for cmd thread. return value %u errno %u.\n",
                           LOG_ID_STRING, retVal, errno);
                }
                else
                {
                    if (EOK == (retVal = pthread_join(pThread->threadHandle, NULL)))
                    {
#ifdef VERBOSE_LOGGING
                        printf("%s cmd thread handle %u joined.\n", LOG_ID_STRING, pThread->threadHandle);
#endif
                        break;
                    }

                    if (ETIMEDOUT == retVal)
                    {
                        printf(" Timeout joining cmd thread handle %u. Retry unlocking.\n", pThread->threadHandle);
                    }
                    else
                    {
                        // Log and break any way.
                        printf(" Error %u joining cmd thread handle %u.\n", retVal, pThread->threadHandle);
                        break;
                    }
                }

            } while(1);


            if (EOK != sem_destroy(&(pModule->baas.commandIpcPtr->initiateRequest)))
            {
                printf(" Failed to destroy IPC semaphore.\n ");
            }
            else if (EOK != (retVal = close(pModule->baas.cmdFiledesc)))
            {
                printf("%s error in close fd : %s.\n", LOG_ID_STRING,  strerror(errno));
            }

            if (EOK != (retVal = munmap(pModule->baas.commandIpcPtr, moduleIpcInfoSize)))
            {
                printf("%s error in shm munmap : %s.\n", LOG_ID_STRING,  strerror(errno));
            }

            if (EOK != (retVal = shm_unlink(SHARED_MEM_NAME)))
            {
                printf("%s error in shm_unlink : %s.\n", LOG_ID_STRING,  strerror(errno));
            }

#ifdef MULTIRATE_AUDIOTHREADS

            uint64_t        timeout;
            struct sigevent event;

            SIGEV_UNBLOCK_INIT (&event);

            // 1 sec.
            timeout = 1LL * 1000000000LL;

            TimerTimeout (CLOCK_MONOTONIC, _NTO_TIMEOUT_JOIN,
                           &event, &timeout, NULL);

            BAF_Resource *resource = BAF_resource(pModule->baas.baf);

            const uint32_t threadCount = resource->num_threads;

            for (int i =0; i < threadCount; i++)
            {
                Platform_Thread_t *pThread = &(pModule->baas.thread[i]);

                // Unblock thread so they can exit gracefully.
                pThread->stop = 1;

                do
                {
                    if (EOK != (retVal = sem_post(&(pThread->semaphore))))
                    {
                        printf(" sem_post failed for %i return value %u errno %u.\n",
                               i, retVal, errno);
                    }
                    else
                    {

                        if (EOK == (retVal = pthread_join(pThread->threadHandle, NULL)))
                        {
#ifdef VERBOSE_LOGGING
                            printf(" Thread %u handle %u joined.\n", i, pThread->threadHandle);
#endif
                            break;
                        }

                        if (ETIMEDOUT == retVal)
                        {
                            printf(" Timeout joining thread %u handle %u. Retry unlocking.\n", i, pThread->threadHandle);
                        }
                        else
                        {
                            // Log and break any way.
                            printf(" Error %u joining thread %u handle %u.\n", retVal, i, pThread->threadHandle);
                            break;
                        }
                    }

                } while(1);
            }
#endif  // MULTIRATE_AUDIOTHREADS

            pModule->bInited = false;
        }
    }

#ifdef VERBOSE_LOGGING
    printf("Deinitialize(). return value %u.\n", retVal);
#endif

    return retVal;
}


/** Get supported PCM sample rates
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   pulRates           OUT: Supported sample rates as bitmask of SND_PCM_RATE_*
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t GetSupportedPcmRates( void * hHandle, uint32_t * pulRates )
{
    if ( (hHandle == NULL) || (pulRates == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    // Above checks not really needed if supported sample rates is independent of configuration

    *pulRates = SND_PCM_RATE_48000;
    return ERR_OK;
}

/** Get supported PCM sample formats
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   pulFormats         OUT: Supported sample formats as bitmask of SND_PCM_FMT_*
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t GetSupportedPcmFormats( void * hHandle, uint32_t * pulFormats )
{
    if ( (hHandle == NULL) || (pulFormats == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    // Above checks not really needed if supported sample formats is independent of configuration

    *pulFormats = SND_PCM_FMT_FLOAT;
    return ERR_OK;
}

/** Get supported PCM channel info
 *  - currently only checked for SND_PCM_CHNINFO_INTERLEAVE and SND_PCM_CHNINFO_NONINTERLEAVE
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   pulChannelInfo     OUT: Supported channel info as bitmask of SND_PCM_CHNINFO_*
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t GetSupportedPcmChannelInfo( void * hHandle, uint32_t * pulChannelInfo )
{
    if ( (hHandle == NULL) || (pulChannelInfo == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    // Above checks not really needed if supported channel info is independent of configuration

    *pulChannelInfo = SND_PCM_CHNINFO_NONINTERLEAVE;
    return ERR_OK;
}


/** Get supported channel configurations
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   ppaChConfigs       OUT: Pointer to array of supported channel configs (pairings of source-input channel map & dest-output channel map)
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t GetSupportedChannelConfigs( void * hHandle, chconfig_t const * const * * ppaChConfigs )
{
    if ( (hHandle == NULL) || (ppaChConfigs == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    *ppaChConfigs = chconfig_list;

    return ERR_OK;
}

/** Process frame of audio data
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   in_data_ptr        IN: Frame of input samples in non-interleaved order.
 *  @param   out_data_ptr       OUT: Frame of output samples in non-interleaved order.
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t Process( void * hHandle, float * pfInData, float * pfOutData )
{
    if ((NULL == pfInData) || (NULL == pfOutData) || (NULL == hHandle))
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);

    if (!pModule->bCreated)
    {
        return ERR_NOT_CREATED;
    }

    if (!pModule->bInited)
    {
        return ERR_NOT_INIT;
    }
    
    if (0 == pModule->baas.baf_enable)
    {
        return ERR_NOT_INIT;
    }

    pModule->pInputBuffer = pfInData;

    pModule->pOutputBuffer = pfOutData;

#ifdef VERBOSE_LOGGING
    pModule->baas.cnt++;

    // printf("        Process %u.\n", pModule->baas.cnt);
#endif

    // This IS the base thread bcos of BAF_exec().
    BAF_exec(pModule->baas.baf, PLATFORM_BASETHREADLEVEL, pModule);

#ifdef MULTIRATE_AUDIOTHREADS
    BAF_Resource *resource = BAF_resource(pModule->baas.baf);

    uint32_t threadCount = resource->num_threads;

    for (int i =0; i < threadCount; i++)
    {
        Platform_Thread_t *pThread = &(pModule->baas.thread[i]);

        if (1 == pThread->exec)
        {
            while (sem_wait(&(pThread->wait)) && (errno == EINTR))
            {
            }

            pThread->exec = 0;
        }
    }
#endif  // MULTIRATE_AUDIOTHREADS

    return ERR_OK;
}


/** Get sample rate
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   puSampleRate       OUT: Sample rate (Hz)
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t GetSampleRate( void * hHandle, uint32_t * puSampleRate )
{
    if ( (hHandle == NULL) || (puSampleRate == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    *puSampleRate = pModule->Config.uSampleRate;
    return ERR_OK;
}

/** Get number of samples per frame (per channel)
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   puNumSamples       OUT: Number of samples per frame
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t GetSamplesPerFrame( void * hHandle, unsigned int * puNumSamples )
{
    if ( (hHandle == NULL) || (puNumSamples == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    *puNumSamples = pModule->Config.uSamplesPerFrame;
    return ERR_OK;
}

/** Get number of input and output channels
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   puNumChanIn        OUT: Number of input channels
 *  @param   puNumChanOut       OUT: Number of output channels
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t GetChannelCounts( void * hHandle, unsigned int * puNumChanIn, unsigned int * puNumChanOut )
{
    if ( (hHandle == NULL) || (puNumChanIn == NULL) || (puNumChanOut == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    *puNumChanIn  = pModule->Config.ChanConfig->src_chmap->channels;
    *puNumChanOut = pModule->Config.ChanConfig->dst_chmap->channels;
    return ERR_OK;
}

/** Get processing delay in samples
 *
 *  @param   hHandle            Handle created via Create() and initialized via Initialize().
 *  @param   puProcessingDelay  OUT: Processing delay in samples
 *
 *  @return  Result status
 *  @retval  #ERR_OK                        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t GetProcessingDelay( void * hHandle, unsigned int * puProcessingDelay )
{
    if ( (hHandle == NULL) || (puProcessingDelay == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);
    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    // Delay, if present, could be: pModule->Config.uInternalBufLen - pModule->Config.uSamplesPerFrame
    *puProcessingDelay = 0; // pModule->Config.uProcessingDelay;

    return ERR_OK;
}


/** General data transfer method
 *
 *  This function passes data from the caller to the module and from the module back to the caller.
 *  - the format and interpretation of the data payload is at the discretion of the module and caller.
 *
 *  @param   hHandle        Handle created via Create() and initialized via Initialize().
 *  @param   ulSize         IN: Size of memory buffer. This determines the transfer capacity in each
 *                          direction per call
 *  @param   pData          IN/OUT: Pointer to memory buffer to be filled with data payloads in each direction
 *
 *  @return  Result status
 *  @retval  #ERR_OK        No error.
 *  ...
 */
/*======================================================================================*/
static int16_t PipeData( void * hHandle, size_t ulSize, void * pData )
{   
    if ( (hHandle == NULL) || (pData == NULL) )
    {
        return ERR_NULL_POINTER;
    }

    module_t* pModule = (module_t*)(hHandle);

    if ( !pModule->bCreated )
    {
        return ERR_NOT_CREATED;
    }
    if ( !pModule->bInited )
    {
        return ERR_NOT_INIT;
    }

    // NOTE: ulSize is the size allocated for pDATA - NOT the size of payload?!
    // so, I need the size of payload also as part of the msg. not as arg of API.

    if (ulSize < headerSize)
    {
        printf("Error: msg buffer allocated too small -  %ld bytes.\n", ulSize);

        return ERR_INVALID_SIZE;
    }

    // Serialize access to command processing APIs.
    while (sem_wait(&(pModule->baas.pipeDataLock)) && (errno == EINTR))
    {
    }

    // Subtract the message ID size to get the rest of the payload size.
    // Use this for to prevent response buffer overflow: ulSize = ulSize - 2;
    uint8_t* ioBuffer = (uint8_t*)pData;

    BAF *baf = pModule->baas.baf;

    BAF_Message baf_message_req;

    CART_Message_initialize(&baf_message_req, (CART_Phy_Message*)ioBuffer);

    // Response buffer payload size
    uint32_t responseOffset = headerSize + CART_Message_get_size(&baf_message_req);

    // The expected size is sum of payload and header. So, reinitialize it.
    // Talaria seems to expect a minimum size of 32 bits (atleast msg ID must be present).
    CART_Message_set_size(&baf_message_req, responseOffset);

    BAF_Message baf_message_rsp;

    CART_Message_initialize(&baf_message_rsp, (CART_Phy_Message*)&(ioBuffer[responseOffset]));

    // Set the available buffer size.
    CART_Message_set_size(&baf_message_rsp, ulSize - responseOffset);

#ifdef VERBOSE_LOGGING
    if (0 != responseOffset)
    {
        for (int i = 0; i < responseOffset; i++)
        {
            printf("%x ", ioBuffer[i]);
        } 
        printf(" msg addr %x. \n", pModule->baas.cmdMsg);
    }
#endif  //  VERBOSE_LOGGING

    BAF_command(baf, &baf_message_req, &baf_message_rsp);

    uint32_t outsize = CART_Message_get_size(&baf_message_rsp);

    int16_t retVal = ERR_OK;

    if ((responseOffset + outsize) > ulSize)
    {
        printf("Response size + request size greater than buffer size. Potential memory corruption. \n");

        retVal = ERR_INVALID_SIZE;
    }
    else
    {
        CART_Message_copy_header((CART_Phy_Message*)&(ioBuffer[responseOffset]), &baf_message_rsp);
    
#ifdef VERBOSE_LOGGING
        if (0 != outsize)
        {
            printf("Resp payload sz %u header %u.\n", outsize, headerSize);

            printf("%08x ", CART_Message_get_id(&baf_message_rsp));
            printf("%08x ", outsize);

            for (int i = headerSize; i < headerSize + outsize; i++)
            {
                printf("%02x ", ioBuffer[headerSize + i]);
            }
            printf("\n");
        }
#endif  //  VERBOSE_LOGGING
    }

    int value = 0;

    if (EOK != (value = sem_post(&(pModule->baas.pipeDataLock))))
    {
        printf(" PipeDataLock sem_post failed. Return value %x. %s.\n",
                value, strerror(errno));
    }

    return retVal;
}

/** Get binary config data corresponding to the requested parameters
 *
 *  In practice, this method is probably not needed as binary config data will 
 *  most likely be stored and loaded from the target file system.
 *
 *  The passed back data is valid until the next call to this method.
 *  i.e. subsequent calls to this method will overwrite previous results.
 *
 *  NOTE: this should be consistent with GetSupportedChannelConfigs() above
 *
 *  @param   sample_rate   
 *  @param   num_channels_in 
 *  @param   num_channels_out 
 *  @param   ppConfig           OUT: Pointer to binary config data with requested paramss
 *
 *  @return  Result status
 *  @retval  #ERR_OK                            No error.
 *  ...
 */
/*======================================================================================*/
int16_t GetConfig( uint32_t sample_rate, snd_pcm_chmap_t const * const src_chmap, snd_pcm_chmap_t const * const dst_chmap, void const * * ppConfig)
{
    static module_config_t config; 

    config = default_config;    

    if ( dst_chmap->channels == 4 ) 
    {
        config.ChanConfig = & chconfig_2in4out;
    }

    config.uSampleRate = sample_rate;

    *ppConfig = &config;

    return ERR_OK;
}


/* ---- Externals ---------------------------------------------------------------------*/

const module_funcs_t module_funcs =
{
    .get_version = GetVersion,
    .set_allocator = SetAllocator,
    .create = Create,
    .destroy = Destroy,
    .initialize = Initialize,
    .reset = Reset,
    .deinitialize = Deinitialize,
    .get_supported_pcm_rates = GetSupportedPcmRates,
    .get_supported_pcm_formats = GetSupportedPcmFormats,
    .get_supported_pcm_channel_info = GetSupportedPcmChannelInfo,
    .get_supported_channel_configs = GetSupportedChannelConfigs,
    .get_sample_rate = GetSampleRate,
    .get_samples_per_frame = GetSamplesPerFrame,
    .get_channel_counts = GetChannelCounts,
    .get_processing_delay = GetProcessingDelay,
    .process = Process,
    .pipe_data = PipeData,
    .get_config = GetConfig,
};
